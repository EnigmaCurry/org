#+hugo_base_dir: ../hugo
#+hugo_section: /portable-docker
#+hugo_weight: auto
#+hugo_paired_shortcodes: %notice badge button %children %index run stdout edit math mermaid openapi toc env
#+STARTUP: align

* Portable Docker: Build and Deploy Anywhere with WireGuard Tunneling
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :linkTitle Portable Docker
:EXPORT_HUGO_WEIGHT: 3000
:END:

This book serves as a guide to installing Docker on a small, portable
Linux device (eg. Raspberry Pi), and deploying some web service
containers on it. You'll also create and configure a public cloud
server (eg. DigitalOcean droplet). The cloud serverâ€™s sole purpose is
to host a WireGuard VPN and proxy, enabling the Raspberry Pi to
securely connect from any location.

Through the encrypted tunnel established by this connection, the Pi
can publish services to the internet, even when operating behind a
restrictive firewall, such as public WiFi, mobile hotspots, and
carrier-grade NAT. As long as you can get unblocked /outgoing/
internet access, you can host your public roaming server from
anywhere!

#+attr_shortcode: :icon code-branch :style primary :href https://github.com/EnigmaCurry/d.rymcg.tech#readme
#+begin_button
d.rymcg.tech
#+end_button

#+attr_shortcode: :icon comment-dots :style red :href https://matrix.to/#/#d.rymcg.tech:enigmacurry.com
#+begin_button
Chat with us on Matrix
#+end_button

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: introduction
:EXPORT_HUGO_WEIGHT: 100
:END:
* Setup DNS
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: setup-dns
:EXPORT_HUGO_WEIGHT: 150
:END:
** Setup DNS
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 151
:END:

** Register domain name
:PROPERTIES:
:EXPORT_FILE_NAME: register-domain
:EXPORT_HUGO_WEIGHT: 160
:END:

To host a web service, one of the first things you will need is to
register your domain name. This will be the domain name used for all
of your service links, and it is what your users will need to type
into their browsers (or click on) to visit your pages.

Public domain names are a scarce resource. Because of their scarcity,
you must pay for your domain registrations, doing so in 1 year
increments. If domain names were free, all the good ones would be
taken by now, but because they cost money, there are still some good
enough ones left to be had. In return for your fee, you receive
exclusive use of the domain name for the period that you paid for. You
"own" the domain name, and its configuration, but you need to keep
paying a registrar to keep the record active (so its more like
renting). You can pre-pay for several years in advance, or for just
pay one year at a time. If you stop paying, and the records expire,
they will no longer resolve to your services, and you may lose control
of the domain, possibly forever.

*** Register an Internet domain name

You can buy (rent) a domain name from lots of places. For
documentation purposes, we will use [[https://www.gandi.net][Gandi.net]], but these instructions
will be similar regardless of the domain provider you pick.

#+attr_shortcode: :style info :title Setup on Gandi.net
#+begin_notice
 * Sign up for an account at [[https://www.gandi.net/][Gandi.net]]
 * Once signed in, from your dashboard, click =Register=.
 * Search for any domain name you like, eg. =your-name.com=.
 * Add your domain to the shopping cart, go to checkout, and complete
   your purchase.
 * Once you have purchased the domain, it should show up in your
   =Dashboard=, under the =Domain= tab.
 * Leave this browser tab open, you will return to it in the next
   chapter.
#+end_notice

*** Transfer DNS to DigitalOcean

#+attr_shortcode: :style secondary :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].
#+end_notice

#+attr_shortcode: :style info :title Setup on Gandi.net
#+begin_notice

 * Login to your [[https://admin.gandi.net][gandi.net]] dashboard.
 * Click the =Domain= tab.
 * Find your domain name in the list and click on it.
 * Click on the =Nameservers= tab.
 * Click on the edit button to create new =External nameservers=.
 * Delete all existing nameservers that may exist.
 * Add the following nameservers, specific to DigitalOcean:
   
   * =ns1.digitalocean.com=
   * =ns2.digitalocean.com=
   * =ns3.digitalocean.com=
#+end_notice

Wait a few minutes for the change to take effect, then you can verify
the setting from your workstation, using the =whois= command:

#+begin_run
whois example.com
#+end_run

#+begin_stdout
Domain Name: example.com
Registrar WHOIS Server: whois.gandi.net
Name Server: ns1.digitalocean.com
Name Server: ns2.digitalocean.com
Name Server: ns3.digitalocean.com
#+end_stdout

The output shows a report for your domain registration, including the
list of the new nameservers.

** Add domain to DigitalOcean DNS
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token
:EXPORT_HUGO_WEIGHT: 161
:END:

The [[https://www.rfc-editor.org/rfc/rfc1035][Domain Name System]] is how you can associate one of your
sub-domains with an actual IP address on the internet.

#+attr_shortcode: :style secondary :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].

Sign up for a [[https://m.do.co/c/d827a13964d7][DigitalOcean account]] (using this referral link helps
support this site), and follow along to setup your domain's DNS.
#+end_notice

*** Add your domain name

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =Networking= in the left hand menu.
 * Select the =Domains= tab.
 * Enter your domain name, and click =Add Domain=.

Wait a few minutes for the setting to take effect, then you can verify
the domain name is added:

#+begin_run
# install dig from bind-utils package.
dig -t ns example.com
#+end_run

(if you don't have =dig= installed, you can also use [[https://toolbox.googleapps.com/apps/dig/][the web version
provided by google]], enter the domain name, and select =NS=.)

#+begin_stdout
;; ANSWER SECTION:
example.com.             2400    IN      NS      ns1.digitalocean.com.
example.com.             2400    IN      NS      ns3.digitalocean.com.
example.com.             2400    IN      NS      ns2.digitalocean.com.
#+end_stdout

** Generate DigitalOcean API token for ACME challenge
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token-for-acme-challenge
:EXPORT_HUGO_WEIGHT: 255
:END:
#+attr_shortcode: :style secondary :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].
#+end_notice

DNS is also a part of the TLS certificate request process (ACME DNS-01
challenge). You will need to procure a DigitalOcean Personal Access
Token, which is used for programatic control of your DigitalOcean
account's DNS settings on your behalf:

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =API= in the left hand menu, near the bottom of the list.
 * On the =Tokens= tab, click =Generate New Token=.
 * Enter a descriptive name indicating the owner of the token (eg. a
   subdomain), and its purpose (eg. ACME): =pi5.example.com ACME=.
 * Set the expiration period you want to use. Use =No expire= if you
   just want to set it and forget it, otherwise you will need to
   update the token periodically.
 * Select =Custom Scopes= so you can choose the fine-grained
   permissions.
 * The only permission that needs to be selected is =domain= (you may
   also choose finer grained permissions of =update=, =read=, and
   =create=, but not =delete=).
 * Click =Generate Token=.
 * Copy the generated token to a temporary buffer/notepad. You will
   need to reference this token in the next section, when it asks for
   the =DO_AUTH_TOKEN= variable.

* Setup Raspberry Pi
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: setup-raspberry-pi
:EXPORT_HUGO_WEIGHT: 200
:END:
** Setup Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 201
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Build your Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: build-your-pi
:EXPORT_HUGO_WEIGHT: 210
:END:

These are the parts you will need to source for this build:

#+attr_shortcode: :title Raspberry Pi 5 motherboard
#+begin_notice
[[/img/portable-docker/pi5.webp]]
#+end_notice
The Raspberry Pi 5 is often sold in kits, but you can also buy the
motherboard separately. If buying a pre-made kit, make sure it
includes an NVME shield to plug in an NVME SSD. Otherwise, this can be
purchased separately:

#+attr_shortcode: :title Geeekpi case, heatsink, NVME shield, and power supply
#+begin_notice
[[/img/portable-docker/geeekpi5case.webp]]
#+end_notice
This kit comes with the NVME shield, which is the adapter to install
on top of the Raspberry Pi 5 motherboard. This allows you to plug in a
full size NVME SSD. The metal case fits the extended height neccessary
to fit the NVME shield and SSD. The kit also includes the required
heatsink and power supply.

#+attr_shortcode: :title Sandisk SD card (32GB)
#+begin_notice
[[/img/portable-docker/sandisk-32GB-sdcard.webp]]
#+end_notice

The SD card is used as the root filesystem for Raspbian. It doesn't
need to be very big, as you won't be storing very much data on this.
Booting from the SD-card is slower than NVME, but the advantage of it
is that you can simply swap SD-cards to temporarily use the pi for a
different purpose, without disrupting access to your NVME storage.

#+attr_shortcode: :title Samsung 990EVO NVME SSD
#+begin_notice
[[/img/portable-docker/samsung-990EVO-NVME.webp]]
#+end_notice

The NVME SSD is much faster, and far more reliable, than the SD card.
This storage will be used exclusively for the Docker storage system
(mounted at =/var/lib/docker=). This is where all of your container
images and data will live.

*** Putting everything together

 * Read the directions that come with the case.
 * Install the heatsink to the Pi 5 motherboard first.
 * Install the motherboard into the bottom part of the case.
 * Install the NVME shield on top of the Pi motherboard. The hat plugs
   into the GPIO pins of the motherboard, and risers sandwich things
   together.
 * Install the NVME into the NVME shield.
 * Screw on the top part of the case.
 * Install the SD-card into the slot on the bottom edge.

#+attr_shortcode: :title Pi 5 installed on risers inside Geeekpi case, NVME shield installed on top
#+begin_notice
[[/img/portable-docker/pi5-profile.webp]]
#+end_notice

#+attr_shortcode: :title NVME SSD installed in the NVME shield
#+begin_notice
[[/img/portable-docker/pi5-nvme.webp]]
#+end_notice

#+attr_shortcode: :title SD-card installed
#+begin_notice
[[/img/portable-docker/pi5-sdcard.webp]]
#+end_notice

#+attr_shortcode: :title The fully assembled Raspberry Pi 5
#+begin_notice
[[/img/portable-docker/pi5-assembled.webp]]
#+end_notice

** Install Raspbian
:PROPERTIES:
:EXPORT_FILE_NAME: install-raspbian
:EXPORT_HUGO_WEIGHT: 220
:END:

The best way to install Raspbian onto an sd-card, is to use the
[[https://www.raspberrypi.com/documentation/computers/getting-started.html][rpi-imager program]] from another computer. This allows you to setup the
user account, network settings, and SSH credentials all from the
imager software.

 * [[https://www.raspberrypi.com/software/][Download the Raspberry PI
   Imager]] or install
   =rpi-imager= from your package manager.
 * Run =rpi-imager=.
 * Click on the menu labled =Rasperry Pi Device=.
   * Choose your model of raspberry pi.
   
 * Click on the menu labeled =Operating System=
   * Choose =Raspberry PI OS (other)=
   * Choose =Raspberry PI OS Lite (64-bit)=.
   
 * Click on the menu labeled =Storage=.
   * Choose the Storage device to install to.
   * You may need to change the ownership of the device (eg. I had to
     do =sudo chown ryan /dev/sdb= first).
     
 * Click =Next=.
 
 * Click =Edit Settings=.
 
   * On the =General= tab:
   
     * Enter the hostname
     * Enter a username and password.
     * Optionally setup the Wifi (I just use ethernet instead).
     * Set locale settings. I set mine to UTC.
     
   * On the =Services= tab:
   
     * Click =Enable SSH=
     * Choose =Allow pulbic-key authentication only=
     * Paste the list of your SSH public keys into the box. (Find them
       on your workstation by running =ssh-add -L= or look in
       =~/.ssh/*.pub=)
       
   * On the =Options= tab:
   
     * Unselect =Enable telemetry= unless you're into that sort of
       thing.
       
 * Click =Yes= to the question =Would you like to apply OS custom settings=.
 
 * Confirm you would like to write to the sd-card and wait for it to complete.
 
 * Once complete, unplug the sd-card, put it into the raspberry pi,
   plug in the ethernet, and power it on.

*** Setup ssh config on your workstation

To connect to the pi remotely via SSH, you will need an SSH config
file on your workstation (eg. your laptop).

 * Create an SSH config entry in =$HOME/.ssh/config= like so (replace =X.X.X.X= with the ip address of the pi):

: Host pi
:   Hostname X.X.X.X
:   User pi
:   ControlMaster auto
:   ControlPersist yes
:   ControlPath /tmp/ssh-%u-%r@%h:%p

 * Now test SSH connection works and SSH into the pi (eg =ssh pi=)

*** Setup Log2Ram

You can increase the expected lifespan of your SD card by installing
[[https://github.com/azlux/log2ram#log2ram][log2ram]]

** Setup networking
:PROPERTIES:
:EXPORT_FILE_NAME: setup-networking
:EXPORT_HUGO_WEIGHT: 230
:END:

*** WiFi

You may have already configured the WiFi in the rpi-imager options,
but if not, you can do so after its been installed.

SSH into the pi, and then run:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo raspi-config
#+end_run

 * Enter =System Options=.
 * Enter =S1 Wireless LAN=.
 * Choose your current country.
 * Enter the SSID (WiFi network name) you wish to connect to.
 * Enter the network passphrase

*** Configure DNS

By default, DNS is handled via DHCP, which will probably work in the
majority of cases. However, you may wish to hardcode specific DNS servers instead:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo -e "nameserver 1.1.1.1" | sudo tee /etc/resolv.conf
sudo chattr +i /etc/resolv.conf
#+end_run

=chattr +i= prevents DHCP from overwriting this file.

** Install Docker
:PROPERTIES:
:EXPORT_FILE_NAME: install-docker
:EXPORT_HUGO_WEIGHT: 240
:END:
*** Install Docker

 * On the pi, install docker:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run   
curl -sSL https://get.docker.com | sh
#+end_run

 * Test docker is working: 

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo docker run hello-world
#+end_run

  * If working, you should see a =Hello from Docker!= message and some other help info.

*** Setup SSH Docker context

[[https://github.com/enigmacurry/d.rymcg.tech][d.rymcg.tech]] requires the use of an SSH [[https://docs.docker.com/engine/manage-resources/contexts/][Docker context]], rather than
the default socket context.

Create a new SSH key (without a passphrase):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519
#+end_run

Add the key to the root user's =/root/.ssh.authorized_keys= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat ~/.ssh/id_ed25519.pub | sudo tee -a /root/.ssh/authorized_keys
#+end_run

Create a config named =pi= in your =~/.ssh/config=:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host pi
    User root
    Hostname localhost
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

Test the connection is working:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh pi whoami
#+end_run

Accept the key fingerprint it offers:

#+begin_stdout
The authenticity of host 'localhost (::1)' can't be established.
ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
#+end_stdout

If it worked, you should see the output of =whoami= which should print
the username =root= (which is the user configured by SSH).

Create a new docker SSH context using the SSH config you had just
created (=pi=):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context create pi --docker "host=ssh://pi"
#+end_run

Switch to use the SSH context as the default:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context use pi
#+end_run

Now, when you run any docker command, it will use the SSH context:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker info | grep -iE "(Name|Context)"
#+end_run

This should print the proper context: =pi=.

** Install d.rymcg.tech
:PROPERTIES:
:EXPORT_FILE_NAME: install-d-rymcg-tech
:EXPORT_HUGO_WEIGHT: 250
:END:

*** Install prerequisites

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo apt-get install bash build-essential gettext git openssl \
apache2-utils xdg-utils jq sshfs wireguard curl inotify-tools w3m
#+end_run

*** Clone the d.rymcg.tech git repository

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
git clone https://github.com/EnigmaCurry/d.rymcg.tech.git \
    ${HOME}/git/vendor/enigmacurry/d.rymcg.tech

cd ${HOME}/git/vendor/enigmacurry/d.rymcg.tech
#+end_run

*** Run the main config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
## Run this in the root source directory of d.rymcg.tech:
make config
#+end_run

*** Follow the interactive prompts to finish configuration

**** Install script-wizard
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_stdout
This utility can automatically install a required helper tool called script-wizard.
See https://github.com/enigmacurry/script-wizard

Do you wish to automatically install script-wizard into `_scripts/script-wizard`? (Y/n): y
#+end_stdout

[[https://github.com/EnigmaCurry/script-wizard][script-wizard]] is required dependency that can be downloaded and
installed automatically. =script-wizard= makes interactive input and
selection wizards in Bash a lot nicer.

**** Acknowledge the detected Docker context
#+begin_stdout
? This will make a configuration for the current docker context (pi). Proceed? (Y/n)  y
#+end_stdout

**** Choose the root domain name for this server

#+begin_stdout
ROOT_DOMAIN: Enter the root domain for this context (eg. d.example.com)
: d.example.com
#+end_stdout

Instead of =d.example.com= you should type the actual domain name (or
subdomain name) that you want to use as the root domain for all of
your services on this server.

For example, if you entered =example.com=, you will later install apps
(eg. =whoami=) with subdomains like =whoami.example.com=. Choosing a
deeper subdomain has the benefit of being able to share a single root
domain name amongst several Docker instances, therefore with the
example of =d.example.com= the service would be deployed like
=whoami.d.example.com=, and a second Docker instance could use
=d2.example.com=, with services like =whoami.d2.example.com=.

**** Choose to save generated passwords.json files by default
#+begin_stdout
Every time you configure HTTP Basic Authentication, you are asked if you wish to save the cleartext passwords
into passwords.json (in each project directory). If you were to press Enter without answering the question,
the default answer is No (displayed as y/N). You may change the default response to Yes (displayed as Y/n).
? Do you want to save cleartext passwords in passwords.json by default? (y/N)  y
#+end_stdout

This question is in regards to the integrated HTTP Basic Auth setting,
which allows you to store the plain text credentials in the file named
=passwords.json= in the various project directories. This is a
convenience feature, but you may not want it. Its not really a
security concern, because the same password is also availalbe in the
.env file for the project anyway, so go ahead an enable it.

*** Configure Bash shell integration

Configure the =pi= user's =~/.bashrc= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;'EOF' &gt&gt ~/.bashrc
export PATH=${PATH}:${HOME}/git/vendor/enigmacurry/d.rymcg.tech/_scripts/user
eval "$(d.rymcg.tech completion bash)"
__d.rymcg.tech_cli_alias d
EOF
#+end_run

Once finished, logout and log back in.

Now you have a new alias named =d= that controls =d.rymcg.tech=. Check
out the main help screen:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d
#+end_run

#+begin_stdout
## Main d.rymcg.tech sub-commands - Optional arguments are printed in brackets [OPTIONAL_ARG]
cd [SUBDIR]                   Enter a sub-shell and go to the ROOT_DIR directory (or given subdirectory)
make [PROJECT] [ARGS ...]     Run a `make` command for the given d.rymcg.tech project name
context                       View or set the current Docker context
new-context                   Create a new Docker context
tmp-context                   Use a temporary Docker context in a sub-shell
ssh [COMMAND ...]             Run command or shell on active docker context SSH host
completion                    Setup TAB completion in your shell
install                       Install an app interactively
install-docker                Install Docker Engine on the host
status                        Show status of all installed services
audit                         Print security audit of running containers

## Documentation sub-commands:
help                          Show this help screen
list                          List available d.rymcg.tech projects
                              (not including external projects, unless you symlink them into ROOT_DIR)
readme                        Open the main d.rymcg.tech README.md in your browser
readme [PROJECT]              Open the README.md for the given project name
readme digitalocean           Open root documentation file: DIGITALOCEAN.md
readme security               Open root documentation file: SECURITY.md
readme aws                    Open root documentation file: AWS.md
readme license                Open root documentation file: LICENSE.txt
readme raspberry_pi           Open root documentation file: RASPBERRY_PI.md
readme makefile_ops           Open root documentation file: MAKEFILE_OPS.md
#+end_stdout

** Install Traefik
:PROPERTIES:
:EXPORT_FILE_NAME: install-traefik
:EXPORT_HUGO_WEIGHT: 260
:END:

[[https://doc.traefik.io/traefik/][Traefik]] is the application proxy (HTTP / TCP / UDP) that is the
entrypoint, and router, for all of your web services. Traefik
facilitates automatic TLS certificate requests via Let's Encrypt, and
handles transport security for all of your applications. Traefik is
configured to support several authentication + sentry authorization
mechanisms, including: HTTP Basic Auth, OAuth2, mutual TLS, and IP
address filtering.

*** Basic Traefik config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik config
#+end_run

This presents the interactive configuration menu for Traefik:

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)
[â†‘â†“ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

You can use the up and down arrow keys to choose the selection, and
you may type to narrow the list. Select the =Config= entry and press
the =Enter= key.

**** Traefik Config

#+attr_shortcode: :style secondary :title Don't wander off
#+begin_notice
The Traefik configuration is extensive. This section will only show
you how to configure Traefik for a basic install. Many of the menu
options will be skipped for the time being. Follow these instructions
exactly, and don't go wandering through the other menus just yet.
#+end_notice

#+begin_stdout
During first time setup, you must complete the following tasks:

 * Create Traefik user.
 * Configure TLS certificates and ACME (optional).
 * Install traefik.

Traefik must be re-installed to apply any changes.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


? Traefik Configuration:  
> Traefik user
  Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level
[â†‘â†“ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

***** Traefik user

Select the =Traefik user= option to create the traefik user on the
host.

***** TLS certificates and authorities

 * Select =TLS certificates and authorities=.
 * Select =Configure ACME (Let's Encrypt or Step-CA)=.
   * Select =Let's Encrypt (ACME)=.
   * Select =Production (recommended!)= to choose the production Lets
     Encrypt environment.
   * Select =DNS-01= as the ACME challenge type.
   * Enter an email address for ACME registration (100% optional)

****** TRAEFIK_ACME_DNS_PROVIDER     
   * Enter the ACME DNS provider: =digitalocean=
#+begin_stdout
TRAEFIK_ACME_DNS_PROVIDER: Enter the LEGO code for your DNS Provider (eg. digitalocean)
: digitalocean
#+end_stdout

****** TRAEFIK_ACME_DNS_VARNAME_1
   * Enter the  VAR /name/ that  the DigitalOcean LEGO  provider uses,
     which is literally: =DO_AUTH_TOKEN=
   * ([[https://go-acme.github.io/lego/dns/index.html][If you use a
     different DNS provider, lookup the LEGO docs for the specific var
     names used by your provider.]])

   
#+begin_stdout
You need to enter the NAMES of these variables that your provider needs.
You can enter up to 5 variable names and/or leave them blank
TRAEFIK_ACME_DNS_VARNAME_1: Enter the 1st DNS provider variable name (eg. DO_AUTH_TOKEN)
: DO_AUTH_TOKEN
#+end_stdout
     
****** TRAEFIK_ACME_DNS_VARNAME_2
   * Enter a blank value for the second VAR name, because there are no
     additional variables to enter:
#+begin_stdout
TRAEFIK_ACME_DNS_VARNAME_2: Enter the 2nd DNS provider variable name (or leave blank)
: 
#+end_stdout

****** DO_AUTH_TOKEN
  * Enter the actual value for the =DO_AUTH_TOKEN=:

#+attr_shortcode: :style secondary :title DO_AUTH_TOKEN
#+begin_notice
The value of DO_AUTH_TOKEN should be the DigitalOcean Personal Access
Token that you generated in one the previous sections.
#+end_notice
  
#+begin_stdout
Now to enter the values for the custom DNS API variables:
DO_AUTH_TOKEN: Enter the value for DO_AUTH_TOKEN (eg. your-actual-digitalocean-token-here)
: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#+end_stdout

****** Select =Configure TLS certificates (make certs)=.
   * Select =Create a new certificate=

#+begin_stdout
> Traefik Configuration: TLS certificates and authorities

> Traefik TLS config: Configure TLS certificates (make certs)

> Configure Traefik TLS certificates Create a new certificate.
Set TRAEFIK_ACME_CERT_DOMAINS=[["",[]]]
Enter the main domain (CN) for this certificate (eg. `d.rymcg.tech` or `*.d.rymcg.tech`)
: d.example.com
#+end_stdout

Instead of =d.example.com=, enter the same root domain name you chose
before.

****** Enter secondary (SANS) domains
#+begin_stdout
Now enter additional domains (SANS), one per line:
Enter a secondary domain (enter blank to skip)
: *.d.example.com
#+end_stdout

For the SANS domain, enter the wildcard subdomain of the same domain
as before, like =*.d.example.com=.

#+begin_stdout
Enter a secondary domain (enter blank to skip)
: 
#+end_stdout

It will continue asking you to enter additional SANS domains until you
enter a blank response, so just press Enter on the blank line.

****** Certificate summary

#+begin_stdout
Main domain:
 pi5.forwarding.network
Secondary (SANS) domains:
 *.pi5.forwarding.network
#+end_stdout

Finally a summary of the certificate request is printed.

 * Press the =ESC= key three times to go back to the main menu.

*** Install Traefik

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
[â†‘â†“ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

On the main menu, select =Install (make install)=.

Wait for the Traefik service to be installed, and then you will be
returned to the main menu.

Press the =Esc= key to quit the Traefik configuration.

*** Verify Traefik status

You can check to see that Traefik has started:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik status
#+end_run

You should see two services running, =traefik=, and
=traefik-error-pages=, both in state =running=:

#+begin_stdout
NAME                   ENV              IMAGE                           STATE
traefik-error-pages-1  .env_pi_default  tarampampam/error-pages:2.25.0  running
traefik-traefik-1      .env_pi_default  traefik-traefik                 running
#+end_stdout

** Install Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: install-whoami
:EXPORT_HUGO_WEIGHT: 261
:END:
#+attr_shortcode:
#+begin_toc
table of contents
#+end_toc

*** What is Whoami?

[[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master/whoami#readme][Whoami]] is a web application that simply outputs the request headers
that it receives (reflecting them back to the requesting client):

#+attr_shortcode: :title Run this later after you install it: :style none
#+begin_run
curl https://whoami.example.com
#+end_run

#+begin_stdout
Name: default
Hostname: 38704012c4b3
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:34610
GET / HTTP/1.1
Host: whoami.example.com
User-Agent: curl/7.88.1
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: 10.93.23.114
X-Forwarded-Host: whoami.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: docker
X-Real-Ip: 10.93.23.114
#+end_stdout

This output is useful for end-to-end testing, to verify that the
application is capable of serving requests, and that all of the
configuration is correct. Traefik middlewares may also add additional
headers to incoming requests, and so whoami is a nice way to verify
that those are working too. Finally, the connection test will confirm
whether or not the TLS certificate is installed correctly.

*** Quickstart

Create a new config:

#+begin_run
d make whoami config
#+end_run

The first question the config asks for is =WHOAMI_TRAEFIK_HOST= which
should be the fully qualified domain name that the whoami app will use
for its URL:

#+begin_stdout
WHOAMI_TRAEFIK_HOST: Enter the whoami domain name (eg. whoami.example.com)
â€‹: whoami.d.example.com
#+end_stdout

Optional authentication can be configured:

#+begin_stdout
? Do you want to enable sentry authentication in front of this app (effectively making the entire site private)?  
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout

For now, choose =No=, to disable authentication. 

Install whoami:

#+begin_run
d make whoami install
#+end_run

**** Setup temporary DNS override

The =whoami= service is not public yet, it is currently only
accessible from the same local network (LAN). For testing purposes,
you need to set a temporary local DNS override in the Raspberry Pi's
=/etc/hosts= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo "127.0.1.1       whoami.d.example.com" | sudo tee -a /etc/hosts
#+end_run

#+begin_notice
Replace whoami.d.exmaple.com with the same domain name you set for WHOAMI_TRAEFIK_HOST.
#+end_notice


**** Open whoami in the web browser

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make whoami open
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
The =open= target uses the =xdg-open= tool to automatically open your
preferred web browser to the given application's URL. Since you are
connected to the Raspberry Pi's text console over SSH, you are limited
to text-mode browsers. [[https://w3m.sourceforge.net/][w3m]] will be used in this instance to display
the page. To quit =w3m=, press =q=, then =y=.
#+end_notice

#+begin_stdout
Name: default
Hostname: c3ce89b0fceb
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:50156
GET / HTTP/1.1
Host: whoami.d.example.com
User-Agent: w3m/0.5.3+git20230121
Accept: text/html, text/*;q=0.5, image/*, application/*
Accept-Encoding: gzip, compress, bzip, bzip2, deflate
Accept-Language: en;q=1.0
X-Forwarded-For: 127.0.0.1
X-Forwarded-Host: whoami.d.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: pi5
X-Real-Ip: 127.0.0.1


â‰ª â†‘ â†“ Viewing[SSL] <>
#+end_stdout

If you see output like printed above, you have confirmed that Whoami
and Traefik are functioning correctly. The status bar of =w3m= shows
=Viewing[SSL]= which confirms that TLS is successfully working.

You can further verify the TLS certificate is issued correctly:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
openssl s_client -connect whoami.example.com:443 </dev/null
#+end_run

#+begin_stdout
...
issuer=C = US, O = Let's Encrypt, CN = R10
...
#+end_stdout

 * If the issuer is =Let's Encrypt=, then the certificate is valid âœ….
 * If the issuer is =TRAEFIK DEFAULT CERT=, then there is some kind of
   problem ðŸ’¥, and you will need to inspect the logs.


**** View the logs

It may be necessary to inspect the applicaiton logs, which you can do
so as follows:

#+begin_run
d make whoami logs
#+end_run

To check the Traefik logs, do similar:

#+begin_run
d make traefik logs
#+end_run

* Setup cloud sentry server
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: setup-cloud-sentry
:EXPORT_HUGO_WEIGHT: 300
:END:
TODO
** Setup your cloud server sentry
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 301
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Launch DigitalOcean droplet
:PROPERTIES:
:EXPORT_FILE_NAME: launch-digitalocean-droplet
:EXPORT_HUGO_WEIGHT: 310
:END:
TODO
** Setup Docker context on the Pi
:PROPERTIES:
:EXPORT_FILE_NAME: setup-docker-context
:EXPORT_HUGO_WEIGHT: 320
:END:
TODO
** Install Traefik and Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: install-traefik-and-whoami
:EXPORT_HUGO_WEIGHT: 330
:END:
TODO
* Configure Wireguard tunnel
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: configure-wireguard-tunnel
:EXPORT_HUGO_WEIGHT: 400
:END:
TODO
** Configure Wireguard tunnel
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 401
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Configure sentry wireguard server
:PROPERTIES:
:EXPORT_FILE_NAME: configure-sentry-wireguard-server
:EXPORT_HUGO_WEIGHT: 410
:END:
TODO
** Configure pi wireguard client
:PROPERTIES:
:EXPORT_FILE_NAME: configure-pi-wireguard-client
:EXPORT_HUGO_WEIGHT: 420
:END:
TODO
** Configure routes for Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: configure-routes-for-whoami
:EXPORT_HUGO_WEIGHT: 430
:END:
TODO
* Install web services
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: install-web-services
:EXPORT_HUGO_WEIGHT: 500
:END:
** Install web services
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 501
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Immich
:PROPERTIES:
:EXPORT_FILE_NAME: immich
:EXPORT_HUGO_WEIGHT: 510
:END:
TODO
** Yourls
:PROPERTIES:
:EXPORT_FILE_NAME: yourls
:EXPORT_HUGO_WEIGHT: 520
:END:
TODO
