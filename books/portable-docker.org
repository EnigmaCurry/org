#+hugo_base_dir: ../hugo
#+hugo_section: /portable-docker
#+hugo_weight: auto
#+hugo_paired_shortcodes: %notice badge button %children %index run stdout edit math mermaid openapi toc env
#+STARTUP: align

* Portable Docker: Build and Deploy Anywhere with WireGuard Tunneling
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :linkTitle Portable Docker
:EXPORT_HUGO_WEIGHT: 300
:END:

[[/img/portable-docker/treasure.webp]]

This book serves as your guide to installing Docker on a small
portable Linux device (e.g., Raspberry Pi) and deploying some web
service containers on it.

You'll also create and configure a public cloud server (e.g.,
a DigitalOcean droplet) whose sole purpose is to host a VPN (WireGuard)
and public gateway (Traefik), enabling the Raspberry Pi to securely
connect from any location.

Through the encrypted tunnel established by this connection, the Pi
can publish services to the Internet even when operating behind a
restrictive firewall, such as public Wi-Fi, mobile hotspots, or
carrier-grade NAT. As long as you can get unblocked /outgoing/
Internet access, you can self-host a roaming public server from
anywhere!

#+attr_shortcode: :icon code-branch :style primary :href https://github.com/EnigmaCurry/d.rymcg.tech#readme
#+begin_button
d.rymcg.tech
#+end_button

#+attr_shortcode: :icon comment-dots :style red :href https://matrix.to/#/#d.rymcg.tech:enigmacurry.com
#+begin_button
Chat with us on Matrix
#+end_button

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

* Acknowledgements
:PROPERTIES:
:EXPORT_FILE_NAME: acknowledgements
:EXPORT_HUGO_WEIGHT: 99
:END:
#+attr_shortcode: :style other :title Acknowledgements

Thank you to those who helped test everything: Mike, Jessop, and
Duane.

Thank you to Kellie for help editing this book.

Thank you to DALL-E for drawing the illustrations. We forgive any
misspellings and hallucinations.

[[/img/portable-docker/high-five.webp]]


* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: introduction
:EXPORT_HUGO_WEIGHT: 100
:END:

#+begin_toc
table of contents
#+end_toc

** Raspberry Pi

[[/img/portable-docker/pi5-assembled.webp]]

Here is my Raspberry Pi 5, which is a small form factor Linux
computer, running [[https://www.raspberrypi.com/software/][Raspberry Pi OS]] and [[https://docs.docker.com/engine/][Docker]]. It has been outfitted
with an NVME SSD attached via the expandable PCI-E bus. It has 8GB of
RAM and 1TB of fast storage.

I use this as a tiny web server that I can take anywhere I go.

It normally sits in one place for a long time. But sometimes it needs
to be picked up and installed in a new place. I need it to be able to
get the network up, have it resume all of its previous functions, and
even use the same IP address as before. Traveling with this device
should be a plug and play experience, with minimal disruption to the
clients that expect this server to be online and available. No matter
what kind of Internet connection it has, it should be quick to get
this server back online.

#+attr_shortcode: :style tip :title You can use any Linux computer, not just Raspberry Pi.
#+begin_notice
To follow this book, you don't necessarily require a Raspberry Pi. You
can replace it with any Linux computer (AMD64 or ARM64). The
instructions for installing its dependencies assume it to be running a
variant of Debian Linux, but this is not a requirement either, if you
can read between the lines.
#+end_notice

** Sentry Droplet

To accomplish this feat, we need to set up another server (to be named
=sentry=) that has a static IP address and is accessible from the
public Internet. I use a [[https://m.do.co/c/d5da28d3d99d][DigitalOcean Droplet]] (affiliate link helps
support this book), which is a type of Virtual Private Server (VPS)
and exists in the public cloud. The sentry is always on and anyone in
the world can connect to it (via HTTP). However, the sentry does not
serve any applications by itself; it only creates the public [[https://doc.traefik.io/traefik/][Traefik]]
proxy (ingress), which forwards incoming connections through a backdoor
VPN connection to the Raspberry Pi. The Pi automatically initiates
this connection to the sentry whenever it boots and comes online.

[[/img/portable-docker/vpn-diagram.webp]]

** WireGuard VPN

The Raspberry Pi should use whatever kind of Internet connection you
plug the ethernet into via DHCP (or you may configure Wi-Fi);
therefore it won't have a static IP address initially. Once it's
online, it creates an outbound VPN connection to the sentry via
[[https://www.wireguard.com/][WireGuard]]. Once connected to the VPN, the Pi is assigned a static
private IP address that only the sentry can communicate with.

The sentry forwards incoming connections from the Internet to the
Raspberry Pi over the WireGuard VPN connection. Traefik is used on
both the sentry and Raspberry Pi to create the full public route to
each of your services. Traefik supports the following types of routes:

 * *HTTP Layer 7* Routes an incoming HTTP(s) request, which is a
   domain name (or TLS SNI), including optional HTTP path, over TCP
   port =443= to a backend HTTP server based on these criteria. This
   is the most common method used for publishing web apps.
 * *TCP Layer 4 (no TLS inspection)* Routes a unique TCP ADDRESS:PORT
   combination to a unique backend ADDRESS:PORT combination. This is
   the second most common method, used for publishing non-HTTP
   services (e.g., SSH).
 * *TCP Layer 4/7 (TLS-enabled)* - TODO - unimplemented, but routes a
   TLS encrypted TCP layer 4 connection based upon the domain name (by
   inspecting the unencrypted TLS SNI header) to a backend
   ADDRESS:PORT combination.
 * *UDP Layer 4* - TODO - unimplemented, but similar to non-TLS TCP.

Traefik can create a public route for virtually any service on your
Raspberry Pi, whether it's sitting at your desk or at an impromptu
getaway location.

** d.rymcg.tech


[[/img/portable-docker/vpn-string-along.webp]]


[[https://github.com/EnigmaCurry/d.rymcg.tech][d.rymcg.tech]] is a configuration manager for Docker, as well as a
collection of open source web services and config templates. It
contains an extensive configuration wizard for [[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master/traefik#readme][Traefik]] and an
idiomatic [[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master#command-line-interaction][command line tool]], which makes [[https://docs.docker.com/compose/][Docker Compose]] projects both
easy to document and use.

** The dual roles of the Raspberry Pi

Traditionally, you would install d.rymcg.tech /on a separate
workstation/ and never actually log in to your Docker
server, but rather exclusively control it remotely from your
workstation. This is one of the ways to follow the good DevOps
practice summed up by the metaphor:

#+begin_quote
"Treat your infrastructure like cattle, not like pets."
#+end_quote

However, the cattle ranching strategy has the drawback that if you
lose access to your workstation, it's diffcult to administer the
remaining server (you would have to recreate your =.env= files on a
new workstation, from backup, or from scratch).

To avoid this complexity and make it easier to maintain after long
periods of inactivity and forgetfulness, we will make an important
compromise and an exception to the normal DevOps rule:

#+attr_shortcode: :title The Raspberry Pi serves the role of workstation AND server :style info
#+begin_notice
*In this book*, the configuration tools (d.rymcg.tech) will be
installed /to the same server/ that runs Docker, rather than the usual
recomendation to do so on a separate workstation. Co-mingling the
roles of server and workstation on the Pi means you'll have everything
together in one little box and it will make everything easier to get
(re)acquainted with.

#+begin_quote
Treat your portable Pi as a /pet/ Docker server (not cattle). You
must name it and interact with it directly via SSH console.
#+end_quote

If you read any other d.rymcg.tech documentation and it references
"your workstation," you should use the =pi= user on the Raspberry Pi,
not your personal workstation.

If you had a whole fleet of Raspberry Pis to manage, this would be a
terrible idea, because you would be missing the centralized (cattle
ranching) workstation to control all of them, and you'd have to log in
to each one individually and configure them directly. However,
you will likely start this journey with only one Pi to manage, so
treating it as a pet is a good initial compromise to make. If you want
to build a proper workstation that can control several servers from
one location, read the [[/linux-workstation/][Linux Workstation]] book and the main
[[https://github.com/enigmacurry/d.rymcg.tech?tab=readme-ov-file#readme][d.rymcg.tech README]].

If you are going to travel frequently with this device, you should
consider [[https://gist.github.com/EnigmaCurry/2f9bed46073da8e38057fe78a61e7994][installing full disk encryption]] and requiring remote SSH
unlock on boot, but this is an advanced topic that is outside the
scope of this book.
#+end_notice

** Your personal workstation

Unless you want to carry a display and keyboard to plug into
the Raspberry Pi, you're still going to need to travel with another
computer (e.g., a laptop) and set that up with an SSH key so
you can remotely log in to the Pi.

You can use any sort of personal computer, as long as it's capable of
running a terminal and an SSH client. If it runs Linux, MacOS, or
Windows, you'll also be able to use this computer to run the
[[https://www.raspberrypi.com/software/][rpi-imager]] application for preparing the SD card. Most Linux distros
have this available in their package manager.

#+attr_shortcode: :style tip
#+begin_notice
If you don't yet have an SSH key on your personal computer, the [[/linux-workstation][Linux
Workstation]] book has a [[/linux-workstation/config/ssh/][chapter about SSH]], covering both traditional
SSH keys and agents, as well as the open hardware security token
Solokey.
#+end_notice

**** Editing files on the Pi

Eventually you might need to edit a =.env= file by hand, and so you
need to know how to edit files remotely over SSH. You have a few
different options:

 1. Learn how to use one of the many terminal mode text editors
    (e.g., Emacs, Vim, Nano, etc.) and edit the files through an SSH console
    directly on the Pi. *This is the most secure option, as the files
    never leave the Pi.*
 2. Edit the files directly on your personal workstation and set up
    your editor so that it saves files transparently over SSH. Example
    configurations include Emacs' [[https://www.gnu.org/software/tramp/][TRAMP]], VS Code's
    [[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh][Remote
    SSH]], or Vim's [[https://www.vim.org/scripts/script.php?script_id=1075][Netrw]]. For a universal solution that works with
    any editor, use [[https://wiki.archlinux.org/title/SSHFS][sshfs]].
 3. Edit the files directly on your personal workstation and use
    synchronization tools like [[https://blog.rymcg.tech/blog/linux/rclone_sync/][rclone]], rsync, dropbox etc, however
    this method is the least secure because it leaves several copies
    of the files outside of the Pi itself, and important secrets may
    be leaked as a result.

** Next steps

 * Set up DNS.
 * Set up Raspberry Pi.
 * Set up sentry Droplet.
 * Configure WireGuard VPN.
 * Set up public SSH.
 * Install core services.
 * Install apps.

* Set up DNS
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: set-up-dns
:EXPORT_HUGO_WEIGHT: 150
:END:
** Set up DNS
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 151
:END:

Before you can configure any hardware, you need to set up the domain
name service (DNS) of your domain.

[[/img/portable-docker/dns.webp]]

#+begin_index
index
#+end_index

** Register a domain name
:PROPERTIES:
:EXPORT_FILE_NAME: register-domain
:EXPORT_HUGO_WEIGHT: 160
:END:

To host a web service, one of the first things you will need to do is
to register your domain name (e.g., =example.com=). This will be the
root domain name used for all of your service links and it is part of
what your users will need to type into their web browsers (or click
on) to visit your pages.

[[/img/portable-docker/hello-traefik.webp]]

*** Domain name registration

The public domain name registration system is controlled as a scarce
resource that you must pay for the use of.

If domain names were given out for free, all of the good ones would be
taken by now, but due to the imposed registration costs, there are
still some good names left to be had. In return for your fee, you
receive exclusive control of the domain name for the period that you
paid for.

You can never truly own a domain name outright, because you need to
keep paying the registrar to keep the record active, so it is best to
consider a domain name as a rental service. You may pre-pay for
several years in advance or just pay for one year at a time. If you
stop paying and the record expires, the name will no longer resolve to
your services and you may permanently lose control of the name.

*** Register an Internet domain name

You can register a domain name from any registrar. For documentation
purposes, we will use [[https://www.gandi.net][Gandi.net]], but these instructions will be
similar regardless of the registrar you pick.

#+attr_shortcode: :style info :title Set up Gandi.net
#+begin_notice
 * Sign up for an account at [[https://www.gandi.net/][Gandi.net]]
 * Once signed in, from your dashboard, click =Register=.
 * Search for any domain name you like, e.g., =your-name.com=.
 * Add your domain to the shopping cart, go to checkout, and complete
   your purchase.
 * Once you have purchased the domain, it should show up in your
   =Dashboard=, under the =Domain= tab.
 * Leave this browser tab open, you will return to it in the next
   chapter.
#+end_notice

*** Transfer DNS to DigitalOcean

#+attr_shortcode: :style tip :title Choose any supported DNS provider
#+begin_notice
All examples in this book use DigitalOcean as the DNS provider. You
may choose any DNS service that provides a programmatic API supported
by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].

Sign up for a [[https://m.do.co/c/d827a13964d7][DigitalOcean account]] (using this referral link helps
support this site).
#+end_notice

#+attr_shortcode: :style info :title Set up Gandi.net
#+begin_notice

 * Login to your [[https://admin.gandi.net][Gandi.net]] dashboard.
 * Click the =Domain= tab.
 * Find your domain name in the list and click on it.
 * Click on the =Nameservers= tab.
 * Click on the edit button to create new =External nameservers=.
 * Delete all existing nameservers that may exist.
 * Add the following nameservers, specific to DigitalOcean:
   
   * =ns1.digitalocean.com=
   * =ns2.digitalocean.com=
   * =ns3.digitalocean.com=
#+end_notice

Wait a few minutes for the change to take effect, then you can verify
the setting from your workstation using the =whois= command:

#+begin_run
whois example.com
#+end_run

#+begin_stdout
Domain Name: example.com
Registrar WHOIS Server: whois.gandi.net
Name Server: ns1.digitalocean.com
Name Server: ns2.digitalocean.com
Name Server: ns3.digitalocean.com
#+end_stdout

The output shows a report for your domain registration including the
list of the new nameservers.

If you don't have =whois= installed, you can use [[https://www.registry.google/whois-lookup/][the web version provided by google]].

** Add the domain to DigitalOcean DNS
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token
:EXPORT_HUGO_WEIGHT: 161
:END:

The [[https://www.rfc-editor.org/rfc/rfc1035][Domain Name System]] is how you associate your (sub-)domains with an
actual IP address on the Internet.

[[/img/portable-docker/hello-docker.webp]]

#+attr_shortcode: :style tip :title Choose any supported DNS provider
#+begin_notice
All examples in this book use DigitalOcean as the DNS provider. You
may choose any DNS service that provides a programmatic API supported
by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].

Sign up for a [[https://m.do.co/c/d827a13964d7][DigitalOcean account]] (using this referral link helps
support this site), and follow along to set up your domain's DNS.
#+end_notice

*** Add your domain name

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =Networking= in the left hand menu.
 * Select the =Domains= tab.
 * Enter your domain name, and click =Add Domain=.

*Wait a few minutes* for the setting to take effect, then you can verify
the domain name is added:

#+begin_run
# install dig from bind-utils package.
dig -t ns example.com
#+end_run

(if you don't have =dig= installed, you can also use [[https://toolbox.googleapps.com/apps/dig/][the web version
provided by google]], enter the domain name, and select =NS=.)

#+begin_stdout
;; ANSWER SECTION:
example.com.             2400    IN      NS      ns1.digitalocean.com.
example.com.             2400    IN      NS      ns3.digitalocean.com.
example.com.             2400    IN      NS      ns2.digitalocean.com.
#+end_stdout

The number in the second column is the TTL (Time To Live) which is the
number of seconds that the record is cached in the queried DNS server.
If you jump the gun and check this too quickly before the changes
takes effect, you may need to wait for this TTL to reset.

** Generate DigitalOcean API token for ACME challenge
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token-for-acme-challenge
:EXPORT_HUGO_WEIGHT: 255
:END:

[[/img/portable-docker/api.webp]]

#+attr_shortcode: :style tip :title Choose any supported DNS provider
#+begin_notice
All examples in this book use DigitalOcean as the DNS provider. You
may choose any DNS service that provides a programmatic API supported
by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].

Sign up for a [[https://m.do.co/c/d827a13964d7][DigitalOcean account]] (using this referral link helps
support this site), and follow along to create the required API token.
#+end_notice

DNS is also a part of the TLS certificate request process with [[https://letsencrypt.org/getting-started/][Let's
Encrypt]] (via [[https://letsencrypt.org/docs/challenge-types/][ACME DNS-01 challenge]]). Traefik interacts with Let's
Encrypt on your behalf, automatically requesting TLS certificates to
be created for your services. To allow this, you will need to procure
a DigitalOcean Personal Access Token, which grants programatic control
of your DigitalOcean account's DNS settings:

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =API= in the left hand menu, near the bottom of the list.
 * On the =Tokens= tab, click =Generate New Token=.
 * Enter a descriptive name indicating the owner of the token (e.g., a
   subdomain), and its purpose (e.g., ACME): =pi.example.com ACME=.
 * Set the expiration period you want to use. Use =No expire= if you
   just want to set it and forget it, otherwise you will need to
   update the token periodically.
 * Select =Custom Scopes= so you can choose the fine-grained
   permissions.
 * The only permission that needs to be selected is =domain=.
 * Click =Generate Token=.
 * Copy the generated token to a temporary buffer/notepad. You will
   need to reference this token in the next section, when it asks for
   the =DO_AUTH_TOKEN= variable.

You will also need to generate an API token for the sentry droplet.

 * Create the second token named =sentry.example.com ACME= or similar.
 * Set a =Custom scope= = =domain=.
 * Copy this token to the same temporary buffer/notepad as before,
   you'll need it when setting up the sentry droplet.

#+attr_shortcode: :style tip
#+begin_notice
You could reuse the same API token on both Pi and sentry, but its reccomended 
to create a unique token for each host.
#+end_notice

*** Next steps

 * Set up Rasbperry Pi.
 * Set up sentry Droplet.
 * Configure WireGuard VPN.
 * Set up public SSH.
 * Install core services     
 * Install apps.

* Set up Raspberry Pi
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: set-up-raspberry-pi
:EXPORT_HUGO_WEIGHT: 200 
:END:
** Set up Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 201
:END:
[[/img/portable-docker/rpi-handover.webp]]
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Build your Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: build-your-pi
:EXPORT_HUGO_WEIGHT: 210
:END:

These are the parts you will need to source for this build (purchase
price ~$240 USD):

#+attr_shortcode: :title Raspberry Pi 5 motherboard
#+begin_notice
[[/img/portable-docker/pi5.webp]]
#+end_notice
The Raspberry Pi 5 is often sold in kits, but you can also buy the
motherboard separately. If buying a pre-made kit, make sure it
includes an NVME shield to plug in an NVME SSD. Otherwise, this can be
purchased separately:

#+attr_shortcode: :title Geeekpi / 52Pi case, heatsink, NVME shield, and power supply
#+begin_notice
[[/img/portable-docker/geeekpi5case.webp]]
#+end_notice
This kit comes with the NVME shield, which is an adapter (hat) to
install on top of the Raspberry Pi 5 motherboard. This allows you to
plug in a full size NVME SSD into the Raspberry Pi's PCI-E bus. The
metal case fits the extended height neccessary to fit the NVME shield
and SSD inside. The kit also includes the required heatsink for the
motherboard, a power supply, and the flat ribbon cable (not shown)
that connects the shield to the motherboard's PCI-E port.

#+attr_shortcode: :title Sandisk SD card (32GB)
#+begin_notice
[[/img/portable-docker/sandisk-32GB-sdcard.webp]]
#+end_notice

The SD card is used as the root filesystem for Raspberry Pi OS
(formerly named Raspbian). The capacity of the card doesn't need to be
very big, as you won't be storing very much data on this.

Booting from the SD card is a bit slower than NVME, but the advantage
of it is that you can simply swap SD cards, and temporarily use the pi
for a different purpose, all without disrupting access to your NVME
storage.

SD cards are more prone to failure than NVME, especially if you write
too much data to them, so this is minimized as much as possible.
=/tmp= will be mounted on tmpfs, and =/var/log= will run on log2ram,
which are both stored in RAM, so the only writes that should happen on
the SD card should be OS updates.

#+attr_shortcode: :title SD card adapter
#+begin_notice
[[/img/portable-docker/sd-card-adapter.webp]]
#+end_notice

The micro SD card comes with a full size SD card adapter, but you may
also need a USB adapter, in order to write the image.

#+attr_shortcode: :title Samsung 990EVO NVME SSD
#+begin_notice
[[/img/portable-docker/samsung-990EVO-NVME.webp]]
#+end_notice

The NVME SSD is much faster, and far more reliable, than the SD card.
This device will be used exclusively for the Docker storage system
(mounted at =/var/lib/docker=). This is where all of your container
images will be built/downloaded, and where the volumes holding your
app data will live.

#+attr_shortcode: :title NVME heatsink
#+begin_notice
[[/img/portable-docker/nvme-heatsink.webp]]
#+end_notice

You should purchase separately a heatsink to go on the top of your
NVME drive. There is a little bit of room left in the case to fit a
slim one (the one I installed is 3mm tall). This is not essential, but
it is recommended if you make use of heavy I/O, as it will increase
the life expectancy of the SSD.

*** Putting everything together

 * *Read the directions that come with the Geeekpi / 52Pi case*, the rest of
   this list is just a summary.
 * Install the heatsink to the Pi 5 motherboard.
 * Attach one end of the ribbon cable to the PCI-E port and lock it
   into place. *The blue side of the ribbon cable should be facing
   outward.*
 * Attach the other end of the ribbon cable to the NVME shield and
   lock it into place.
 * Install the NVME shield on top of the Pi motherboard, plugging into
   the GPIO ports, and using the taller risers to sandwich things
   together.
 * Install the motherboard into the bottom part of the case, using the
   smaller risers to support the motherboard from below.
 * Install the NVME SSD into the NVME shield.
 * Screw on the top part of the case.
 * Install the SD card into the slot on the bottom edge.

#+attr_shortcode: :title Pi 5 heatsink and risers installed
#+begin_notice
[[/img/portable-docker/pi-heatsink.webp]]
#+end_notice

#+attr_shortcode: :title Ribbon cable and GPIO pins connect NVME shield to Pi motherboard
#+begin_notice
[[/img/portable-docker/ribbon-cable.webp]]
#+end_notice

#+attr_shortcode: :title NVME SSD installed in the NVME shield and motherboard secured in the bottom part of case
#+begin_notice
[[/img/portable-docker/pi5-nvme.webp]]
#+end_notice

#+attr_shortcode: :title top part of the case screwed on top and SD card installed
#+begin_notice
[[/img/portable-docker/pi5-sdcard.webp]]
#+end_notice

#+attr_shortcode: :title The fully assembled Raspberry Pi 5 (NVME heatsink not shown)
#+begin_notice
[[/img/portable-docker/pi5-assembled.webp]]
#+end_notice

** Install Raspberry Pi OS
:PROPERTIES:
:EXPORT_FILE_NAME: install-raspbian
:EXPORT_HUGO_WEIGHT: 220
:END:

[[/img/portable-docker/penguin.webp]]

The best way to install Raspberry Pi OS onto an SD card, is to use
[[https://www.raspberrypi.com/documentation/computers/getting-started.html#installing-the-operating-system][rpi-imager]] from another computer. This allows you to set up the user
account, network settings, and SSH credentials all from the imager
software.


*** rpi-imager

 * On your personal workstation,
   [[https://www.raspberrypi.com/software/][Download the Raspberry PI
   Imager]] or install =rpi-imager= from your package manager.
 * Run =rpi-imager=.
 * Click on the menu labled =Rasperry Pi Device=.
   * Choose your model of Raspberry Pi.
   
 * Click on the menu labeled =Operating System=
   * Choose =Raspberry PI OS (other)=
   * Choose =Raspberry PI OS Lite (64-bit)=.
   
 * Click on the menu labeled =Storage=.
   * Choose the Storage device to install to.
   * You may need to change the ownership of the device (e.g., I had to
     do =sudo chown ryan /dev/sdb= first).
     
 * Click =Next=.
 
 * Click =Edit Settings=.
 
   * On the =General= tab:
   
     * Enter the hostname (e.g., =pi=).
     * Enter a username and password (e.g., =pi=).
     * Optionally set up the Wi-Fi (I just use ethernet instead).
     * Set locale settings. (e.g., UTC).
     
   * On the =Services= tab:
   
     * Click =Enable SSH=
     * Choose =Allow public-key authentication only=
     * If you don't have an SSH key yet, read the [[/linux-workstation/config/ssh/][SSH chapter of the Linux Workstation book]].
     * Paste the list of your SSH public keys into the box. (Find them
       on your workstation by running =ssh-add -L= or look in
       =~/.ssh/id_ed25519.pub=)
     * The SSH key is important to protect, as this is the only way to
       remotely SSH into the Raspberry Pi
       
   * On the =Options= tab:
   
     * Unselect =Enable telemetry= unless you're into that sort of
       thing.
       
 * Click =Yes= to the question =Would you like to apply OS custom settings=.
 
 * Confirm you would like to write to the SD card and wait for it to complete.
 
 * Once complete, unplug the SD card, put it into the raspberry pi,
   plug in the ethernet, and power it on.

*** Find the local IP address of the Pi on your LAN

Once the Pi is powered on, and is connected to your LAN, you need to
figure out what its IP address is. There are a number of ways to do
that:

 * If your network has configured multicast DNS (mDNS, Avahi,
   Bonjour), you can find the IP address by the hostname (e.g., =pi=
   set in rpi-imager), appended with the domain =.local=:

#+begin_run
ping -c3 pi.local
#+end_run

 * From any Linux computer attached to the same LAN, run =arp -a= to
   find and list local connections. Try doing this before and after
   you turn on the Pi, and then spot the difference.

#+begin_run
arp -a
#+end_run

 * If you have a central LAN router + DHCP server, check the console
   of the router (or DHCP log) for the newly added device.
   
 * Plug a monitor into the (micro) HDMI port of the Raspberry Pi, and
   the IP address will be printed to the console when it boots.
   

*** Create SSH config on your personal workstation

To connect your personal workstation to your Raspberry Pi,
you will need to create an SSH config on your workstation, containing
the temporary local IP address of the Raspberry Pi. This config is
somewhat temporary, and once DNS is set up later on, it can be
replaced with a permanent hostname config.

#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host pi
    User pi
    Hostname X.X.X.X
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

Replace =X.X.X.X= with the local IP address assigned to the Raspberry
Pi.

Test that the SSH connection works:

#+begin_run
ssh pi
#+end_run

The first time you connect, it will ask you to confirm the remote host
ssh key, you should simply type =yes= to trust whatever it says, and
it will trust it automatically from now on.

If the connection is successful, you should now be logged into the
remote shell console of the Raspberry Pi.

*** Set up Log2Ram

You can increase the expected lifespan of your SD card by installing
[[https://github.com/azlux/log2ram#log2ram][log2ram]]

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo "deb [signed-by=/usr/share/keyrings/azlux-archive-keyring.gpg] http://packages.azlux.fr/debian/ bookworm main" | sudo tee /etc/apt/sources.list.d/azlux.list
sudo wget -O /usr/share/keyrings/azlux-archive-keyring.gpg  https://azlux.fr/repo.gpg
sudo apt update
sudo apt install log2ram
#+end_run

After installing log2ram, reboot the pi:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo reboot
#+end_run

After reboot, you will find =/var/log/= is mounted as type =log2ram=:

#+begin_stdout
ryan@pi5:~ $ df -h
Filesystem      Size  Used Avail Use% Mounted on
...
log2ram         128M   14M  115M  11% /var/log
#+end_stdout

*** Format and mount SSD storage

**** Identify the device name of the NVME SSD:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo fdisk -l | grep -A5 nvme
#+end_run

#+begin_stdout
Disk /dev/nvme0n1: 931.51 GiB, 1000204886016 bytes, 1953525168 sectors
Disk model: Samsung SSD 990 EVO 1TB                 
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
#+end_stdout

This shows the device is named =/dev/nvme0n1=.

**** Partition the device

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo parted /dev/nvme0n1 --script mklabel gpt
sudo parted /dev/nvme0n1 --script mkpart primary ext4 0% 100%
#+end_run

**** Create filesystem

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo mkfs.ext4 /dev/nvme0n1p1
#+end_run

**** Mount the filesystem

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo mkdir -p /var/lib/docker

echo "/dev/nvme0n1p1  /var/lib/docker  ext4  defaults,nofail  0  3" | sudo tee -a /etc/fstab

sudo systemctl daemon-reload
sudo mount /var/lib/docker
#+end_run

**** Verify the mounted storage

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
df -h /var/lib/docker
#+end_run

#+begin_stdout
Filesystem      Size  Used Avail Use% Mounted on
/dev/nvme0n1p1  916G   28K  870G   1% /var/lib/docker
#+end_stdout

This shows the correct partition =/dev/nvme0n1p1= mounted at the
correct path =/var/lib/docker= and showing the correct size of the
NVME SSD (=916G=; it's always a bit smaller than advertised.)

** Set up networking
:PROPERTIES:
:EXPORT_FILE_NAME: set-up-networking
:EXPORT_HUGO_WEIGHT: 230
:END:

[[/img/portable-docker/networking.webp]]

*** Wi-Fi

You may have already configured the Wi-Fi in the rpi-imager options,
but if not, you can do so after its been installed.

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo raspi-config
#+end_run

 * Enter =System Options=.
 * Enter =S1 Wireless LAN=.
 * Choose your current country.
 * Enter the SSID (Wi-Fi network name) you wish to connect to.
 * Enter the network passphrase

*** Configure DNS

By default, DNS is handled via DHCP, which will probably work in the
majority of cases. However, you may wish to hardcode specific DNS servers instead:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo rm -f /etc/resolv.conf
echo -e "nameserver 1.1.1.1" | sudo tee /etc/resolv.conf
sudo chattr +i /etc/resolv.conf
#+end_run

=chattr +i= prevents DHCP from overwriting this file in the future.

*** Links

 * [[https://raspberrypi-guide.github.io/networking][The Raspberry Pi Guide - For scientists and anyone else]] - this
   shares how to configure many different network scenarios, including
   a direct ethernet cable between your workstation and the pi, useful
   when you can't find an ethernet LAN with DHCP.
 * [[https://www.raspberrypi.com/documentation/computers/configuration.html#wireless-networking-command-line][Official Raspberry Pi Networking guide]]

** Set up SSH
:PROPERTIES:
:EXPORT_FILE_NAME: set-up-ssh
:EXPORT_HUGO_WEIGHT: 231
:END:

The Docker context is controlled exclusively through SSH, as the
=root= user. This requires setting up some keys to allow the =pi= user
to access the =root= user's account.

Although you will not need to interact with the =root= user's shell
directly, the =pi= user will be granted full access to =root= via SSH.

#+attr_shortcode: :style warning :title Docker == root == pi
#+begin_notice
SSH is used here almost like =sudo=. The =pi= user should be treated
with the same respect as the =root= user, as it will be granted full
=root= access through SSH (to localhost).
#+end_notice

*** Create a new SSH key

You need to create a new SSH key for the =pi= user.

#+attr_shortcode: :style warning :title Unencrypted SSH keys are used for convenience
#+begin_notice
To connect to the Docker context requires that your SSH key be already
/decrypted/.

There's only two ways to do that:

 * Create an /unencrypted/ SSH key, so that no passphrase is ever
    required.
 -or-
 * Set up an ssh-agent to decrypt and load the unencrypted key into
    resident memory, so that your key can be used without requiring a
    passphrase.

For the sake of convenience, this guide will use the first method, and
create a new /unencrypted/ SSH key, living in the pi user's home
directory: =/home/pi/.ssh/id_ed25519=. The security of this key
depends upon the physical and network security of the device
(including SD card). Any user gaining entry to the =pi= user's account
will have access to the key, and no passphrase is required to use the
key.

If you wish to enhance the security of your SSH key, please read the
[[https://wiki.archlinux.org/title/SSH_keys][Arch Wiki article on SSH keys]], which covers generating secure SSH
keys, setting a passphrase, and setting up an ssh-agent with [[https://wiki.archlinux.org/title/SSH_keys#Keychain][Keychain]].

You may also protect the integrity of the SD card (at rest) with [[https://gist.github.com/EnigmaCurry/2f9bed46073da8e38057fe78a61e7994][full
disk encryption and remote unlock via SSH]].
#+end_notice

Create a new SSH key (without a passphrase):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519
#+end_run

*** Authorize the key of the pi user to connect as root

All interaction with Docker is done over SSH as the =root= user, so
for the =pi= user to control Docker, they need to be able to SSH to
=localhost= as the =root= user.

Add the =pi= user's key to the root user's
=/root/.ssh/authorized_keys= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat ~/.ssh/id_ed25519.pub | sudo tee -a /root/.ssh/authorized_keys
#+end_run

Create a config named =pi= in your =~/.ssh/config=:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host pi
    User root
    Hostname localhost
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

Test the connection is working:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh pi whoami
#+end_run

Accept the key fingerprint it offers:

#+begin_stdout
The authenticity of host 'localhost (::1)' can't be established.
ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
#+end_stdout

If it worked, you should see the output of =whoami= which should print
the username =root= (which is the user configured by SSH).


** Install Docker
:PROPERTIES:
:EXPORT_FILE_NAME: install-docker
:EXPORT_HUGO_WEIGHT: 240
:END:
*** Install Docker

 * On the pi, install docker:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run   
curl -sSL https://get.docker.com | sh
#+end_run

 * Test docker is working: 

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo docker run hello-world
#+end_run

  * If working, you should see a =Hello from Docker!= message and some other help info.

#+attr_shortcode: :style tip
#+begin_notice
Normally, you shouldn't use =sudo docker=. In the next section you
will create a Docker context for the =pi= user to use directly.
#+end_notice
  
*** Set up Docker context (SSH)

[[https://github.com/enigmacurry/d.rymcg.tech][d.rymcg.tech]] requires the use of a [[https://docs.docker.com/engine/manage-resources/contexts/][Docker context]] via SSH, rather than
the default socket context.

Create a new docker context, named =pi=, using the SSH config you had
just created (also called =pi=):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context create pi --docker "host=ssh://pi"
#+end_run

Switch to use the new SSH context as the default:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context use pi
#+end_run

Now, when you run any docker command, it will use the SSH context:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker info | grep -iE "(Name|Context)"
#+end_run

This should print the proper context: =pi=.

If it worked, the =pi= user is now fully equipped to run any docker comamnd as =root=.

** Install d.rymcg.tech
:PROPERTIES:
:EXPORT_FILE_NAME: install-d-rymcg-tech
:EXPORT_HUGO_WEIGHT: 250
:END:

*** Install dependencies

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo apt-get update && \
sudo apt-get install -y bash build-essential gettext \
     git openssl apache2-utils xdg-utils jq sshfs \
     wireguard curl inotify-tools w3m
#+end_run

*** Clone the git repository

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
git clone https://github.com/EnigmaCurry/d.rymcg.tech.git \
    ${HOME}/git/vendor/enigmacurry/d.rymcg.tech

cd ${HOME}/git/vendor/enigmacurry/d.rymcg.tech
#+end_run

*** Configure Bash shell integration

Configure the =pi= user's =~/.bashrc= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;'EOF' &gt&gt ~/.bashrc
export EDITOR=nano

## d.rymcg.tech cli tool:
export PATH=${PATH}:${HOME}/git/vendor/enigmacurry/d.rymcg.tech/_scripts/user
eval "$(d.rymcg.tech completion bash)"
__d.rymcg.tech_cli_alias d

## Add d.rymcg.tech alias for each Docker context:
__d.rymcg.tech_context_alias pi
__d.rymcg.tech_context_alias sentry

EOF
#+end_run

#+attr_shortcode: :style tip :title Tip
#+begin_notice
Set =EDITOR= to your preferred console text editor.
#+end_notice

Once finished, logout of the Pi and log back in.

Now you should have a new alias named =d= that controls the
=d.rymcg.tech= toolset. Check out the main help screen:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d
#+end_run

#+begin_stdout
## Main d.rymcg.tech sub-commands - Optional arguments are printed in brackets [OPTIONAL_ARG]
cd [SUBDIR]                   Enter a sub-shell and go to the ROOT_DIR directory (or given subdirectory)
make [PROJECT] [ARGS ...]     Run a `make` command for the given d.rymcg.tech project name
context                       View or set the current Docker context
new-context                   Create a new Docker context
tmp-context                   Use a temporary Docker context in a sub-shell
config                        Configure the current Docker context
ssh [COMMAND ...]             Run command or shell on active docker context SSH host
completion                    Setup TAB completion in your shell
install                       Install an app interactively
install-docker                Install Docker Engine on the host
status                        Show status of all installed services
audit                         Print security audit of running containers

## Documentation sub-commands:
help                          Show this help screen
list                          List available d.rymcg.tech projects
                              (not including external projects, unless you symlink them into ROOT_DIR)
readme                        Open the main d.rymcg.tech README.md in your browser
readme [PROJECT]              Open the README.md for the given project name
readme digitalocean           Open root documentation file: DIGITALOCEAN.md
readme security               Open root documentation file: SECURITY.md
readme aws                    Open root documentation file: AWS.md
readme license                Open root documentation file: LICENSE.txt
readme raspberry_pi           Open root documentation file: RASPBERRY_PI.md
readme makefile_ops           Open root documentation file: MAKEFILE_OPS.md
#+end_stdout

There are two additional aliases created for each of the Docker contexts:

 * =pi=
 * =sentry=

These aliases can be used to directly interact with that particular
context without requiring the use of setting the context first (e.g.,
=d context use= is unnecessary). These aliases will be used throughout
this book.

You can see how they each of the aliases are constructed:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
alias d
alias pi
alias sentry
#+end_run

#+begin_stdout
alias d='D_RYMCG_TECH_CLI_ALIAS=d d.rymcg.tech '
alias pi='D_RYMCG_TECH_CONTEXT_ALIAS=pi d.rymcg.tech tmp-context pi d.rymcg.tech'
alias sentry='D_RYMCG_TECH_CONTEXT_ALIAS=sentry d.rymcg.tech tmp-context sentry d.rymcg.tech'
#+end_stdout

Full tab completion is supported for all of the aliases.

*** Run the main config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi config
#+end_run

*** Follow the interactive prompts to finish configuration
**** Install script-wizard
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_stdout
This utility can automatically install a required helper tool called script-wizard.
See https://github.com/enigmacurry/script-wizard

Do you wish to automatically install script-wizard into `_scripts/script-wizard`? (Y/n): y
#+end_stdout

[[https://github.com/EnigmaCurry/script-wizard][script-wizard]] is required dependency that can be downloaded and
installed automatically. =script-wizard= makes interactive input and
selection wizards in Bash a lot nicer.

**** Acknowledge the detected Docker context
#+begin_stdout
? This will make a configuration for the current docker context (pi). Proceed? (Y/n)  y
#+end_stdout
**** Choose the root domain name for this server

#+begin_stdout
ROOT_DOMAIN: Enter the root domain for this context (e.g., d.example.com)
: pi.example.com
#+end_stdout

Instead of =pi.example.com= you should type the actual domain name (or
subdomain name) that you want to use as the root domain for all of
your services on this server.

For example, if you entered =example.com=, you will later install apps
(e.g., =whoami=) with subdomains like =whoami.example.com=. Choosing a
deeper subdomain has the benefit of being able to share a single root
domain name amongst several Docker instances, therefore with the
example of =pi.example.com= the service would be deployed like
=whoami.pi.example.com=, and a second Docker instance could use
=pi2.example.com=, with services like =whoami.pi2.example.com=.

**** Choose to save generated passwords.json files by default
#+begin_stdout
Every time you configure HTTP Basic Authentication, you are asked if you wish to save the cleartext passwords
into passwords.json (in each project directory). If you were to press Enter without answering the question,
the default answer is No (displayed as y/N). You may change the default response to Yes (displayed as Y/n).
? Do you want to save cleartext passwords in passwords.json by default? (y/N)  y
#+end_stdout

This question is in regards to the integrated HTTP Basic Auth setting,
which allows you to store the plain text credentials in the file named
=passwords.json= in the various project directories. This is a
convenience feature, but you may not want it. It's not really a
security concern, because the same password is also availalbe in the
.env file for the project anyway, so go ahead and enable it.

** Install Traefik
:PROPERTIES:
:EXPORT_FILE_NAME: install-traefik
:EXPORT_HUGO_WEIGHT: 260
:END:

[[/img/portable-docker/gopher.webp]]

[[https://doc.traefik.io/traefik/][Traefik]] is an ingress application proxy and router for all of your web
services (HTTP / TCP / UDP). Traefik facilitates automatic TLS
certificate management via [[https://letsencrypt.org/getting-started/][Let's Encrypt]], and handles transport
security for all of your applications. Traefik is configured to
support several authentication and sentry authorization mechanisms,
including: HTTP Basic Auth, OAuth2, mutual TLS, and IP address
filtering.

*** Basic Traefik config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make traefik config
#+end_run

This presents the interactive configuration menu for Traefik:

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

You can use the up and down arrow keys to choose the selection, and
you may type any substring to narrow the list. Select the =Config= entry and press
the =Enter= key.

**** Traefik Config

#+attr_shortcode: :style secondary :title Don't wander off
#+begin_notice
The Traefik configuration is extensive. This section will only show
you how to configure Traefik for a basic install. Many of the menu
options will be skipped for the time being. Follow these instructions
exactly, and don't go wandering through the other menus just yet.
#+end_notice

#+begin_stdout
During first time setup, you must complete the following tasks:

 * Create Traefik user.
 * Configure TLS certificates and ACME (optional).
 * Install traefik.

Traefik must be re-installed to apply any changes.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


? Traefik Configuration:  
> Traefik user
  Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
v Logging level
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

***** Traefik user

#+begin_stdout
? Traefik Configuration:  
> Traefik user
  Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level
#+end_stdout

Select the =Traefik user= option to create the =traefik= user on the
host.

***** Entrypoints (including dashboard)

#+begin_stdout
? Traefik Configuration:  
  Traefik user
> Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level
#+end_stdout

The following entrypoints are defined by default:

#+begin_stdout
Entrypoint  Listen_address  Listen_port  Protocol  Upstream_proxy
----------  --------------  -----------  --------  --------------
web         0.0.0.0         80           tcp       
websecure   0.0.0.0         443          tcp       
#+end_stdout

You will need to reconfigure the =websecure= entrypoint, to enable the
=Proxy Protocol=:

#+begin_stdout
? Traefik entrypoint config  
  Show enabled entrypoints
> Configure stock entrypoints
  Configure custom entrypoints

? Select entrypoint to configure:  
  dashboard : Traefik dashboard (only accessible from 127.0.0.1:8080 and requires HTTP basic auth)
  web : HTTP (unencrypted; used to redirect requests to use HTTPS)
> websecure : HTTPS (TLS encrypted HTTP)
  web_plain : HTTP (unencrypted; specifically NOT redirected to websecure; must use different port than web)
  mqtt : MQTT (mosquitto) pub-sub service
  ssh : SSH (forgejo) git (ssh) entrypoint
v xmpp_c2s : XMPP (ejabberd) client-to-server entrypoint

> Do you want to enable the websecure entrypoint? Yes
Set TRAEFIK_WEBSECURE_ENTRYPOINT_ENABLED=true
TRAEFIK_WEBSECURE_ENTRYPOINT_HOST: Enter the host ip address to listen on (0.0.0.0 to listen on all interfaces) (e.g., 0.0.0.0)
: 0.0.0.0
TRAEFIK_WEBSECURE_ENTRYPOINT_PORT: Enter the host port to listen on (e.g., 443)
: 443

? Is this entrypoint downstream from another trusted proxy?  
  No, clients dial directly to this server. (Turn off Proxy Protocol)
> Yes, clients are proxied through a trusted server. (Turn on Proxy Protocol)

TRAEFIK_WEBSECURE_ENTRYPOINT_PROXY_PROTOCOL_TRUSTED_IPS: Enter the comma separated list of trusted upstream proxy servers (CIDR)
: 10.13.16.1/32
#+end_stdout

=10.13.16.1/32= is the correct (default) IP address of the sentry
WireGuard peer.

Press =ESC= two times to get back to the traefik config menu.

***** Configure ACME

#+begin_stdout
? Traefik Configuration:
  Traefik user
  Entrypoints (including dashboard)
> TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level

? Traefik TLS config:
  Configure certificate authorities (CA)
> Configure ACME (Let's Encrypt or Step-CA)
  Configure TLS certificates (make certs)

? Which ACME provider do you want to use?  
> Let's Encrypt (ACME)
  Step-CA (ACME)
  Disable ACME
  Cancel / Go back

? Which LE environment do you want to use?  
> Production (recommended!)
  Staging (untrusted / testing)

Which type of ACME challenge should be used?  
  TLS-ALPN-01 (default for public servers, easy, but no wildcard certs)
> DNS-01 (requires API key, but good behind firewalls, and allows wildcard certs)

TRAEFIK_ACME_CA_EMAIL: Enter your email address (not required; blank to skip)
: 

TRAEFIK_ACME_DNS_PROVIDER: Enter the LEGO code for your DNS Provider (eg. digitalocean)
: digitalocean

TRAEFIK_ACME_DNS_VARNAME_1: Enter the 1st DNS provider variable name (eg. DO_AUTH_TOKEN)
: DO_AUTH_TOKEN

TRAEFIK_ACME_DNS_VARNAME_2: Enter the 2nd DNS provider variable name (or leave blank)
:

Now to enter the values for the custom DNS API variables:
DO_AUTH_TOKEN: Enter the value for DO_AUTH_TOKEN (e.g., your-actual-digitalocean-token-here)
: dop_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#+end_stdout

***** Request TLS certificates

#+begin_stdout
? Traefik TLS config:  
  Configure certificate authorities (CA)
  Configure ACME (Let's Encrypt or Step-CA)
> Configure TLS certificates (make certs)

? Configure Traefik TLS certificates  
  Manage all certificates.
> Create a new certificate.
  Done / Go back
#+end_stdout

Next enter the domain names you want listed on this certificate:

 * =pi.example.com= (this is your main domain name CN record for the server.)
 * =*.pi.example.com= (this is your various app sub-domains wildcard
   SANS record, matching e.g., =whoami.pi.example.com=)
 * Any other domains you want listed on the same certificate.
   

#+begin_stdout

Enter the main domain (CN) for this certificate (e.g., `d.rymcg.tech` or `*.d.rymcg.tech`)
: pi.example.com

Now enter additional domains (SANS), one per line:
Enter a secondary domain (enter blank to skip)
: *.pi.example.com

Enter a secondary domain (enter blank to skip)
: 
#+end_stdout

It will continue asking you to enter additional SANS domains until you
enter a blank response to signify you are done.

***** Certificate summary

#+begin_stdout
Main domain:
 pi.example.com
Secondary (SANS) domains:
 *.pi.example.com
#+end_stdout

Finally a summary of the certificate request is printed.

 * Press the =ESC= key three times to go back to the main menu.

***** Error page template

You can customize the [[https://github.com/tarampampam/error-pages#-templates][Traefik error page template]] by selecing a custom
theme:

[[/img/portable-docker/404.webp]]

#+begin_stdout
? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / WireGuard)
> Error page template
  Logging level
  Access logs

? Select an error page theme (https://github.com/tarampampam/error-pages#-templates)  
^ hacker-terminal
  cats
  lost-in-space
  app-down
  connection
> matrix
  orient
#+end_stdout

Since this theme is only used for the 404s and other errors coming
from Traefik directly (and not for any errors coming from the apps
themselves), the choice here is not purely aesthetic: as long as you
choose /unique/ error page template themes for each Traefik server
instance (e.g., =pi=, =sentry=), you will gain extra debugging
knowledge of knowing /which/ Traefik instance is returning a
particular error.


*** Install Traefik

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

On the main menu, select =Install (make install)=.

Wait for the Traefik service to be installed, and then you will be
returned to the main menu.

Press the =Esc= key to quit the Traefik configuration.

*** Verify Traefik status

You can check to see that Traefik has started:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make traefik status
#+end_run

You should see two services running: =traefik= and
=traefik-error-pages=, both in state =running=:

#+begin_stdout
NAME                   ENV              IMAGE                           STATE
traefik-error-pages-1  .env_pi_default  tarampampam/error-pages:2.25.0  running
traefik-traefik-1      .env_pi_default  traefik-traefik                 running
#+end_stdout

** Install Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: install-whoami
:EXPORT_HUGO_WEIGHT: 261
:END:
#+attr_shortcode:
#+begin_toc
table of contents
#+end_toc

[[/img/portable-docker/whoami.webp]]

*** What is Whoami?

[[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master/whoami#readme][Whoami]] is a web application that simply outputs the request headers
that it receives (reflecting them back to the requesting client):

#+attr_shortcode: :title Run this later after you install it: :style none
#+begin_run
curl https://whoami.pi.example.com
#+end_run

#+begin_stdout
Name: default
Hostname: 38704012c4b3
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:34610
GET / HTTP/1.1
Host: whoami.example.com
User-Agent: curl/7.88.1
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: 198.51.100.1
X-Forwarded-Host: whoami.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: docker
X-Real-Ip: 198.51.100.1
#+end_stdout

This output is useful for end-to-end testing, to verify that the
application is capable of serving requests, and that all of the
configuration is correct. Traefik middlewares may also add additional
headers to incoming requests, and so whoami is a nice way to verify
that those are working too. Finally, the connection test will confirm
whether or not the TLS certificate is installed correctly.

*** Install

Create a new config:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make whoami config
#+end_run

The first question the config asks for is =WHOAMI_TRAEFIK_HOST= which
should be the fully qualified domain name that the whoami app will use
for its URL:

#+begin_stdout
WHOAMI_TRAEFIK_HOST: Enter the whoami domain name (e.g., whoami.example.com)
​: whoami.pi.example.com
#+end_stdout

Optional authentication can be configured:

#+begin_stdout
? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?  
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout

For now, choose =No=, to disable authentication. 

Install whoami:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make whoami install
#+end_run

**** Set up temporary DNS override

The =whoami= service is not public yet, it is currently only
accessible from the same local network (LAN). For testing purposes,
you need to set a temporary local DNS override in the Raspberry Pi's
=/etc/hosts= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo "127.0.1.1       whoami.pi.example.com" | sudo tee -a /etc/hosts
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
Replace =whoami.pi.example.com= with the same domain name you set for =WHOAMI_TRAEFIK_HOST=.
#+end_notice


**** Testing whoami

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make whoami open
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
The =open= target uses the =xdg-open= tool to automatically open your
preferred web browser to the given application's URL. Since you are
connected to the Raspberry Pi's text console over SSH, you are limited
to text-mode browsers. [[https://w3m.sourceforge.net/][w3m]] will be used in this instance to display
the page.
#+end_notice

#+begin_stdout
Name: default
Hostname: c3ce89b0fceb
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:50156
GET / HTTP/1.1
Host: whoami.pi.example.com
User-Agent: w3m/0.5.3+git20230121
Accept: text/html, text/*;q=0.5, image/*, application/*
Accept-Encoding: gzip, compress, bzip, bzip2, deflate
Accept-Language: en;q=1.0
X-Forwarded-For: 127.0.0.1
X-Forwarded-Host: whoami.pi.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: pi5
X-Real-Ip: 127.0.0.1


≪ ↑ ↓ Viewing[SSL] <>
#+end_stdout

If you see output like printed above, you have confirmed that Whoami
and Traefik are functioning correctly. The status bar of =w3m= shows
=Viewing[SSL]= which confirms that TLS is successfully working.

To quit =w3m=, press =q=, then =y=.

Alternatively, test it with curl:
#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
curl https://whoami.pi.example.com
#+end_run

If the TLS certificate has not been issued yet, you will get this
error from curl (and a similar error in =w3m=):

#+begin_stdout
curl: (60) SSL certificate problem: self-signed certificate
More details here: https://curl.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
#+end_stdout

Simply wait a bit longer for the TLS cert to issue, or check the logs
for errors (=d make traefik logs service=traefik=). You can also tell
curl to ignore the error (=-k=):

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
## This is insecure, but fine for testing:
curl -k https://whoami.pi.example.com
#+end_run

You can further verify the TLS certificate is issued correctly:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi script tls_debug whoami.pi.example.com
#+end_run

#+begin_stdout
...
issuer=C = US, O = Let's Encrypt, CN = R10
...
#+end_stdout

 * If the issuer is =Let's Encrypt=, then the certificate is valid ✅.
 * If the issuer is =TRAEFIK DEFAULT CERT=, then there is some kind of
   problem 💥, and you will need to inspect the traefik logs (see next
   section).

**** View the logs

It may be necessary to inspect the applicaiton logs, which you can do
so as follows:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make whoami logs
#+end_run

To check the Traefik logs, do similar:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make traefik logs service=traefik
#+end_run

*** Next steps

 * Set up the sentry Droplet.
 * Configure WireGuard VPN.
 * Set up public SSH.
 * Install core services.
 * Install apps.

* Set up sentry Droplet
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: set-up-cloud-sentry
:EXPORT_HUGO_WEIGHT: 300
:END:
** Set up sentry Droplet
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 301
:END:
#+attr_shortcode: :depth 999
[[/img/portable-docker/flight.webp]]

#+begin_index
index
#+end_index
** Launch DigitalOcean droplet
:PROPERTIES:
:EXPORT_FILE_NAME: launch-digitalocean-droplet
:EXPORT_HUGO_WEIGHT: 310
:END:

**** Set up your SSH key on DigitalOcean

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 - Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 - Click =Settings= in the menu.
 - Click on the =Security= tab.
 - Click on the =Add SSH Key= button.
 - Paste the public SSH key of the =pi= user into the box. (copy the
   contents of =~/.ssh/id_ed25519.pub= from the Raspberry Pi.)
 - Enter a key name e.g., =pi@pi.example.com=.
 - Finish adding the key, click =Add SSH Key=.
#+end_notice

**** Create a DigitalOcean firewall template

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Firewalls= tab.
 * Click =Create Firewall=.
 * Enter the name, e.g., =sentry.example.com=.
 * Enter the following rules:
   * SSH:
     * Type: =SSH=
     * Protocol: =TCP=
     * Port Range: =22=
     * Sources: All IPv4, All IPv6, or a specific static IP address if
       you want to be more secure.
     * Description: This is so you can access the SSH console of the
       public sentry.
   * HTTP:
     * Type: =HTTP=
     * Protocol: =TCP=
     * Port Range: =80=
     * Sources: All IPv4, All IPv6.
     * Description: This is used solely to forward incoming HTTP
       connections to HTTPS.
   * HTTPS:
     * Type: =HTTPS=
     * Protocol: =TCP=
     * Port Range: =443=
     * Sources: All IPv4, All IPv6.
     * Description: This allows incoming HTTPs connections.
   * WireGuard VPN:
     * Type: =Custom=
     * Protocol: =UDP=
     * Port Range: =51820=
     * Sources: All IPv4, All IPv6, unless you know the Pi will only
       connect from a set of specific IP addresses.
     * Description: This allows incoming VPN connections from the Pi.
   * ICMP:
     * Type: ICMP
     * Description: /Optional/ - to allow ping response to the public sentry.
   * Public SSH to the Pi:
     * Type: =Custom=
     * Protocol: =TCP=
     * Port Range: =2220=
     * Sources: All IPv4, All IPv6, or a specific set of static IP
       addresses if you want to be more secure.
     * Description: /Optional/ - this is so you can access the SSH
       console of the Raspberry Pi through the public sentry.
   * Public SSH access for Forgejo (public git access):
     * Type: =Custom=
     * Protocol: =TCP=
     * Port Range: =2222=
     * Sources: All IPv4, All IPv6, or a specific set of static IP
       addresses if you want to be more secure.
     * Description: /Optional/ - this is so you can fetch and push to
       git repositories over SSH.
   * Public SFTP access:
     * Type: =Custom=
     * Protocol: =TCP=
     * Port Range: =2223=
     * Sources: All IPv4, All IPv6, or a specific set of static IP
       addresses if you want to be more secure.
     * Description: /Optional/ - this is so you can use [[http://localhost:1313/portable-docker/install-web-services/sftp/][SFTP]].
  * Click =Create Firewall=.
#+end_notice

**** Create the DigitalOcean droplet

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Droplets= in the menu.
 * Click =Create Droplet=.
 * Choose a Region (e.g., New York), where the droplet will be created.
 * Underneath the heading =Choose an image=, choose =Debian= (select
   the latest version).
 * Choose a droplet size. For a wireguard proxy by itself, 1GB should
   be fine. 2GB RAM and 50GB disk recommended for medium size
   production installs with some apps installed on the droplet itself.
   (It is also tested working on as little as 512MB ram,
   [[https://blog.rymcg.tech/blog/linux/zram/][if you enable zram]]
   and/or create a 1GB swapfile. Do not abuse swap space like this in
   production! However I think its fine for development use, but you
   may occasionally run into low memory issues if less than 1GB.)
 * Select the =pi= user's SSH key to access this droplet.
 * Set the hostname for the Docker server. The name should be short
   and typeable, as it will become a part of the canononical service
   URLs. For this example, we choose =sentry=.
 * Verify everything is correct, and then click =Create Dropet=.
#+end_notice

**** Apply the DigitalOcean droplet firewall

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Find the firewall template you created, and click on it.
 * Click on the firewall's =Droplets= tab.
 * Click =Add Droplets= and search for the droplet you created and select it.
 * Click =Add Droplet= to add the firewall to the droplet.
#+end_notice

**** Create wildcard DNS records for the droplet

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Domains= tab.
 * Find the domain you created earlier, and click it.
 * Create an =A= record for the sentry:
   * Hostname: enter the subdomain name without the domain part (e.g.,
     =sentry=, the name of your docker server, without the
     =.example.com= suffix).
   * Will direct to: select the droplet you created from the list.
   * Click =Create Record=.
 * Create another =A= record, for the wildcard of the sentry:
   * Hostname: enter the same name as before but prepend =*.= in front
     of it (e.g., if the server is named =sentry=, create a record for
     =*.sentry=, without the =.example.com= suffix).
   * Will direct to: select the same droplet as before.
   * Click =Create Record=.
 * Create another =A= record, for the Raspberry Pi:
   * Hostname: e.g., =pi.example.com=.
   * Will direct to to: select the same droplet as before.
   * Click =Create Record=.
 * Create another =A= record, for the wildcard of the Raspberry Pi:
   * Hostname: e.g., =*.pi.example.com=.
   * Will direct to to: select the same droplet as before.
   * Click =Create Record=.
 * Create any more =A= records that you may need.
#+end_notice

#+attr_shortcode: :style secondary :title Test DNS
#+begin_notice
Test that your wildcard record actually works. Use the =dig= command
(For Debian/Ubuntu install the =dnsutils= package. For Arch Linux
install =bind-tools=. For Fedora install =bind-utils=.)

Pick some random subdomain off your domain:

#+begin_run
dig laksdflkweieri.sentry.example.com
#+end_run

#+begin_stdout
;; ANSWER SECTION:
laksdflkweieri.sentry.example.com.    3600    IN      A       153.114.12.78
#+end_stdout

Since you created the wildcard record for =*.sentry.example.com= dig
should return your Docker server's IP address in the =ANSWER SECTION=
of the output. You can test all your other records the same way.

If you run into DNS caching problems, verify with the source DNS
server directly:

#+begin_run
dig @ns1.digitalocean.com laksdflkweieri.sentry.example.com
#+end_run
#+end_notice

** Configure the sentry context on the Pi
:PROPERTIES:
:EXPORT_FILE_NAME: set-up-docker-context
:EXPORT_HUGO_WEIGHT: 320
:END:

You now need to be able to control the droplet's =root= user from the
 Raspberry Pi's =pi= user. Create a new SSH config entry for the
 sentry (replace =sentry.example.com= with your own droplet's DNS
 name):

[[/img/portable-docker/configure.webp]]
 
*** Append to the SSH config on the Pi
 
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host sentry
    User root
    Hostname sentry.example.com
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
The Hostname value should point to the same name you created the DNS
entry for the sentry.
#+end_notice

*** Test the connection from the Pi to the sentry
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh sentry whoami
#+end_run

The first time you connect, you must confirm the host fingerprint (type =yes=):

#+begin_stdout
The authenticity of host 'sentry' can't be established.
ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
#+end_stdout

On the final line, it will print the output of the command you
requested, which should print the username =root= :

#+begin_stdout
root
#+end_stdout

*** Create a new Docker context for the sentry

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context new
#+end_run

#+begin_stdout
? This command can help create a new SSH config and Docker context. Proceed? (Y/n) y 

? You must specify the SSH config entry to use  
> I already have an SSH host entry in ~/.ssh/config that I want to use
  I want to make a new SSH host entry in ~/.ssh/config

? Choose an existing SSH Host config  
  pi
> sentry

> Do you want to switch to the new sentry context now? Yes
#+end_stdout

*** Install Docker on the sentry

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry install-docker
#+end_run

#+begin_stdout
? This will install Docker on the host of your remote Docker context.. Proceed? Yes
#+end_stdout

*** Test the docker context is functional

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d tmp-context sentry docker info | grep Context
#+end_run

#+begin_stdout
 Context:    sentry
#+end_stdout

#+attr_shortcode: :title Switch between Docker contexts :style info
#+begin_notice
You should now have two configured Docker contexts on your Pi:
 * =pi=
 * =sentry=

You can switch between these two contexts using =d context=. The
currently selected context specifies which Docker server is currently
being operated on.
#+end_notice

** Configure d.rymcg.tech for the sentry
:PROPERTIES:
:EXPORT_FILE_NAME: configure-d-rymcg-tech-for-sentry
:EXPORT_HUGO_WEIGHT: 325
:END:

*** Run the main config

The main config must be run for each new context you create:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry config
#+end_run

#+begin_stdout
> This will make a configuration for the current docker context (sentry). Proceed? Yes

ROOT_DOMAIN: Enter the root domain for this context (e.g., d.example.com)
: sentry.example.com
#+end_stdout

*** Install Traefik

This is a very similar process as when you installed Traefik on the
Raspberry Pi:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Create the traefik user:

#+begin_stdout
? Traefik Configuration:  
> Traefik user
#+end_stdout

Configure ACME:

#+begin_stdout
? Traefik TLS config:  
  Configure certificate authorities (CA)
> Configure ACME (Let's Encrypt or Step-CA)
  Configure TLS certificates (make certs)
#+end_stdout

Choose Let's Encrypt:

#+begin_stdout
? Which ACME provider do you want to use?  
> Let's Encrypt (ACME)
  Step-CA (ACME)
  Disable ACME
  Cancel / Go back
#+end_stdout

Choose the Production environment:

#+begin_stdout
? Which LE environment do you want to use?  
> Production (recommended!)
  Staging (untrusted / testing)
#+end_stdout

Choose the DNS-01 challenge type:

#+begin_stdout
? Which type of ACME challenge should be used?  
  TLS-ALPN-01 (default for public servers, easy, but no wildcard certs)
> DNS-01 (requires API key, but good behind firewalls, and allows wildcard certs)

Find the provider code of your supported DNS provider here:
https://go-acme.github.io/lego/dns/#dns-providers

TRAEFIK_ACME_DNS_PROVIDER: Enter the LEGO code for your DNS Provider (e.g., digitalocean)
: digitalocean
#+end_stdout

Enter the variable /name/ literal DO_AUTH_TOKEN:

#+begin_stdout
# For DigitalOcean, literally enter DO_AUTH_TOKEN here.
TRAEFIK_ACME_DNS_VARNAME_1: Enter the 1st DNS provider variable name (e.g., DO_AUTH_TOKEN)
: DO_AUTH_TOKEN
TRAEFIK_ACME_DNS_VARNAME_2: Enter the 2nd DNS provider variable name (or leave blank)
: 
#+end_stdout

Enter a blank for the second var name, because there isn't one.

Now enter the variable /value/ for DO_AUTH_TOKEN (this should actually
be the secret [[https://cloud.digitalocean.com/account/api/tokens/new][personal access token that you generate on DigitalOcean]]):
#+begin_stdout
Now to enter the values for the custom DNS API variables:
DO_AUTH_TOKEN: Enter the value for DO_AUTH_TOKEN (e.g., your-actual-digitalocean-token-here)
: dop_v1_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#+end_stdout

Create a new TLS certificate:

#+begin_stdout
? Traefik TLS config:  
  Configure certificate authorities (CA)
  Configure ACME (Let's Encrypt or Step-CA)
> Configure TLS certificates (make certs)

? Configure Traefik TLS certificates  
  Manage all certificates.
> Create a new certificate.
  Done / Go back

Enter the main domain (CN) for this certificate (e.g., `d.rymcg.tech` or `*.d.rymcg.tech`)
: sentry.example.com

Now enter additional domains (SANS), one per line:
Enter a secondary domain (enter blank to skip)
: *.sentry.example.com
Enter a secondary domain (enter blank to skip)
: 

Main domain:
 sentry.example.com
Secondary (SANS) domains:
 *.sentry.example.com
#+end_stdout

*** Install Traefik

Press =ESC= three times to go back to the main menu.

Install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

When done, press =ESC= to quit the Traefik config program.

*** Install whoami

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make whoami config
#+end_run

#+begin_stdout
WHOAMI_TRAEFIK_HOST: Enter the whoami domain name (e.g., whoami.example.com)
: whoami.sentry.example.com

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout


#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make whoami install
#+end_run

#+attr_shortcode: :style info :title Whoami on the sentry
#+begin_notice
This instance of whoami runs on the droplet, and it is only to test
the connectivity of the public droplet itself. We still have not yet
exposed the whoami running on the Raspberry Pi publicly.
#+end_notice


*** Wait a few minutes for the TLS certificate to generate

*** Test the whoami instance

You can open the page in =w3m=:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry make whoami open
#+end_run

Or test it with curl:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
curl https://whoami.sentry.example.com
#+end_run

Note that if the TLS certificate has not been issued yet, you will get
this error from curl (and a similar error in =w3m=):

#+begin_stdout
curl: (60) SSL certificate problem: self-signed certificate
More details here: https://curl.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
#+end_stdout

Simply wait a bit longer for the TLS cert to issue, or check the logs
for errors (=d make traefik logs service=traefik=). You can also tell
curl to ignore the error (=-k=):

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
## This is insecure, but fine for testing:
curl -k https://whoami.sentry.example.com
#+end_run

A valid whoami response page looks like similar to this:

#+begin_stdout
Name: default
Hostname: 52a9750ecaa4
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:56082
GET / HTTP/1.1
Host: whoami.sentry.example.com
User-Agent: curl/7.88.1
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: X.X.X.X
X-Forwarded-Host: whoami.sentry.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: sentry
X-Real-Ip: X.X.X.X
#+end_stdout

*** Next steps 

 * Configure the WireGuard VPN.
 * Set up public SSH.
 * Install core services.
 * Install apps.

* Configure WireGuard VPN
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: configure-wireguard-tunnel
:EXPORT_HUGO_WEIGHT: 400
:END:

** Configure WireGuard VPN
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 401
:END:
#+attr_shortcode: :depth 999

[[/img/portable-docker/dragon.webp]]

WireGuard will now be installed on the sentry and Raspberry Pi.
WireGuard is a peer-to-peer connection, but for convience the sentry
will be called the server and the Pi will be called the client.

By default, the private VPN IP network is =10.13.16.1/24=, with static
IP addresses assigned for each peer:

 * Sentry WireGuard server : =10.13.16.1=
 * Raspberry Pi WireGuard client : =10.13.16.2=

The sentry can support up to 252 additional VPN clients, having
consecutive IP addresses =10.13.16.3= through =10.13.16.254=.

#+begin_index
index
#+end_index
** Configure sentry wireguard server
:PROPERTIES:
:EXPORT_FILE_NAME: configure-sentry-wireguard-server
:EXPORT_HUGO_WEIGHT: 410
:END:

[[/img/portable-docker/tunnel.webp]]

*** Reconfigure Traefik to enable WireGuard server

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
  Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
> Configure wireguard VPN

? Should this Traefik instance connect to a wireguard VPN?  
  No, Traefik should use the host network directly.
> Yes, and this Traefik instance should start the wireguard server.
  Yes, but this Traefik instance needs credentials to connect to an outside VPN.

? Should Traefik bind itself exclusively to the VPN interface?  
> No, Traefik should work on all interfaces (including the VPN).
  Yes, Traefik should only listen on the VPN interface.

TRAEFIK_VPN_HOST: Enter the public Traefik VPN hostname (e.g., vpn.example.com)
: sentry.example.com
TRAEFIK_VPN_SUBNET: Enter the Traefik VPN private subnet (no mask) (e.g., 10.13.16.0)
: 10.13.16.0
TRAEFIK_VPN_ADDRESS: Enter the Traefik VPN private IP address (e.g., 10.13.16.1)
: 10.13.16.1
TRAEFIK_VPN_PORT: Enter the Traefik VPN TCP port number (e.g., 51820)
: 51820
Enter the Traefik VPN peers list
: pi
#+end_stdout

You may enter up 253 peer names, separated by commas, with no spaces,
e.g., =pi,pi2,phone1,toaster,garage=. Each client name should be a
single word of letters and/or numbers.

Press =ESC= two times to back out to the main menu.

#+attr_shortcode: :style tip
#+begin_notice
You may also add additional clients at a later time, however you
should not remove or change the order of the existing clients, so it
is only safe to append to this list. If you need to remove a client,
you should destroy all the clients and recreate them.

#+attr_shortcode: :style warning :title Run this if you need to reset all the client keys
#+begin_run
## Resets all WireGuard keys:
sentry make traefik destroy service=wireguard
sentry make traefik install
#+end_run
#+end_notice

*** Reconfigure Traefik to add a Layer 7 route to the Raspberry Pi

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

> Do you want to enable the layer 7 TLS proxy? Yes

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: whoami.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443
##
## See https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint              Destination_address  Destination_port  Proxy_protocol
----------              -------------------  ----------------  --------------
whoami.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= multiple times to back out to the main menu. On the main
menu, select =Install=, to re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

*** Find the wireguard peer config

You can check the wireguard service is now started:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik show-wireguard-peers
#+end_run

#+begin_stdout
## /config/peer_pi/peer_pi.conf
[Interface]
Address = 10.13.16.2
PrivateKey = 2E1vQHCS5JuaoRrt21GO0bYVrafOhplrGNFqoFBivEY=
ListenPort = 51820
DNS = 10.13.16.1

[Peer]
PublicKey = AZiNh/5sk71QTy6Rk0ygzIUsSGAX8/s3EeGN6lT9oj0=
PresharedKey = tEIW8FuxR6I+Qu79bORatbD+JgNPeigNvc9V18f7to8=
Endpoint = sentry.example.com:51820
AllowedIPs = 10.13.16.0/24
#+end_stdout

Copy the output you see into a tempory buffer / notepad, you will need
to copy this information in the next chapter.

** Configure Raspberry Pi WireGuard client
:PROPERTIES:
:EXPORT_FILE_NAME: configure-raspberry-pi-wireguard-client
:EXPORT_HUGO_WEIGHT: 420
:END:

[[/img/portable-docker/castle.webp]]

*** Reconfigure Traefik to enable WireGuard client

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
  Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
> Configure wireguard VPN

? Should this Traefik instance connect to a wireguard VPN?  
  No, Traefik should use the host network directly.
  Yes, and this Traefik instance should start the wireguard server.
> Yes, but this Traefik instance needs credentials to connect to an outside VPN.

? Should Traefik bind itself exclusively to the VPN interface?  
> No, Traefik should work on all host interfaces (including the VPN).
  Yes, Traefik should only listen on the VPN interface.

TRAEFIK_VPN_CLIENT_INTERFACE_ADDRESS: Enter the wireguard client Interface Address (e.g., 10.13.16.2)
: 10.13.16.2
TRAEFIK_VPN_CLIENT_INTERFACE_PRIVATE_KEY: Enter the wireguard PrivateKey (ends with =)
: 2E1vQHCS5JuaoRrt21GO0bYVrafOhplrGNFqoFBivEY=
TRAEFIK_VPN_CLIENT_INTERFACE_LISTEN_PORT: Enter the wireguard listen port (e.g., 51820)
: 51820
TRAEFIK_VPN_CLIENT_PEER_PUBLIC_KEY: Enter the Peer PublicKey (ends with =)
: AZiNh/5sk71QTy6Rk0ygzIUsSGAX8/s3EeGN6lT9oj0=
TRAEFIK_VPN_CLIENT_PEER_PRESHARED_KEY: Enter the Peer PresharedKey (ends with =)
: tEIW8FuxR6I+Qu79bORatbD+JgNPeigNvc9V18f7to8=
TRAEFIK_VPN_CLIENT_PEER_ENDPOINT: Enter the Peer Endpoint (host:port)
: sentry.example.com:51820
TRAEFIK_VPN_CLIENT_PEER_ALLOWED_IPS: Enter the Peer AllowedIPs (e.g., 10.13.16.1/32)
: 10.13.16.1/32
#+end_stdout

*** Reinstall Traefik

Press =ESC= twice to go back to the main menu, then re-install:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Once reinstalled, press =ESC= to quit the config tool.

*** Test VPN connectivity

Check the logs:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make traefik logs service=wireguard-client
#+end_run

#+begin_stdout
wireguard-client-1  | 2024-09-28T08:42:09.445201647Z **** All tunnels are now active ****
#+end_stdout

Enter the wireguard client shell to test networking parameters:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make traefik shell service=wireguard-client
#+end_run

Show the connected wireguard peers:

#+attr_shortcode: :title Run this in the WireGuard Client shell :style info
#+begin_run
wg
#+end_run

#+attr_shortcode: :title Look for the last handshake time :style info
#+begin_notice
The output of =wg= should show the peer and the =latest handshake=
time, for example:

: latest handshake: 45 seconds ago

If you do not see a handshake time, then there is some kind of problem
connecting to the WireGuard server that you need to resolve.
#+end_notice

Ping the WireGuard server (=10.13.16.1=):

#+attr_shortcode: :title Run this in the WireGuard Client shell :style info
#+begin_run
ping -c3 10.13.16.1
#+end_run

When you are done using the shell press =Ctrl-D= or type =exit= to
quit.

*** Check that whoami is available publicly

In the last chapter you created a layer 7 route for the URL
=https://whoami.pi.example.com=. Now that your wireguard connection
is active on both ends, it should be publicly accessible. Test the URL
in your personal web browser.

*** Next steps

 * Set up public SSH.
 * Install core services.
 * Install apps.

* Set up public SSH
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: set-up-public-ssh-reverse-tunnel
:EXPORT_HUGO_WEIGHT: 500
:END:
** Set up public SSH
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 501
:END:

This chapter will focus on creating an out-of-band backup SSH tunnel
(non-WireGuard, non-Traefik based), using a public gateway port on the
sentry. This backdoor connection will ensure that you retain access to
the Raspberry Pi even during emergency maintenance cycles, including
restarting Traefik, restarting Docker, or even rebooting the system
(the persistent tunnels will be restarted on boot).

*** Ensure the SSH server is secure

During the =rpi-imager= configuration, you should have selected the
option for SSH to =Allow public-key authentication only=. You should
double-check that this setting was applied:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
cat /etc/ssh/sshd_config | grep "^PasswordAuthentication"
#+end_run

#+begin_stdout
PasswordAuthentication no
#+end_stdout

If correctly setup, it should show that =PasswordAuthentication= is
disabled (thus requring the use of keys rather than passwords).

*** Open the firewall for SSH (port 2220)

#+attr_shortcode: :style tip :title Open the SSH port in the firewall
#+begin_notice
The example TCP port used for the SSH tunnel is =2220=. Make sure you
open this port in the public sentry firewall (i.e., DigitalOcean
firewall).
#+end_notice

*** Install dependencies

[[https://github.com/Autossh/autossh][AutoSSH]] is used to create a reliable SSH tunnel.

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sudo apt-get update
sudo apt-get install -y autossh
#+end_run

*** Enable SSH GatewayPorts on the sentry

To expose a public reverse tunnel via SSH, you must enable the
non-default [[https://man.archlinux.org/man/sshd_config.5#GatewayPorts][GatewayPorts]] setting in the server's SSH config, which
allows reverse tunnels to be published to the WAN interface of the
sentry:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry sshd-config GatewayPorts=yes
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
This will permanently alter the sentry's =/etc/ssh/sshd_config= file
and will then restart =sshd=. To restore the setting, run the inverse
command:

#+attr_shortcode: :style other :title To disable GatewayPorts
#+begin_run
## This is the default setting:
sentry sshd-config GatewayPorts=no
#+end_run

With =GatewayPorts=no=, the reverse tunnels can only be accessed from
the sentry's loopback (=lo=) interface at =127.0.0.1=, effectively
blocking public access.
#+end_notice

*** Make a one-time transient tunnel

Forward the public sentry port =2220= to the local Raspberry Pi port
=22=:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry ssh-expose 2220 22
#+end_run

To check the status:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry ssh-expose
#+end_run

#+begin_stdout
## Active tunnels:
HOST            PUBLIC_PORT  LOCAL_PORT   TYPE        
----            -----------  ------------ ----        
sentry          2220         22           transient   
#+end_stdout

With the tunnel active, you can ssh to the Pi from anywhere, going
through the reverse tunnel public port:

#+begin_run
ssh -p 2220 pi@pi.example.com
#+end_run

To stop the service later:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry ssh-expose 2220 22 --close
#+end_run

*** Make a persistent tunnel

To make a persistent connection that will survive a reboot, you must
enable the systemd linger privilege for the =pi= user:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sudo loginctl enable-linger ${USER}
#+end_run

To create a persistent connection, use the the =--persistent= flag:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry ssh-expose 2220 22 --persistent
#+end_run

#+begin_stdout
## Active tunnels:
HOST            PUBLIC_PORT  LOCAL_PORT   TYPE        
----            -----------  ------------ ----        
sentry          2220         22           persistent  
#+end_stdout

*** Reconfigure SSH clients

On your personal workstation, you can create a new config for
accessing the Pi through the public sentry reverse tunnel:

#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host pi.example.com
    User pi
    Port 2220
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

**** Test the public SSH connection to the Pi

#+begin_run
ssh -t pi.example.com w
#+end_run

The =w= command prints a list of the currently logged in users, and
their remote IP address (=-t= is important to ensure the current
connection is included):

#+begin_stdout
18:24:29 up 5 days, 33 min,  1 user,  load average: 0.10, 0.07, 0.08
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
ryan     pts/2    127.0.0.1        18:24    0.00s  0.01s  0.01s w
#+end_stdout

#+attr_shortcode: :style tip
#+begin_notice
Unfortunately there is no way to show the real origin IP address of
the connection; it will always show the IP address of the tunnel
(=127.0.0.1=).
#+end_notice

* Install core services
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: install-core-services
:EXPORT_HUGO_WEIGHT: 600
:END:
** Install core services
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 601
:END:

[[/img/portable-docker/core-services.webp]]

There are a few services you should consider installing before any
others, which we will call core services:

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

** Forgejo
:PROPERTIES:
:EXPORT_FILE_NAME: forgejo
:EXPORT_HUGO_WEIGHT: 620
:END:

[[https://forgejo.org/][Forgejo]] is a self-hosted git forge similar to [[https://docs.github.com/en/get-started/start-your-journey/about-github-and-git][GitHub]]. Forgejo is a
fork of [[https://github.com/go-gitea/gitea?tab=readme-ov-file#gitea][Gitea]], which is a fork of [[https://github.com/gogs/gogs][Gogs]].

[[/img/portable-docker/forgejo-home.webp]]

Installing Forgejo is useful for two unrelated purposes:

 * Self-hosting your own git repositories.
 * Providing an OAuth2 identity service for your organization,
   facilitating single-sign on to all of your apps via Traefik's
   [[https://doc.traefik.io/traefik/middlewares/http/forwardauth/][forward-auth middleware]].

#+attr_shortcode: :style info :title Forgejo is fundamental infrastructure
#+begin_notice
You don't need to install Forgejo on every server you make, but having
at least one instance in your domain is recommended.

Even if you (or your users) have no need for storing git repositories,
Forgejo is part of the fundamental infrastructure of securing other
d.rymcg.tech apps via OAuth2. You can authenticate and authorize your
users to access your apps via their Forgejo account (sentry
authorization), see the next chapter: [[/portable-docker/install-core-services/traefik-forward-auth][Traefik Forward Auth]].
#+end_notice

*** Configure Forgejo

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make forgejo config
#+end_run

Configure the domain name and service description:

#+begin_stdout
FORGEJO_TRAEFIK_HOST: Enter your forgejo domain name (eg. git.example.com)
: git.pi.example.com

APP_NAME: Enter the service description (eg. "git thing")
: pi5 git hosting

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?
> No
  Yes, with Mutual TLS (mTLS)
#+end_stdout

*** Install Forgejo

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make forgejo install
#+end_run

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: git.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint           Destination_address  Destination_port  Proxy_protocol
----------           -------------------  ----------------  --------------
git.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.


*** Finish Forgejo installation

Immediately open the Foregjo application to finish the installation.
Open your web browser to =https://git.pi.example.com=.

This should show a page with the title =Initial configuration= at the
top. The *only* thing you need to change on this page is the admin
credentials found at the bottom (all of other settings are instead
derived from the environment variables found in the Forgejo
=.env_{CONTEXT}_{INSTANCE}= file created by d.rymcg.tech):

[[/img/portable-docker/forgejo-admin-account-settings.webp]]

 * You should create a dedicated admin account, separate from your
   personal account.
 * Click =Administrator account settings= to expand the section.
 * Enter the =Adminstrator username=: =root=
 * Enter the admin email address.
 * Enter a secure passphrase and confirmation.
 * Click the =Install Forgejo= button at the very bottom.

Once logged in as =root=, you can create additional user accounts from
the account icon in the top right, which expands a menu.

[[/img/portable-docker/forgejo-admin-site-settings.webp]]

 * Click =Site adminstration=.
 * Click =Identity & access=.
 * Click =User accounts=.

[[/img/portable-docker/forgejo-admin-user-accounts.webp]]

 * Click =Create User Account= and create your own personal account.
 * Log out of the root account and test logging into the new account.

*** Which account to use?

 * You should use the =root= account for creating new OAuth2 apps and
   for creating new users.
 * You should use your personal account for storing your git
   repositories and for your identity when logging into other apps.

*** Enable access to repositories by SSH

By default, Forgejo only supports cloning its hosted git repositories
via HTTPS. To allow cloning by SSH, you must enable the Traefik SSH
entrypoint:

**** Enable the Traefik SSH entrypoint
#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
  Traefik user
> Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level

? Traefik entrypoint config  
  Show enabled entrypoints
> Configure stock entrypoints
  Configure custom entrypoints

? Select entrypoint to configure:  
^ websecure : HTTPS (TLS encrypted HTTP)
  web_plain : HTTP (unencrypted; specifically NOT redirected to websecure; must use different port than web)
  mqtt : MQTT (mosquitto) pub-sub service
> ssh : SSH (forgejo) git (ssh) entrypoint
  xmpp_c2s : XMPP (ejabberd) client-to-server entrypoint
  xmpp_s2s : XMPP (ejabberd) server-to-server entrypoint
v mpd : Music Player Daemon (mopidy) control entrypoint

> Do you want to enable the ssh entrypoint? Yes

TRAEFIK_SSH_ENTRYPOINT_HOST: Enter the host ip address to listen on (0.0.0.0 to listen on all interfaces) (eg. 0.0.0.0)
: 0.0.0.0

TRAEFIK_SSH_ENTRYPOINT_PORT: Enter the host port to listen on (eg. 2222)
: 2222

? Is this entrypoint downstream from another trusted proxy?  
> No, clients dial directly to this server. (Turn off Proxy Protocol)
  Yes, clients are proxied through a trusted server. (Turn on Proxy Protocol)
#+end_stdout

#+attr_shortcode: :style warning :title Do not enable Proxy Protocol
#+begin_notice
Do not enable Proxy Protocol, because it is not supported by SSH.
#+end_notice

Press =ESC= three times to go back to the main menu, then re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Once reinstalled, press =ESC= to exit the config tool.

**** TODO Create an entrypoint on the sentry

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)


? Traefik Configuration:  
  Traefik user
> Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level

? Custom Entrypoints: <canceled>

? Traefik entrypoint config  
  Show enabled entrypoints
  Configure stock entrypoints
> Configure custom entrypoints

? Traefik entrypoint config  
  Show enabled entrypoints
  Configure stock entrypoints
> Configure custom entrypoints

? Custom Entrypoints:  
  List custom entrypoints
> Add new custom entrypoint
  Remove custom entrypoints

Adding a custom TCP/UDP entrypoint - 

 * Make sure to enable the port in all upstream firewalls.
 * Make sure each entrypoint has a unique lower-case one-word name.

Enter the new entrypoint name:
: forgejo

Enter the entrypoint listen address:
: 0.0.0.0

Enter the entrypoint port:
: 2222

Enter the protocol (tcp or udp):
: tcp
? Is this entrypoint downstream from another trusted proxy?  
> No, clients dial directly to this server. (Turn off Proxy Protocol)
  Yes, clients are proxied through another trusted proxy. (Turn on Proxoy Protocol)
#+end_stdout

#+attr_shortcode: :style warning :title Do not enable Proxy Protocol
#+begin_notice
SSH does not support [[https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt][Proxy Protocol]], so be sure to disable it.
#+end_notice

Press =ESC= three times to go back to the main menu.

**** Create a route from the sentry to the Pi

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)
  
? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
  Configure layer 7 TLS proxy
> Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 4 TCP/UDP Proxy:  
  List layer 4 ingress routes
> Add new layer 4 ingress route
  Remove layer 4 ingress routes
  Disable layer 4 TCP/UDP Proxy

? Entrypoint  
> forgejo

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 2222

##
## See https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt

> Do you want to enable Proxy Protocol for this route? No
Set TRAEFIK_LAYER_4_TCP_UDP_PROXY_ROUTES=ssh_pi:10.13.16.2:22:0,forgejo:10.13.16.2:2222:0
## Configured Layer 4 Routes:
Entrypoint  Destination_address  Destination_port  Proxy_protocol
----------  -------------------  ----------------  --------------
forgejo     10.13.16.2           2222              0
ssh_pi      10.13.16.2           22                0
#+end_stdout

Press =ESC= three times to go back to main menu, then re-install
Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Once reinstalled, press =ESC= to exit the config tool.

**** Test cloning a repository via SSH

 * Login to your Forgejo instance
 * Create a new repository
 * On the repository page, click on SSH and copy the SSH URL.

#+begin_run
git clone ssh://git@git.pi.example.com:2222/username/repository.git
#+end_run

** Traefik-Forward-Auth (sentry authorization)
:PROPERTIES:
:EXPORT_FILE_NAME: traefik-forward-auth
:EXPORT_HUGO_WEIGHT: 630
:END:

*** Sentry authorization

Some apps may already have their own authentication mechanisms, while
others may not. Sentry authorization creates a common authentication
and authorization framework /in front of/ your applications via
Traefik middleware. Sentry authorization happens /before/ any existing
auth mechanisms in the app itself, and so it acts as a front door
gatekeeper for your apps. It can't control what users are allowed to
do once they get in, but it does control who is allowed in through the
front door.

 * Users are /authenticated/ via the [[/portable-docker/install-core-services/forgejo/index.html][Forgejo]] instance and [[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master/traefik-forward-auth#traefik-forward-auth][traefik-forward-auth]].
 * Users are /authorized/ by a group membership filter applied on a
   per-app basis.

*** Configure traefik-forward-auth

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make traefik-forward-auth config
#+end_run

#+begin_stdout
TRAEFIK_FORWARD_AUTH_HOST: Enter the traefik-foward-auth host domain name (eg. auth.example.com)
: auth.pi.example.com

TRAEFIK_FORWARD_AUTH_COOKIE_DOMAIN: Enter the cookie domain name (ie ROOT domain) (eg. example.com)
: pi.example.com

? Select the OAuth provider to use  
> gitea
  github
  google
  discord

TRAEFIK_FORWARD_AUTH_GITEA_DOMAIN: Enter your gitea domain name (eg. git.example.com)
: git.pi.example.com
#+end_stdout

At this point it will open =w3m= to the gitea instance asking you to
sign in. Because this isn't very user friendly, so just press =q= and
then =y= to quit =w3m=.

 * Open your preffered web browser and open up the gitea URL:
   =https://git.pi.example.com=
 * Make sure you are logged in as the =root= user.
 * Open the root user settings page, click =Applications=.
 * Fill in the section titled =Manage OAuth2 applications=:
   * Enter an application name as a public identifier.
   * Enter the redirect URI =https:://auth.pi.example.com/_oauth=.
 * Click =Create Application=.

[[/img/portable-docker/forgejo-admin-user-create-app.webp]]

 * This will show you the OAuth2 client ID and secret:

[[/img/portable-docker/forgejo-admin-user-app-secret.webp]]

Back in your terminal session, it should be asking you to fill these
same details in:

#+begin_stdout
TRAEFIK_FORWARD_AUTH_PROVIDERS_GENERIC_OAUTH_CLIENT_ID: Copy and Paste the OAuth2 client ID here
: 38d6c7f7-c712-43a9-967c-27888819e85f

TRAEFIK_FORWARD_AUTH_PROVIDERS_GENERIC_OAUTH_CLIENT_SECRET: Copy and Paste the OAuth2 client secret here
: gto_4g54tazy7oyslypqhr7z7khundcmtwezlkdeyghe7ctj7k4gltvq

TRAEFIK_FORWARD_AUTH_LOGOUT_REDIRECT: Enter the logout redirect URL
: https://git.pi.example.com/logout
#+end_stdout

*** Install Traefik-Forward-Auth

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make traefik-forward-auth install
#+end_run

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: auth.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint           Destination_address  Destination_port  Proxy_protocol
----------           -------------------  ----------------  --------------
auth.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Add user groups for sentry authorization

With OAuth2 sentry authorization enabled, users are authorized to
access apps only if they are a member of an authorized group for that
app. You need to create the group membership lists in the Traefik
config:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
  Traefik user
  Entrypoints (including dashboard)
  TLS certificates and authorities
> Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level

? Traefik middleware config:  
  MaxMind geoIP locator
> OAuth2 sentry authorization (make sentry)

? Sentry Authorization Manager (main menu):  
> Group Manager
  User Manager
  List all members
  List authorized callback URLs
  Quit

> Sentry Authorization Manager (main menu): Group Manager
? Choose a group to manage  
> Create a new group

? Enter the name of the group to create: admin

> Do you want to add users to this group now? Yes

Enter the new user id(s) to add, one per line:
? Enter a user ID (Press Esc or enter a blank value to finish)  me@example.com
#+end_stdout

#+attr_shortcode: :style tip
#+begin_notice
Replace =me@example.com= with the same *email address* that you used
to sign up for your personal account in Forgejo. You can add more
users to the group if you wish, when done enter a blank line.
#+end_notice

*** Re-configure whoami with sentry authorization (OAuth2)

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make whoami config
#+end_run

#+begin_stdout
WHOAMI_TRAEFIK_HOST: Enter the whoami domain name (eg. whoami.example.com)
: whoami.pi.example.com

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?
  No
  Yes, with HTTP Basic Authentication
> Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)

? Which authorization group do you want to permit access to this app?  
> admin
#+end_stdout

#+attr_shortcode: :style tip :title Tip
#+begin_notice
This will allow only the =admin= authorization group to access this
instance.

Remember, you can create [[/portable-docker/install-core-services/traefik-forward-auth/#add-user-groups-for-sentry-authorization][extra authorization groups]] in the Traefik
config, that way you can have separate user access per instance.
#+end_notice

Re-install whoami:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make whoami install
#+end_run

*** Test login for whoami

Open the whoami app in your web browser: =https://whoami.pi.example.com=.

You should be automatically redirected to the Foregjo app to login.

The first time a Forgejo user authenticates to a sentry authorization
protected app, they should see this prompt:

[[/img/portable-docker/forgejo-authorize-app.webp]]

Confirm by clicking the button =Authorize Application=.

If the user is authorized, they should be automatically redirected
back to the whoami app.

The output of whoami now reflects the authorized user:

#+begin_stdout
Name: default
Hostname: c863ccd86cec
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:38606
GET / HTTP/1.1
Host: whoami.pi.example.com
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:127.0) Gecko/20100101 Firefox/127.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: en-US,en;q=0.5
Cookie: _forward_auth=xxxxxxxxxxxxxxxxxxxxxxxxxxx=|123456789|me@example.com
Dnt: 1
Priority: u=1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-site
Sec-Fetch-User: ?1
Te: trailers
Upgrade-Insecure-Requests: 1
X-Forwarded-For: 192.168.1.1
X-Forwarded-Host: whoami.pi.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: pi
X-Forwarded-User: me@example.com
X-Real-Ip: 192.168.1.1
#+end_stdout

The request shows the new details:

 * =Cookie= the cookie value is set by the traefik-forward-auth
   middleware once the user is successfully authenticated.
 * The =X-Forwarded-User= is passed to the application to identify the
   validated user id (email address).

*** Reconfigure other apps to use OAuth2

All other apps may be protected with sentry authorization in the same manner as whoami.

*** Next steps

 * Install apps.

* Install apps
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: install-web-services
:EXPORT_HUGO_WEIGHT: 7000
:END:
** Install apps
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 7001
:END:

[[/img/portable-docker/surf.webp]]

You may install any of the [[https://github.com/EnigmaCurry/d.rymcg.tech?tab=readme-ov-file#install-applications][apps bundled with d.rymcg.tech]] or you can
create your own. Included in this chapter are instructions for only a
subset of the available apps.

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Immich
:PROPERTIES:
:EXPORT_FILE_NAME: immich
:EXPORT_HUGO_WEIGHT: 7100
:END:

[[https://immich.app/][Immich]] is an open-source self-hosted photo and video management
solution.

[[/img/portable-docker/immich-gallery.webp]]

*** Configure Immich

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make immich config
#+end_run


#+begin_stdout
IMMICH_TRAEFIK_HOST: Enter the Immich domain name (e.g., immich.example.com)
: immich.pi.example.com

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)

? Select the hardware acceleration to use for machine learning
> CPU
  ...

? Select the hardware acceleration to use for transcoding
> CPU
  ...

? Select whether you want Immich to upload images to a bind mount on the host or to a named Docker volume  
  bind mount
> Docker volume
#+end_stdout

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make immich install wait
#+end_run

Wait for the services to start and report themselves as healthy:

#+begin_stdout
Waiting until all services are started and become healthy ...
All services healthy.
#+end_stdout

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: immich.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint              Destination_address  Destination_port  Proxy_protocol
----------              -------------------  ----------------  --------------
immich.pi.example.com  10.13.16.2           443               2
whoami.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.


*** Finish

The app is now deployed at the URL you configured: =https://immich.pi.example.com=

#+attr_shortcode: :title Immediately secure the admin account :style warning
#+begin_notice
You should immediately open the URL in your web browser:
=https://immich.pi.example.com= and complete the initial
configuration to secure the admin user account.
#+end_notice

** SFTP (and Thttpd)
:PROPERTIES:
:EXPORT_FILE_NAME: sftp
:EXPORT_HUGO_WEIGHT: 7200
:END:

[[https://www.rfc-editor.org/rfc/rfc4253][SFTP]] (SSH File Transfer Protocol) is a standard and secure method of
transferring files. There are clients available for all platforms. You
can configure an SFTP server to send and receive files directly with
your Docker volumes.

*** Install a demo web server (thttpd)

[[https://www.acme.com/software/thttpd/][Thttpd]] is a tiny static HTTP server for hosting websites. It will be
used for demonstration purposes in showing the effect of transferring
files directly into its volume, via SFTP. You can substitute this with
[[/portable-docker/install-web-services/nginx-and-php/][Nginx]] if you prefer. This same approach will work with any Docker
volume.

**** Configure thttpd

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make thttpd config
#+end_run

Thttpd will serve a website at a URL of your choosing:

#+begin_stdout
THTTPD_TRAEFIK_HOST: Enter the website domain name (eg. thttpd.example.com)
: www.pi.example.com

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout

Install thttpd:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make thttpd install
#+end_run

**** Configure the thttpd route on the sentry

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: www.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes
#+end_stdout

Press =ESC= three times to go back to the main menu, then re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Once re-installed, press =ESC= to quit the config tool.

**** Open the website in your browser

 * Open =https://www.pi.example.com= in your web browser.
 * Because there are no files uploaded yet, the page will show only an
   index:

[[/img/portable-docker/thttpd-index.webp]]

*** Configure SFTP

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make sftp config
#+end_run

#+begin_stdout
SFTP_PORT: Enter the public SSH port (eg. 2223)
: 2223

SFTP_USERS: Enter the user:uid list (eg. ryan:1000,gary:1001)
: www:54321
#+end_stdout

#+attr_shortcode: :style info :title Use the same UID as thttpd
#+begin_notice
The thttpd container has a user with UID =54321=, so the SFTP user
(=www=) has to have the same UID =54321=.
#+end_notice

#+begin_stdout
SFTP_VOLUMES: Enter the volume:user:mount list (can be blank)
: thttpd_files:www:public_html
#+end_stdout

#+attr_shortcode: :style info :title SFTP_VOLUMES
#+begin_notice
The =SFTP_VOLUMES= setting is a list of 3-tuple separated by the
character =:=

 1. The Docker volume to mount (e.g., =thttpd_files=)
 2. The SFTP user that should own the mountpoint (e.g., =www=.)
 3. An arbitrary mount point sub-directory, only visible to the SFTP
    user

In the example above, the Docker volume named =thttpd_files= is
mounted inside the =www= user's SFTP home directory, in a
sub-directory named =public_html=.

The user may have access to multiple volumes, each with a different
mount point. Additional volumes may be mounted as a comma separated
list of 3-tuples:

: thttpd_files:www:public_html,other_volume:www:other_files

If mounting multiple volumes under one SFTP user, all volume files
must share the same owner. If the files require different ownership,
you must use different SFTP users.
#+end_notice

Install sftp:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make sftp install
#+end_run

*** Enable SFTP traffic

**** Enable the SFTP entrypoint on the sentry

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sentry make traefik config
#+end_run


#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
  Traefik user
> Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level

? Traefik entrypoint config  
  Show enabled entrypoints
  Configure stock entrypoints
> Configure custom entrypoints

? Custom Entrypoints:  
  List custom entrypoints
> Add new custom entrypoint
  Remove custom entrypoints

Enter the new entrypoint name:
: sftp

Enter the entrypoint listen address:
: 0.0.0.0

Enter the entrypoint port:
: 2223

Enter the protocol (tcp or udp):
: tcp
? Is this entrypoint downstream from another trusted proxy?  
> No, clients dial directly to this server. (Turn off Proxy Protocol)
  Yes, clients are proxied through another trusted proxy. (Turn on Proxoy Protocol)
#+end_stdout

#+attr_shortcode: :style warning :title Do not enable Proxy Protocol
#+begin_notice
SSH does not support [[https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt][Proxy Protocol]], so be sure to disable it.
#+end_notice

Press =ESC= three times to go back to the main menu.

**** Create the SFTP route on the sentry

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
  Configure layer 7 TLS proxy
> Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 4 TCP/UDP Proxy:  
  List layer 4 ingress routes
> Add new layer 4 ingress route
  Remove layer 4 ingress routes
  Disable layer 4 TCP/UDP Proxy

? Entrypoint  
> sftp

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 2223

> Do you want to enable Proxy Protocol for this route? No
#+end_stdout

#+attr_shortcode: :style warning :title Do not enable Proxy Protocol
#+begin_notice
SSH does not support [[https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt][Proxy Protocol]], so be sure to disable it.
#+end_notice


Press =ESC= three times to go back to the main menu, then re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Once re-installed, press =ESC= to exit the config tool.

*** Authorize your client's SSH public key

Copy the contents of your SSH pubkey from your personal workstation to
your clipboard:

#+begin_run
## Your key may be in a different location
cat ~/.ssh/id_ed25519.pub
#+end_run

Authorize the key to access the server:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make sftp ssh-authorize-key
#+end_run

Enter the information at the prompt:

#+begin_stdout
Which SSH username do you want to add a key for? : www
Enter the SSH public key : xxxxxxxxxxxxxxxxxxxxxxxxxxxx
#+end_stdout

 * Enter the SSH username (e.g., =www=.)   
 * Paste the SSH key from your clipboard, then press =Enter=.

If you want to authorize multiple keys, repeat the last step. (If you
want to remove all the authorized keys for a user, run =pi make sftp
ssh-clear-id= and it will prompt for you to enter the username.)

*** Configure your personal workstation as a client

#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host sftp.pi.example.com
    User www
    Port 2223
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

Test connecting:

#+begin_run
sftp sftp.pi.example.com
#+end_run

#+begin_stdout
The authenticity of host '[sftp.pi.example.com]:2223 ([X.X.X.X]:2223)' can't be established.
ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
This key is not known by any other names.

Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
#+end_stdout

If connected successfully, you should see the =sftp>= prompt. Type
=ls= and you should see the =public_html= sub-directory listed:

#+begin_stdout
sftp> ls
public_html
#+end_stdout

Press =Ctrl-D= to quit.

*** Test uploading a new index.html to thttpd volume

Create a temporary test folder on your personal workstation and create
an index.html file:

#+begin_run
cd $(mktemp -d)
echo '&lt;h1&gt;Hello, World!&lt;/h1&gt;' > index.html
#+end_run

Copy the files to the server into the =public_html= folder:

#+begin_run
scp index.html sftp.pi.example.com:public_html/
#+end_run

**** Refresh the website in your browser

The new page should now be public (e.g., =https://www.pi.example.com=):

[[/img/portable-docker/thttpd-hello-world.webp]]

*** Use Rclone to synchronize whole directories to SFTP

Unfortunately, the traditional tool [[https://man.archlinux.org/man/rsync.1][rsync]] only works with SSH, not
SFTP. An alternative tool named [[https://rclone.org/][Rclone]] can be used in place of it.

 * On your personal workstation, install =rclone= via your package
   manager (preferred) or [[https://rclone.org/install/][from the
   official site]].

**** Create rclone config file

#+begin_run
mkdir -p ~/.config/rclone

cat &lt;&lt;EOF &gt;&gt; ~/.config/rclone/rclone.conf
[pi]
type = sftp
host = pi.example.com
user = www
port = 2223
EOF
#+end_run
**** How to use rclone

Read the [[https://rclone.org/docs/][rclone docs]] for comprehensive usage information.

***** List all the remote files

#+begin_run
rclone ls pi:
#+end_run

#+begin_stdout
        2 public_html/.gitignore
       23 public_html/index.html
#+end_stdout

***** Syncronize a local directory to the remote public_html folder

Sync the current directory ( . ):

#+begin_run
## dangerous:
rclone -v sync . pi:public_html/
#+end_run

#+attr_shortcode: :style warning
#+begin_notice
This is a potentially destructive command: it makes the remote
directory /exactly/ like your local directory. *All existing files in
the remote destination directory are deleted if they do not exist
locally*.
#+end_notice

#+attr_shortcode: :style tip
#+begin_notice
It is recommended to create an alias so that you don't fat-finger the
=sync= command. For example, setup your local web root in your home
directory =~/public_html=:

#+begin_run
mkdir -p ~/public_html
#+end_run

Next create this alias in your =~/.bashrc= file:

: alias sync-web="rclone -v sync ~/public_html pi:public_html/"

Then run the alias whenever you want to sync your local website to the
remote public site:

#+begin_run
sync-web
#+end_run
#+end_notice

** MinIO S3 (and Filestash)
:PROPERTIES:
:EXPORT_FILE_NAME: minio-s3
:EXPORT_HUGO_WEIGHT: 7210
:END:

[[https://en.wikipedia.org/wiki/Amazon_S3][S3]] is a storage API first implemented at Amazon AWS, but has since
been copied and re-implemented as open source [[https://github.com/minio/minio][MinIO]]. MinIO is a
service you can install to centrally store files in your network via
the S3 API. With a web frontend like [[https://github.com/mickael-kerjean/filestash][Filestash]], you can host a file
manager webapp for easy file sharing.

[[/img/portable-docker/filestash-window.webp]]

#+attr_shortcode: :style tip
#+begin_notice
Running MinIO on a single Raspberry Pi is perfect for personal use.
However, for heavier production use, you will need to plan to use
beefier hardware with redundant storage.
#+end_notice

*** Configure MinIO


#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
pi make minio config
#+end_run

#+begin_stdout
MINIO_TRAEFIK_HOST: Enter the minio domain name (eg. s3.example.com)
: s3.pi.example.com

MINIO_CONSOLE_TRAEFIK_HOST: Enter the minio console domain name (eg. console.s3.example.com)
: s3-console.pi.example.com

MINIO_SITE_REGION: Enter the self-described region of the server (eg. default)
: default

MINIO_ROOT_USER: Enter the minio root username (eg. root)
: root

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?  
> No
  Yes, with Mutual TLS (mTLS)
#+end_stdout

*** Enable admin console (optional)

The admin console is optional and it is blocked by default. If you
want to access the console, you must unblock it, by providing your
client IP address:

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
## Unblock the console for your specific IP address:
pi make minio reconfigure var=CONSOLE_SOURCERANGE=X.X.X.X/32
#+end_run

#+attr_shortcode: :style tip :title Tip
#+begin_notice
To allow any IP address access to the minio console use =0.0.0.0/0=:

#+attr_shortcode: :style other :title Run this on your Raspberry Pi
#+begin_run
## To unblock the console for any IP address:
pi make minio reconfigure var=CONSOLE_SOURCERANGE=0.0.0.0/0
#+end_run

Once installed, the console will be accessible at
=https://s3-console.pi.example.com=. You will need to enter the
username (=root=) and the password can be retrieved from the
=.env_{CONTEXT}_{INSTANCE}= file:

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
## To retrieve the minio console root password:
pi make minio dotenv_get var=MINIO_ROOT_PASSWORD
#+end_run

#+begin_stdout
XxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXx
#+end_stdout
#+end_notice

*** Install MinIO

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
pi make minio install wait
#+end_run

*** Add two new routes on the sentry (droplet)

Create a route for S3 and the console:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: s3.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint         Destination_address  Destination_port  Proxy_protocol
----------         -------------------  ----------------  --------------
s3.pi.example.com  10.13.16.2           443               2

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: s3-console.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint                 Destination_address  Destination_port  Proxy_protocol
----------                 -------------------  ----------------  --------------
s3.pi.example.com          10.13.16.2           443               2
s3-console.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Create an S3 bucket and credentials

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
pi make minio bucket
#+end_run

Create the bucket name: =demo= and then leave the policy, group, and
username blank to use the same value:

#+begin_stdout
Enter a new bucket name (test): demo
Enter a new policy name (demo): 
Enter a new group name (demo): 
Enter a new user name (demo): 
#+end_stdout

This will create the bucket and the output the endpoint and access
credentials, which is all of the information necessary to provide
access:

#+begin_stdout
Bucket: demo
Endpoint: s3.pi.example.com
Access Key: demo
Secret Key: XxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXx
#+end_stdout

*** Configure Filestash instance

It is likely you will want several instances of filestash for
different buckets, so you you should configure them separately as
named instances:

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
## Create an instance named test:

pi make filestash config instance=test
#+end_run

#+begin_stdout
FILESTASH_TRAEFIK_HOST: Enter the filestash domain name (eg. filestash.example.com)
: filestash-test.pi.example.com

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?  
  No
  Yes, with HTTP Basic Authentication
> Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout

#+attr_shortcode: :style warning :title Warning
#+begin_notice
*sentry authorization is a requirement* as the S3 credentials are
stored in the filestash client (i.e., web browser), therefore you
should not allow anyone you do not trust with this information to
access the page.
#+end_notice


#+begin_stdout
? Which authorization group do you want to permit access to this app?  
> admin
#+end_stdout

#+attr_shortcode: :style tip :title Tip
#+begin_notice
This will allow only the =admin= authorization group to access this
instance.

Remember, you can create [[/portable-docker/install-core-services/traefik-forward-auth/#add-user-groups-for-sentry-authorization][extra authorization groups]] in the Traefik
config, that way you can have separate user access per instance.
#+end_notice

*** Install the Filestash instance

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
## Install the instance named test:

pi make filestash install instance=test
#+end_run

#+attr_shortcode: :style primary :title Info
#+begin_notice
The build process for filestash may take awhile, as it is built from
source code. This is because the [[https://hub.docker.com/r/machines/filestash/][upstream images]] were out of date for
ARM64.
#+end_notice

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: filestash-test.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint                     Destination_address  Destination_port  Proxy_protocol
----------                     -------------------  ----------------  --------------
filestash-test.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Open Filestash

Open the URL in your browser: =https://filestash-test.pi.example.com=.

 * The initial page will ask you to create an admin password.

*** Administer Filestash

The admin page is only accessible from
=https://filestash-test.pi.example.com/admin/=, and it is here you
must configure the storage backend.

 * Click =Backend= in the menu.
 * Remove every backend except for =S3=.
 * Do not select any authentication middleware.
 * Click the icon in the upper left to go to main page, or simply go
   to =https://filestash-test.pi.example.com/=.

On the main page, enter the credentials for the S3 connection:

 * Click =Advanced=
 * Enter the Access key ID
 * Enter the Secret Access Key
 * Enter the Endpoint
 * Leave the other options blank.

[[/img/portable-docker/filestash-connect.webp]]

 * Click =Connect=.

Once logged in you should see a single folder with the same name as
the bucket (=test=):

[[/img/portable-docker/filestash-folder.webp]]

 * Click the Share icon in the top right of the folder container.

[[/img/portable-docker/filestash-share-link.webp]]

 * Choose the appropriate permission for the person you are sharing
   with:

   * =Editor= has full access, download, upload, view, and delete.
   * =Viewer= is read only.
   * =Uploader= is write only (they won't be able to see any files,
     not even the ones they upload.)
   
 * Under =Advanced= settings, you may optionally set an expiration for
   the link, or customize the link URL.
 * Do not set a password, as you can rely upon the sentry
   authorization instead.
 * Copy the link, and share this link with your friends!
 * Try the link yourself in an Incognito browser window so that you
   test it with no existing cookies. It should force you to login
   through Forgejo first, and then once on the filestash page, test
   the permissions you set are working.

#+attr_shortcode: :style tip :title Tip
#+begin_notice
Because you enabled sentry authorization for this route, your friends
will also need to create Forgejo accounts, and you will need to add
them to the [[/portable-docker/install-core-services/traefik-forward-auth/#add-user-groups-for-sentry-authorization][sentry authorization group]] in the Traefik config.
#+end_notice

#+attr_shortcode: :style tip :title Tip
#+begin_notice
Create an admin link for yourself, so that you don't need to enter the
S3 credentials again, and you can create new share links too:

 * Create a new share link like before.
 * Choose =Editor= privilege.
 * Click =Advanced=.
 * Click =Can Reshare=.

[[/img/portable-docker/filestash-share-admin.webp]]
#+end_notice

*** Using filestash

 * You can upload multiple files at a time by draging and dropping
   them directly from your computer's file manager into the browser
   window (FYI the dropzone is only near the top of the page).

 * Many media types are supported with rich viewers, including images,
   audio, and video.

** Homepage
:PROPERTIES:
:EXPORT_FILE_NAME: homepage
:EXPORT_HUGO_WEIGHT: 7300
:END:

[[https://gethomepage.dev/][Homepage]] is a customizable dashboard for all of your self-hosted apps
and services.

[[/img/portable-docker/homepage-dashboard.webp]]

*** Configure Homepage

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
pi make homepage config
#+end_run

You need to configure two sub-domains, one for homepage itself, and
one for its webhooks:

#+begin_stdout
HOMEPAGE_TRAEFIK_HOST: Enter the homepage domain name (eg. homepage.example.com)
: homepage.pi.example.com

HOMEPAGE_WEBHOOK_HOST: Enter the separate webhook domain name (eg. homepage-webhook.example.com)
: homepage-webhook.pi.example.com
#+end_stdout

It is recommended to enable some form of [[/install-core-services/traefik-forward-auth/][sentry authorization]] to
protect homepage, e.g., with OAuth2:

#+begin_stdout
? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?  
  No
  Yes, with HTTP Basic Authentication
> Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)

? Which authorization group do you want to permit access to this app?  
> admin
#+end_stdout

#+attr_shortcode: :style tip :title Tip
#+begin_notice
This will allow only the =admin= authorization group to access this
instance.

Remember, you can create [[/portable-docker/install-core-services/traefik-forward-auth/#add-user-groups-for-sentry-authorization][extra authorization groups]] in the Traefik
config, that way you can have separate user access per instance.
#+end_notice

**** HOMEPAGE_AUTO_CONFIG

Homepage has optional auto configuration:

 * If =HOMEPAGE_AUTO_CONFIG=true=, homepage will create a template
   automatically that will discover all of your existing services.
 * If =HOMEPAGE_AUTO_CONFIG=false=, homepage will clone a default
   template from a git repository, or you may provide your own
   repository via =HOMEPAGE_TEMPLATE_REPO=.

For now, enable the auto-configuration:
 
#+begin_stdout
? Do you want to auto-configure Homepage and to discover all of your
running d.rymcg.tech apps of the current docker context? (Y/n) Yes
#+end_stdout

*** Install Homepage

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make homepage install wait
#+end_run

*** Add two new routes on the sentry (droplet)

You need to create two routes: one for homepage, and one for the
webhooks:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: homepage.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint               Destination_address  Destination_port  Proxy_protocol
----------               -------------------  ----------------  --------------
homepage.pi.example.com  10.13.16.2           443               2

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: homepage-webhooks.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint                       Destination_address  Destination_port  Proxy_protocol
----------                       -------------------  ----------------  --------------
homepage.pi.example.com           10.13.16.2           443               2
homepage-webhooks.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Open Homepage

Open =https://homepage.pi.example.com= in your web browser.

*** Redeploy Homepage after you have installed new services

The Homepage auto-config only happens at install time. If you install
or remove services, you should reinstall homepage to update the
dashboard:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make homepage install
#+end_run

*** Customize Hompepage template
To customize your homepage template, you must set
=HOMEPAGE_AUTO_CONFIG=false= and provide =HOMEPAGE_TEMPLATE_REPO= in
the =.env_{CONTEXT}_{INSTANCE}= file:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make homepage reconfigure \
  var=HOMEPAGE_TEMPLATE_REPO=https://github.com/EnigmaCurry/d.rymcg.tech_homepage-template.git

pi make homepage reconfigure \
  var=HOMEPAGE_AUTO_CONFIG=false
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
You can [[https://github.com/EnigmaCurry/d.rymcg.tech_homepage-template][fork the default template repository]] and provide your own
=HOMEPAGE_TEMPLATE_REPO= and it will automatically pull the
template from your URL.

If your template repository is not public, you must create a deploy key:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make homepage git-deploy-key
#+end_run

This will generate and save a new SSH key in the config volume
(=/app/config/ssh/id_rsa=). It will print out the public key, which
you need to copy and paste into your Forgejo, Github, or Gitlab
repository settings (Search for Deploy Key in the settings, and add
this public key to allow cloning from the private repository.)

[[/img/portable-docker/github-deploy-key.webp]]
#+end_notice

*** Reloading webhook

An optional feature when using a custom template repository
(=HOMEPAGE_TEMPLATE_REPO=) is you can send a webhook from your git
forge to your homepage instance, telling it to restart and pull the
changes automatically.

First you must enable =HOMEPAGE_TEMPLATE_REPO_SYNC_ON_START=true= in
the homepage =.env_{CONTEXT}_{INSTANCE}= file. Note that this setting
will delete your existing config everytime homepage restarts, and it
will redownload the template repository from scratch:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make homepage reconfigure \
  var=HOMEPAGE_TEMPLATE_REPO_SYNC_ON_START=true
#+end_run

Next you must configure your Forgejo, Github, or Gitlab repository to
send the webhook on =git push= events:

 * Webhook URL is of the format: https://homepage.example.com/reloader/restart
 * Choose the data type: =application/json=
 * Webhook Secret is found in your =.env_{INSTANCE}_{CONTEXT}= as
   =HOMEPAGE_RELOADER_HMAC_SECRET=. This secret is used to validate that
   the request is actually coming from your git host.

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make homepage dotenv_get \
  var=HOMEPAGE_RELOADER_HMAC_SECRET
#+end_run

#+begin_stdout
xXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxX
#+end_stdout

 * No extra authorization header is required.

[[/img/portable-docker/github-webhook.webp]]

Finally, redeploy homepage:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make homepage install
#+end_run

** Yourls
:PROPERTIES:
:EXPORT_FILE_NAME: yourls
:EXPORT_HUGO_WEIGHT: 7400
:END:

[[https://yourls.org/][Yourls]] is a URL shortener.

*** Configure Yourls

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make yourls config
#+end_run

Follow the prompts to configure the domain name and admin user
authentication.

#+begin_stdout
YOURLS_TRAEFIK_HOST: Enter the YOURLS domain name (e.g., yourls.example.com)
: yourls.pi.example.com

? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)

YOURLS_USER: Enter the admin username for your YOURLS instance
: admin
YOURLS_PASS: Enter the password for 'admin'
: 528e0e36fc170 
#+end_stdout

Choose your own a secure passphrase!

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make yourls install wait
#+end_run

Wait for the services to start and report themselves as healthy:

#+begin_stdout
Waiting until all services are started and become healthy ...
All services healthy.
#+end_stdout

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: yourls.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint              Destination_address  Destination_port  Proxy_protocol
----------              -------------------  ----------------  --------------
yourls.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Finish

#+attr_shortcode: :title Immediately secure the admin account :style warning
#+begin_notice
You should immediately open the URL in your web browser:
=https://yourls.pi.example.com/admin= and complete the initial
configuration to finsh installation.

There is no page at the root URL (Forbidden.) To administer the site,
you must go to the page =https://yourls.pi.example.com/admin=.
#+end_notice
** Nginx and PHP
:PROPERTIES:
:EXPORT_FILE_NAME: nginx-and-php
:EXPORT_HUGO_WEIGHT: 7500
:END:

d.rymcg.tech ships with a traditional [[https://www.php.net/][PHP]] webstack, including [[https://github.com/nginx/nginx][Nginx]]
proxy, with [[https://www.postgresql.org/][PostgreSQL]] database and [[https://github.com/redis/redis][Redis]] session store. These extra
features can all be turned off, turning Nginx into a simple static
file server instead.

*** Configure Nginx

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
pi make nginx config
#+end_run

Make sure you choose a unique domain for this service (=www= is also
the default for =thttpd=, so if you installed that too, just make sure
this is unique:)

#+begin_stdout
NGINX_TRAEFIK_HOST: Enter the nginx domain name (eg. www.example.com)
: nginx.pi.example.com
#+end_stdout

Choose the optional features you want to enable: =postgres=, =php-fpm=:

#+begin_stdout
? Choose the docker-compose profiles to enable:  
  [x] nginx - Base Nginx config (don't unselect this, it is required)
  [x] postgres - PostgreSQL database
> [x] php-fpm - PHP script support + Redis session store
#+end_stdout

Choose one of the default PHP apps to install:

#+begin_stdout
? Choose the index PHP file to install  
  default.php
> phpinfo.php
  https://github.com/adminerevo/adminerevo/releases/download/v4.8.3/adminer-4.8.3.php
#+end_stdout

Turn on one of the sentry authorization options to protect your
instance:

#+begin_stdout
? Do you want to enable sentry authorization in front of this app (effectively making the entire site private)?  
  No
  Yes, with HTTP Basic Authentication
> Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)

? Which authorization group do you want to permit access to this app?  
> admin
#+end_stdout

#+attr_shortcode: :style tip :title Tip
#+begin_notice
This will allow only the =admin= authorization group to access this
instance.

Remember, you can create [[/portable-docker/install-core-services/traefik-forward-auth/#add-user-groups-for-sentry-authorization][extra authorization groups]] in the Traefik
config, that way you can have separate user access per instance.
#+end_notice

*** Install Nginx

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make nginx install wait
#+end_run

*** Add a new route on the sentry (droplet)

You need to create two routes: one for homepage, and one for the
webhooks:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: nginx.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint            Destination_address  Destination_port  Proxy_protocol
----------            -------------------  ----------------  --------------
nginx.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Open Nginx webpage

Open =https://nginx.pi.example.com= in your web browser.

*** Upload site files with SFTP

Manage the Nginx volume (=nginx_files=) with [[/portable-docker/install-web-services/sftp/][SFTP]] (the same way as
with =thttpd=), and you can use this as a simple way to publish your
websites.

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make sftp config
#+end_run

#+begin_stdout
SFTP_PORT: Enter the public SSH port (eg. 2223)
: 2223

SFTP_USERS: Enter the user:uid list (eg. ryan:1000,gary:1001)
: www:54321

SFTP_VOLUMES: Enter the volume:user:mount list (can be blank)
: nginx_files:www:nginx
#+end_stdout

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make sftp install
#+end_run

Authorize your SSH key:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make sftp ssh-authorize-key
#+end_run

 * Enter the username =nginx=
 * Enter the SSH public key (copy this from your local
   =~/.ssh/id_ed25519.pub=)

*** Create counters demo app

Let's create a demo PHP script that shows how to connect to the
PostgreSQL database and make a web page hit counter:

Create a new project directory on your personal workstation:

#+begin_run
mkdir -p ~/php-demo
#+end_run

#+begin_run
cat &lt;&lt;'EOF' > ~/php-demo/counter.php
&lt;?php
// Load environment variables using the standard PostgreSQL environment variable names
$host = getenv('PGHOST') ?: 'localhost'; // Default to localhost if PGHOST is not set
$dbname = getenv('PGDATABASE') ?: 'your_default_database';
$user = getenv('PGUSER') ?: 'your_default_user';
$password = getenv('PGPASSWORD') ?: 'your_default_password';
$port = getenv('PGPORT') ?: '5432'; // Default to port 5432 if PGPORT is not set

// Check if all the necessary environment variables are set
if (!$host || !$dbname || !$user || !$password || !$port) {
    die('Missing required PostgreSQL environment variables.');
}

// Establish a connection to the PostgreSQL database
try {
    $dsn = "pgsql:host=$host;port=$port;dbname=$dbname";
    $pdo = new PDO($dsn, $user, $password, [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]);
} catch (PDOException $e) {
    die('Connection failed: ' . $e->getMessage());
}

// Function to check if the table exists
function checkTableExists($pdo, $tableName) {
    $query = $pdo->prepare("SELECT to_regclass(:table_name) AS exists");
    $query->execute(['table_name' => $tableName]);
    $result = $query->fetch(PDO::FETCH_ASSOC);
    return $result['exists'] !== null;
}

// Create the table if it does not exist
if (!checkTableExists($pdo, 'page_counters')) {
    $createTableQuery = "
    CREATE TABLE page_counters (
        id SERIAL PRIMARY KEY,
        counter_name VARCHAR(255) UNIQUE NOT NULL,
        count BIGINT DEFAULT 0
    );
    ";
    $pdo->exec($createTableQuery);
}

// Determine the counter name from the query string, defaulting to 'default'
$counterName = isset($_GET['counter']) ? $_GET['counter'] : 'default';

// Check if the counter exists in the database
$stmt = $pdo->prepare("SELECT count FROM page_counters WHERE counter_name = :counter_name");
$stmt->execute(['counter_name' => $counterName]);
$counter = $stmt->fetch(PDO::FETCH_ASSOC);

if ($counter) {
    // If the counter exists, increment it
    $newCount = $counter['count'] + 1;
    $updateStmt = $pdo->prepare("UPDATE page_counters SET count = :count WHERE counter_name = :counter_name");
    $updateStmt->execute(['count' => $newCount, 'counter_name' => $counterName]);
} else {
    // If the counter does not exist, create it with a value of 1
    $newCount = 1;
    $insertStmt = $pdo->prepare("INSERT INTO page_counters (counter_name, count) VALUES (:counter_name, :count)");
    $insertStmt->execute(['counter_name' => $counterName, 'count' => $newCount]);
}

// Output the current counter value
echo "Counter '$counterName': $newCount";
EOF
#+end_run

#+begin_run
scp ~/php-demo/counter.php sftp.pi.example.com:nginx/public/
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
Instead of =scp=, you can follow the same instructions as for [[/portable-docker/install-web-services/sftp/#use-rclone-to-synchronize-whole-directories-to-sftp][Thttpd]],
and setup Rclone with an easy to use =sync-web= alias for
synchronizing your web files.
#+end_notice

*** Visit counter page

Try these URLs in your browser (replacing your root domain):

 * =https://nginx.pi.example.com/counter.php=
 * =https://nginx.pi.example.com/counter.php?counter=two=

Refresh each one multiple times and watch the counter grow.

[[/img/portable-docker/php-counter.webp]]

** Jupyterlab
:PROPERTIES:
:EXPORT_FILE_NAME: jupyterlab
:EXPORT_HUGO_WEIGHT: 7600
:END:

[[https://jupyter.org/][JupyterLab]] is an interactive programming notebook which lets you write
and test code in a persistent web browser environment. Notebooks are
useful for simple experiments, reproducible research, and easy sharing
and collaboration.

[[/img/portable-docker/jupyterlab-notebook.webp]]

*** Configure Jupyterlab

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
pi make jupyterlab config
#+end_run

#+begin_stdout
#+end_stdout

#+begin_stdout
#+end_stdout

*** Install Jupyterlab

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
pi make jupyterlab install wait
#+end_run

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sentry make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: jupyterlab.pi.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint                 Destination_address  Destination_port  Proxy_protocol
----------                 -------------------  ----------------  --------------
jupyterlab.pi.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Retrieve the login token

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
pi make jupyterlab token
#+end_run

Copy the token that is output to your clipboard:

#+begin_stdout
xXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxX
#+end_stdout

*** Open Jupyterlab

Open =https://jupyterlab.pi.example.com= in your web browser. Paste
the login token, and optionally set a new password.

* Maintainence
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: maintainence
:EXPORT_HUGO_WEIGHT: 9000
:END:
** Maintainence
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 9001
:END:

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

** Backup
:PROPERTIES:
:EXPORT_FILE_NAME: backup
:EXPORT_HUGO_WEIGHT: 9002
:END:

TODO

** Upgrade
:PROPERTIES:
:EXPORT_FILE_NAME: upgrade
:EXPORT_HUGO_WEIGHT: 9003
:END:

*** Upgrade Raspberry Pi OS

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
sudo apt update
sudo apt full-upgrade
sudo reboot
#+end_run

*** Upgrade container images

Each application is configured via its own =.env_{CONTEXT}_{INSTANCE}=
file in the project folder of each app.

The version of the app is usually controlled via an environment
variable named =PROJECT_IMAGE= or =PROJECT_VERSION=. For some apps,
this will be labeled as =latest= so that it always installs the latest
version, while others are locked to a specific know working version.
The =d.rymcg.tech= authors will update the =.env-dist= file
automatically, but you must still update this in your own
=.env_{CONTEXT}_{INSTANCE}= config files.

You can edit the .env file for any app instance:

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
## Immich is just an example app:
pi make immich config-edit instance=default
#+end_run

This will open the config file in the default editor (=nano=), find
the appropriate environment variable that affects the version of the
application (usually there's a comment or URL to go to), edit it so
that it points to the latest version, and save the file.

You must reinstall the application to install the new version:

#+begin_run
## Immich is just an example app:
pi make immich install
#+end_run

*** Upgrade sentry

The sentry should also be upgraded from time to time:

 * Update the Traefik version.
 * Update the WireGuard version.

#+attr_shortcode: :style secondary :title Run this on your Raspberry Pi
#+begin_run
sentry make traefik config-edit
#+end_run
** Troubleshooting
:PROPERTIES:
:EXPORT_FILE_NAME: troubleshooting
:EXPORT_HUGO_WEIGHT: 9004
:END:
*** Monitor kernel logs

During the first day or so of setting this machine up, it is
recommended to actively monitor the kernel logs, checking for errors.

#+begin_run
## Just leave this running in a separate terminal as you keep working..
sudo dmesg -w
#+end_run

**** Disable power saving on NVME storage

#+attr_shortcode: :style info :title How to disable power saving on the NVME drive
#+begin_notice
Out of two identical kits, I encountered one error in the kernel log
on one machine but not on the other, so you may or may not run into
this error:

#+begin_stdout
[  359.477209] nvme nvme0: controller is down; will reset: CSTS=0xffffffff, PCI_STATUS=0x11
[  359.477218] nvme nvme0: Does your device have a faulty power saving mode enabled?
[  359.477220] nvme nvme0: Try "nvme_core.default_ps_max_latency_us=0 pcie_aspm=off" and report a bug
[  359.545210] nvme 0000:01:00.0: enabling device (0000 -> 0002)
[  359.549032] nvme nvme0: Shutdown timeout set to 10 seconds
[  359.722783] nvme nvme0: 4/0/0 default/read/poll queues
#+end_stdout

This error seems to indicate there is a faulty power saving feature in hardware or in
the NVME firmware or kernel code. It may be fixed by following the advice
to turn off the power saving feature of the NVME:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sudo nano /boot/firmware/cmdline.txt
#+end_run

This file should contain a single long line of text. You should find
the very end of the line, and add the following to the end of it:

: nvme_core.default_ps_max_latency_us=0 pcie_aspm=off

The whole line should now look like:

: console=serial0,115200 console=tty1 root=PARTUUID=xxxxxxxx-02 rootfstype=ext4 fsck.repair=yes rootwait cfg80211.ieee80211_regdom=US   nvme_core.default_ps_max_latency_us=0 pcie_aspm=off

Press =Ctrl+S= to save the file. Press =Ctrl+X= to quit =nano=.

Reboot the pi:

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
sudo reboot
#+end_run

Check to see if the error goes away, but if not, you probably have a
hardware issue.
#+end_notice

