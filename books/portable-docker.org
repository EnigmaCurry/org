#+hugo_base_dir: ../hugo
#+hugo_section: /portable-docker
#+hugo_weight: auto
#+hugo_paired_shortcodes: %notice badge button %children %index run stdout edit math mermaid openapi toc env
#+STARTUP: align

* Portable Docker: Build and Deploy Anywhere with WireGuard Tunneling
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :linkTitle Portable Docker
:EXPORT_HUGO_WEIGHT: 3000
:END:

[[/img/portable-docker/treasure.webp]]

This book serves as your guide to installing Docker on a small,
portable Linux device (eg. Raspberry Pi), and deploying some web
service containers on it, using Traefik. You'll also create and
configure a public cloud server (eg. DigitalOcean droplet), whose sole
purpose is to host a VPN (WireGuard) and public gateway (Traefik),
enabling the Raspberry Pi to securely connect from any location.

Through the encrypted tunnel established by this connection, the Pi
can publish services to the internet, even when operating behind a
restrictive firewall, such as public WiFi, mobile hotspots, and
carrier-grade NAT. As long as you can get unblocked /outgoing/
internet access, you can self-host a roaming public server from
anywhere!

#+attr_shortcode: :icon code-branch :style primary :href https://github.com/EnigmaCurry/d.rymcg.tech#readme
#+begin_button
d.rymcg.tech
#+end_button

#+attr_shortcode: :icon comment-dots :style red :href https://matrix.to/#/#d.rymcg.tech:enigmacurry.com
#+begin_button
Chat with us on Matrix
#+end_button

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: introduction
:EXPORT_HUGO_WEIGHT: 100
:END:

[[/img/portable-docker/pi5-assembled.webp]]

* Setup DNS
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: setup-dns
:EXPORT_HUGO_WEIGHT: 150
:END:
** Setup DNS
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 151
:END:

Before you can configure any hardware, you need to setup the domain
name service of your own domain.

#+begin_index
index
#+end_index

** Register a domain name
:PROPERTIES:
:EXPORT_FILE_NAME: register-domain
:EXPORT_HUGO_WEIGHT: 160
:END:

To host a web service, one of the first things you will need is to
register your domain name. This will be the domain name used for all
of your service links, and it is what your users will need to type
into their browsers (or click on) to visit your pages.

Public domain names are a scarce resource. Because of their scarcity,
you must pay for your domain registrations, doing so in 1 year
increments. If domain names were free, all the good ones would be
taken by now, but because they cost money, there are still some good
enough ones left to be had. In return for your fee, you receive
exclusive use of the domain name for the period that you paid for. You
"own" the domain name, and its configuration, but you need to keep
paying a registrar to keep the record active (so its more like
renting). You can pre-pay for several years in advance, or just pay
for one year at a time. If you stop paying, and the records expire,
they will no longer resolve to your services, and you may lose control
of the domain, possibly forever.

*** Register an Internet domain name

You can buy (rent) a domain name from lots of places. For
documentation purposes, we will use [[https://www.gandi.net][Gandi.net]], but these instructions
will be similar regardless of the domain provider you pick.

#+attr_shortcode: :style info :title Setup on Gandi.net
#+begin_notice
 * Sign up for an account at [[https://www.gandi.net/][Gandi.net]]
 * Once signed in, from your dashboard, click =Register=.
 * Search for any domain name you like, eg. =your-name.com=.
 * Add your domain to the shopping cart, go to checkout, and complete
   your purchase.
 * Once you have purchased the domain, it should show up in your
   =Dashboard=, under the =Domain= tab.
 * Leave this browser tab open, you will return to it in the next
   chapter.
#+end_notice

*** Transfer DNS to DigitalOcean

#+attr_shortcode: :style secondary :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].
#+end_notice

#+attr_shortcode: :style info :title Setup on Gandi.net
#+begin_notice

 * Login to your [[https://admin.gandi.net][gandi.net]] dashboard.
 * Click the =Domain= tab.
 * Find your domain name in the list and click on it.
 * Click on the =Nameservers= tab.
 * Click on the edit button to create new =External nameservers=.
 * Delete all existing nameservers that may exist.
 * Add the following nameservers, specific to DigitalOcean:
   
   * =ns1.digitalocean.com=
   * =ns2.digitalocean.com=
   * =ns3.digitalocean.com=
#+end_notice

Wait a few minutes for the change to take effect, then you can verify
the setting from your workstation, using the =whois= command:

#+begin_run
whois example.com
#+end_run

#+begin_stdout
Domain Name: example.com
Registrar WHOIS Server: whois.gandi.net
Name Server: ns1.digitalocean.com
Name Server: ns2.digitalocean.com
Name Server: ns3.digitalocean.com
#+end_stdout

The output shows a report for your domain registration, including the
list of the new nameservers.

** Add domain to DigitalOcean DNS
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token
:EXPORT_HUGO_WEIGHT: 161
:END:

The [[https://www.rfc-editor.org/rfc/rfc1035][Domain Name System]] is how you can associate one of your
sub-domains with an actual IP address on the internet.

#+attr_shortcode: :style secondary :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].

Sign up for a [[https://m.do.co/c/d827a13964d7][DigitalOcean account]] (using this referral link helps
support this site), and follow along to setup your domain's DNS.
#+end_notice

*** Add your domain name

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =Networking= in the left hand menu.
 * Select the =Domains= tab.
 * Enter your domain name, and click =Add Domain=.

Wait a few minutes for the setting to take effect, then you can verify
the domain name is added:

#+begin_run
# install dig from bind-utils package.
dig -t ns example.com
#+end_run

(if you don't have =dig= installed, you can also use [[https://toolbox.googleapps.com/apps/dig/][the web version
provided by google]], enter the domain name, and select =NS=.)

#+begin_stdout
;; ANSWER SECTION:
example.com.             2400    IN      NS      ns1.digitalocean.com.
example.com.             2400    IN      NS      ns3.digitalocean.com.
example.com.             2400    IN      NS      ns2.digitalocean.com.
#+end_stdout

** Generate DigitalOcean API token for ACME challenge
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token-for-acme-challenge
:EXPORT_HUGO_WEIGHT: 255
:END:
#+attr_shortcode: :style secondary :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].
#+end_notice

DNS is also a part of the TLS certificate request process (ACME DNS-01
challenge). You will need to procure a DigitalOcean Personal Access
Token, which is used for programatic control of your DigitalOcean
account's DNS settings on your behalf:

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =API= in the left hand menu, near the bottom of the list.
 * On the =Tokens= tab, click =Generate New Token=.
 * Enter a descriptive name indicating the owner of the token (eg. a
   subdomain), and its purpose (eg. ACME): =pi5.example.com ACME=.
 * Set the expiration period you want to use. Use =No expire= if you
   just want to set it and forget it, otherwise you will need to
   update the token periodically.
 * Select =Custom Scopes= so you can choose the fine-grained
   permissions.
 * The only permission that needs to be selected is =domain= (you may
   also choose finer grained permissions of =update=, =read=, and
   =create=, but not =delete=).
 * Click =Generate Token=.
 * Copy the generated token to a temporary buffer/notepad. You will
   need to reference this token in the next section, when it asks for
   the =DO_AUTH_TOKEN= variable.

* Setup Raspberry Pi
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: setup-raspberry-pi
:EXPORT_HUGO_WEIGHT: 200
:END:
** Setup Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 201
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Build your Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: build-your-pi
:EXPORT_HUGO_WEIGHT: 210
:END:

These are the parts you will need to source for this build:

#+attr_shortcode: :title Raspberry Pi 5 motherboard
#+begin_notice
[[/img/portable-docker/pi5.webp]]
#+end_notice
The Raspberry Pi 5 is often sold in kits, but you can also buy the
motherboard separately. If buying a pre-made kit, make sure it
includes an NVME shield to plug in an NVME SSD. Otherwise, this can be
purchased separately:

#+attr_shortcode: :title Geeekpi case, heatsink, NVME shield, and power supply
#+begin_notice
[[/img/portable-docker/geeekpi5case.webp]]
#+end_notice
This kit comes with the NVME shield, which is the adapter to install
on top of the Raspberry Pi 5 motherboard. This allows you to plug in a
full size NVME SSD. The metal case fits the extended height neccessary
to fit the NVME shield and SSD. The kit also includes the required
heatsink and power supply.

#+attr_shortcode: :title Sandisk SD card (32GB)
#+begin_notice
[[/img/portable-docker/sandisk-32GB-sdcard.webp]]
#+end_notice

The SD card is used as the root filesystem for Raspbian. It doesn't
need to be very big, as you won't be storing very much data on this.
Booting from the SD-card is slower than NVME, but the advantage of it
is that you can simply swap SD-cards to temporarily use the pi for a
different purpose, without disrupting access to your NVME storage.

#+attr_shortcode: :title Samsung 990EVO NVME SSD
#+begin_notice
[[/img/portable-docker/samsung-990EVO-NVME.webp]]
#+end_notice

The NVME SSD is much faster, and far more reliable, than the SD card.
This storage will be used exclusively for the Docker storage system
(mounted at =/var/lib/docker=). This is where all of your container
images and data will live.

*** Putting everything together

 * Read the directions that come with the case.
 * Install the heatsink to the Pi 5 motherboard first.
 * Install the motherboard into the bottom part of the case.
 * Install the NVME shield on top of the Pi motherboard. The hat plugs
   into the GPIO pins of the motherboard, and risers sandwich things
   together.
 * Install the NVME into the NVME shield.
 * Screw on the top part of the case.
 * Install the SD-card into the slot on the bottom edge.

#+attr_shortcode: :title Pi 5 installed on risers inside Geeekpi case, NVME shield installed on top
#+begin_notice
[[/img/portable-docker/pi5-profile.webp]]
#+end_notice

#+attr_shortcode: :title NVME SSD installed in the NVME shield
#+begin_notice
[[/img/portable-docker/pi5-nvme.webp]]
#+end_notice

#+attr_shortcode: :title SD-card installed
#+begin_notice
[[/img/portable-docker/pi5-sdcard.webp]]
#+end_notice

#+attr_shortcode: :title The fully assembled Raspberry Pi 5
#+begin_notice
[[/img/portable-docker/pi5-assembled.webp]]
#+end_notice

** Install Raspbian
:PROPERTIES:
:EXPORT_FILE_NAME: install-raspbian
:EXPORT_HUGO_WEIGHT: 220
:END:

The best way to install Raspbian onto an SD-card, is to use the
[[https://www.raspberrypi.com/documentation/computers/getting-started.html][rpi-imager program]] from another computer. This allows you to setup the
user account, network settings, and SSH credentials all from the
imager software.

 * [[https://www.raspberrypi.com/software/][Download the Raspberry PI
   Imager]] or install
   =rpi-imager= from your package manager.
 * Run =rpi-imager=.
 * Click on the menu labled =Rasperry Pi Device=.
   * Choose your model of raspberry pi.
   
 * Click on the menu labeled =Operating System=
   * Choose =Raspberry PI OS (other)=
   * Choose =Raspberry PI OS Lite (64-bit)=.
   
 * Click on the menu labeled =Storage=.
   * Choose the Storage device to install to.
   * You may need to change the ownership of the device (eg. I had to
     do =sudo chown ryan /dev/sdb= first).
     
 * Click =Next=.
 
 * Click =Edit Settings=.
 
   * On the =General= tab:
   
     * Enter the hostname
     * Enter a username and password (This book uses the username
       =pi=).
     * Optionally setup the Wifi (I just use ethernet instead).
     * Set locale settings. I set mine to UTC.
     
   * On the =Services= tab:
   
     * Click =Enable SSH=
     * Choose =Allow pulbic-key authentication only=
     * Paste the list of your SSH public keys into the box. (Find them
       on your workstation by running =ssh-add -L= or look in
       =~/.ssh/*.pub=)
       
   * On the =Options= tab:
   
     * Unselect =Enable telemetry= unless you're into that sort of
       thing.
       
 * Click =Yes= to the question =Would you like to apply OS custom settings=.
 
 * Confirm you would like to write to the SD-card and wait for it to complete.
 
 * Once complete, unplug the SD-card, put it into the raspberry pi,
   plug in the ethernet, and power it on.

*** Setup Log2Ram

You can increase the expected lifespan of your SD card by installing
[[https://github.com/azlux/log2ram#log2ram][log2ram]]

** Setup networking
:PROPERTIES:
:EXPORT_FILE_NAME: setup-networking
:EXPORT_HUGO_WEIGHT: 230
:END:

*** WiFi

You may have already configured the WiFi in the rpi-imager options,
but if not, you can do so after its been installed.

SSH into the pi, and then run:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo raspi-config
#+end_run

 * Enter =System Options=.
 * Enter =S1 Wireless LAN=.
 * Choose your current country.
 * Enter the SSID (WiFi network name) you wish to connect to.
 * Enter the network passphrase

*** Configure DNS

By default, DNS is handled via DHCP, which will probably work in the
majority of cases. However, you may wish to hardcode specific DNS servers instead:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo -e "nameserver 1.1.1.1" | sudo tee /etc/resolv.conf
sudo chattr +i /etc/resolv.conf
#+end_run

=chattr +i= prevents DHCP from overwriting this file in the future.

** Setup SSH
:PROPERTIES:
:EXPORT_FILE_NAME: setup-ssh
:EXPORT_HUGO_WEIGHT: 231
:END:

The Docker context is controlled exclusively through SSH, as the
=root= user. This requires setting up some keys to allow the =pi= user
to access the =root= user's account.

Although you will not need to interact with the =root= user's shell
directly, the =pi= user will be granted full access to =root= via SSH.

#+attr_shortcode: :style warning :title Docker == root == pi
#+begin_notice
SSH is used here almost like =sudo=. The =pi= user should be treated
with the same respect as the =root= user, as it will be granted full
=root= access through SSH (to localhost).
#+end_notice

*** Create a new SSH key

You need to create a new SSH key for the =pi= user.

#+attr_shortcode: :style warning :title Unencrypted SSH keys are used for convenience
#+begin_notice
To connect to the Docker context requires that your SSH key be already
/decrypted/.

There's only two ways to do that:

 * Create an /unencrypted/ SSH key, so that no passphrase is ever
    required.
 -or-
 * Setup an ssh-agent to decrypt and load the unencrypted key into
    resident memory, so that your key can be used without requiring a
    passphrase.

For the sake of convenience, this guide will use the first method, and
create a new /unencrypted/ SSH key, living in the pi user's home
directory: =/home/pi/.ssh/id_ed25519=. The security of this key
depends upon the physical and network security of the device
(including SD-card). Any user gaining entry to the =pi= user's account
will have access to the key, and no passphrase is required to use the
key.

If you wish to enhance the security of your SSH key, please read the
[[https://wiki.archlinux.org/title/SSH_keys][Arch Wiki article on SSH keys]], which covers generating secure SSH
keys, setting a passphrase, and setting up an ssh-agent with [[https://wiki.archlinux.org/title/SSH_keys#Keychain][Keychain]].
#+end_notice

Create a new SSH key (without a passphrase):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519
#+end_run

*** Authorize the key of the pi user to connect as root

All interaction with Docker is done over SSH as the =root= user, so
for the =pi= user to control Docker, they need to be able to SSH to
=localhost= as the =root= user.

Add the =pi= user's key to the root user's
=/root/.ssh.authorized_keys= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat ~/.ssh/id_ed25519.pub | sudo tee -a /root/.ssh/authorized_keys
#+end_run

Create a config named =pi= in your =~/.ssh/config=:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host pi
    User root
    Hostname localhost
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

Test the connection is working:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh pi whoami
#+end_run

Accept the key fingerprint it offers:

#+begin_stdout
The authenticity of host 'localhost (::1)' can't be established.
ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
#+end_stdout

If it worked, you should see the output of =whoami= which should print
the username =root= (which is the user configured by SSH).


** Install Docker
:PROPERTIES:
:EXPORT_FILE_NAME: install-docker
:EXPORT_HUGO_WEIGHT: 240
:END:
*** Install Docker

 * On the pi, install docker:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run   
curl -sSL https://get.docker.com | sh
#+end_run

 * Test docker is working: 

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo docker run hello-world
#+end_run

  * If working, you should see a =Hello from Docker!= message and some other help info.

*** Setup Docker context (SSH)

[[https://github.com/enigmacurry/d.rymcg.tech][d.rymcg.tech]] requires the use of a [[https://docs.docker.com/engine/manage-resources/contexts/][Docker context]] via SSH, rather than
the default socket context.

Create a new docker context, named =pi=, using the SSH config you had
just created (also called =pi=):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context create pi --docker "host=ssh://pi"
#+end_run

Switch to use the new SSH context as the default:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context use pi
#+end_run

Now, when you run any docker command, it will use the SSH context:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker info | grep -iE "(Name|Context)"
#+end_run

This should print the proper context: =pi=.

If it worked, the =pi= user is now fully equipped to run any docker comamnd as =root=.

** Install d.rymcg.tech
:PROPERTIES:
:EXPORT_FILE_NAME: install-d-rymcg-tech
:EXPORT_HUGO_WEIGHT: 250
:END:

*** Install dependencies

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo apt-get install bash build-essential gettext \
     git openssl apache2-utils xdg-utils jq sshfs \
     wireguard curl inotify-tools w3m
#+end_run

*** Clone the git repository

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
git clone https://github.com/EnigmaCurry/d.rymcg.tech.git \
    ${HOME}/git/vendor/enigmacurry/d.rymcg.tech

cd ${HOME}/git/vendor/enigmacurry/d.rymcg.tech
#+end_run

*** Run the main config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
## Run this in the root source directory of d.rymcg.tech:
make config
#+end_run

*** Follow the interactive prompts to finish configuration

**** Install script-wizard
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_stdout
This utility can automatically install a required helper tool called script-wizard.
See https://github.com/enigmacurry/script-wizard

Do you wish to automatically install script-wizard into `_scripts/script-wizard`? (Y/n): y
#+end_stdout

[[https://github.com/EnigmaCurry/script-wizard][script-wizard]] is required dependency that can be downloaded and
installed automatically. =script-wizard= makes interactive input and
selection wizards in Bash a lot nicer.

**** Acknowledge the detected Docker context
#+begin_stdout
? This will make a configuration for the current docker context (pi). Proceed? (Y/n)  y
#+end_stdout

**** Choose the root domain name for this server

#+begin_stdout
ROOT_DOMAIN: Enter the root domain for this context (eg. d.example.com)
: d.example.com
#+end_stdout

Instead of =d.example.com= you should type the actual domain name (or
subdomain name) that you want to use as the root domain for all of
your services on this server.

For example, if you entered =example.com=, you will later install apps
(eg. =whoami=) with subdomains like =whoami.example.com=. Choosing a
deeper subdomain has the benefit of being able to share a single root
domain name amongst several Docker instances, therefore with the
example of =d.example.com= the service would be deployed like
=whoami.d.example.com=, and a second Docker instance could use
=d2.example.com=, with services like =whoami.d2.example.com=.

**** Choose to save generated passwords.json files by default
#+begin_stdout
Every time you configure HTTP Basic Authentication, you are asked if you wish to save the cleartext passwords
into passwords.json (in each project directory). If you were to press Enter without answering the question,
the default answer is No (displayed as y/N). You may change the default response to Yes (displayed as Y/n).
? Do you want to save cleartext passwords in passwords.json by default? (y/N)  y
#+end_stdout

This question is in regards to the integrated HTTP Basic Auth setting,
which allows you to store the plain text credentials in the file named
=passwords.json= in the various project directories. This is a
convenience feature, but you may not want it. Its not really a
security concern, because the same password is also availalbe in the
.env file for the project anyway, so go ahead an enable it.

*** Configure Bash shell integration

Configure the =pi= user's =~/.bashrc= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;'EOF' &gt&gt ~/.bashrc
export PATH=${PATH}:${HOME}/git/vendor/enigmacurry/d.rymcg.tech/_scripts/user
eval "$(d.rymcg.tech completion bash)"
__d.rymcg.tech_cli_alias d
EOF
#+end_run

Once finished, logout and log back in.

Now you have a new alias named =d= that controls =d.rymcg.tech=. Check
out the main help screen:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d
#+end_run

#+begin_stdout
## Main d.rymcg.tech sub-commands - Optional arguments are printed in brackets [OPTIONAL_ARG]
cd [SUBDIR]                   Enter a sub-shell and go to the ROOT_DIR directory (or given subdirectory)
make [PROJECT] [ARGS ...]     Run a `make` command for the given d.rymcg.tech project name
context                       View or set the current Docker context
new-context                   Create a new Docker context
tmp-context                   Use a temporary Docker context in a sub-shell
ssh [COMMAND ...]             Run command or shell on active docker context SSH host
completion                    Setup TAB completion in your shell
install                       Install an app interactively
install-docker                Install Docker Engine on the host
status                        Show status of all installed services
audit                         Print security audit of running containers

## Documentation sub-commands:
help                          Show this help screen
list                          List available d.rymcg.tech projects
                              (not including external projects, unless you symlink them into ROOT_DIR)
readme                        Open the main d.rymcg.tech README.md in your browser
readme [PROJECT]              Open the README.md for the given project name
readme digitalocean           Open root documentation file: DIGITALOCEAN.md
readme security               Open root documentation file: SECURITY.md
readme aws                    Open root documentation file: AWS.md
readme license                Open root documentation file: LICENSE.txt
readme raspberry_pi           Open root documentation file: RASPBERRY_PI.md
readme makefile_ops           Open root documentation file: MAKEFILE_OPS.md
#+end_stdout

** Install Traefik
:PROPERTIES:
:EXPORT_FILE_NAME: install-traefik
:EXPORT_HUGO_WEIGHT: 260
:END:

[[https://doc.traefik.io/traefik/][Traefik]] is the application proxy (HTTP / TCP / UDP) that is the
entrypoint, and router, for all of your web services. Traefik
facilitates automatic TLS certificate requests via Let's Encrypt, and
handles transport security for all of your applications. Traefik is
configured to support several authentication + sentry authorization
mechanisms, including: HTTP Basic Auth, OAuth2, mutual TLS, and IP
address filtering.

*** Basic Traefik config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik config
#+end_run

This presents the interactive configuration menu for Traefik:

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

You can use the up and down arrow keys to choose the selection, and
you may type to narrow the list. Select the =Config= entry and press
the =Enter= key.

**** Traefik Config

#+attr_shortcode: :style secondary :title Don't wander off
#+begin_notice
The Traefik configuration is extensive. This section will only show
you how to configure Traefik for a basic install. Many of the menu
options will be skipped for the time being. Follow these instructions
exactly, and don't go wandering through the other menus just yet.
#+end_notice

#+begin_stdout
During first time setup, you must complete the following tasks:

 * Create Traefik user.
 * Configure TLS certificates and ACME (optional).
 * Install traefik.

Traefik must be re-installed to apply any changes.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


? Traefik Configuration:  
> Traefik user
  Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / Wireguard)
  Error page template
v Logging level
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

***** Traefik user

Select the =Traefik user= option to create the traefik user on the
host.

***** TLS certificates and authorities

 * Select =TLS certificates and authorities=.
 * Select =Configure ACME (Let's Encrypt or Step-CA)=.
   * Select =Let's Encrypt (ACME)=.
   * Select =Production (recommended!)= to choose the production Lets
     Encrypt environment.
   * Select =DNS-01= as the ACME challenge type.
   * Enter an email address for ACME registration (100% optional)

****** TRAEFIK_ACME_DNS_PROVIDER     
   * Enter the ACME DNS provider: =digitalocean=
#+begin_stdout
TRAEFIK_ACME_DNS_PROVIDER: Enter the LEGO code for your DNS Provider (eg. digitalocean)
: digitalocean
#+end_stdout

****** TRAEFIK_ACME_DNS_VARNAME_1
   * Enter the  VAR /name/ that  the DigitalOcean LEGO  provider uses,
     which is literally: =DO_AUTH_TOKEN=
   * ([[https://go-acme.github.io/lego/dns/index.html][If you use a
     different DNS provider, lookup the LEGO docs for the specific var
     names used by your provider.]])

   
#+begin_stdout
You need to enter the NAMES of these variables that your provider needs.
You can enter up to 5 variable names and/or leave them blank
TRAEFIK_ACME_DNS_VARNAME_1: Enter the 1st DNS provider variable name (eg. DO_AUTH_TOKEN)
: DO_AUTH_TOKEN
#+end_stdout
     
****** TRAEFIK_ACME_DNS_VARNAME_2
   * Enter a blank value for the second VAR name, because there are no
     additional variables to enter:
#+begin_stdout
TRAEFIK_ACME_DNS_VARNAME_2: Enter the 2nd DNS provider variable name (or leave blank)
: 
#+end_stdout

****** DO_AUTH_TOKEN
  * Enter the actual value for the =DO_AUTH_TOKEN=:

#+attr_shortcode: :style secondary :title DO_AUTH_TOKEN
#+begin_notice
The value of DO_AUTH_TOKEN should be the DigitalOcean Personal Access
Token that you generated in one the previous sections.
#+end_notice
  
#+begin_stdout
Now to enter the values for the custom DNS API variables:
DO_AUTH_TOKEN: Enter the value for DO_AUTH_TOKEN (eg. your-actual-digitalocean-token-here)
: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#+end_stdout

****** Select =Configure TLS certificates (make certs)=.
   * Select =Create a new certificate=

#+begin_stdout
> Traefik Configuration: TLS certificates and authorities

> Traefik TLS config: Configure TLS certificates (make certs)

> Configure Traefik TLS certificates Create a new certificate.
Set TRAEFIK_ACME_CERT_DOMAINS=[["",[]]]
Enter the main domain (CN) for this certificate (eg. `d.rymcg.tech` or `*.d.rymcg.tech`)
: d.example.com
#+end_stdout

Instead of =d.example.com=, enter the same root domain name you chose
before.

****** Enter secondary (SANS) domains
#+begin_stdout
Now enter additional domains (SANS), one per line:
Enter a secondary domain (enter blank to skip)
: *.d.example.com
#+end_stdout

For the SANS domain, enter the wildcard subdomain of the same domain
as before, like =*.d.example.com=.

#+begin_stdout
Enter a secondary domain (enter blank to skip)
: 
#+end_stdout

It will continue asking you to enter additional SANS domains until you
enter a blank response, so just press Enter on the blank line.

****** Certificate summary

#+begin_stdout
Main domain:
 pi5.forwarding.network
Secondary (SANS) domains:
 *.pi5.forwarding.network
#+end_stdout

Finally a summary of the certificate request is printed.

 * Press the =ESC= key three times to go back to the main menu.

*** Install Traefik

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

On the main menu, select =Install (make install)=.

Wait for the Traefik service to be installed, and then you will be
returned to the main menu.

Press the =Esc= key to quit the Traefik configuration.

*** Verify Traefik status

You can check to see that Traefik has started:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik status
#+end_run

You should see two services running, =traefik=, and
=traefik-error-pages=, both in state =running=:

#+begin_stdout
NAME                   ENV              IMAGE                           STATE
traefik-error-pages-1  .env_pi_default  tarampampam/error-pages:2.25.0  running
traefik-traefik-1      .env_pi_default  traefik-traefik                 running
#+end_stdout

** Install Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: install-whoami
:EXPORT_HUGO_WEIGHT: 261
:END:
#+attr_shortcode:
#+begin_toc
table of contents
#+end_toc

*** What is Whoami?

[[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master/whoami#readme][Whoami]] is a web application that simply outputs the request headers
that it receives (reflecting them back to the requesting client):

#+attr_shortcode: :title Run this later after you install it: :style none
#+begin_run
curl https://whoami.example.com
#+end_run

#+begin_stdout
Name: default
Hostname: 38704012c4b3
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:34610
GET / HTTP/1.1
Host: whoami.example.com
User-Agent: curl/7.88.1
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: 10.93.23.114
X-Forwarded-Host: whoami.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: docker
X-Real-Ip: 10.93.23.114
#+end_stdout

This output is useful for end-to-end testing, to verify that the
application is capable of serving requests, and that all of the
configuration is correct. Traefik middlewares may also add additional
headers to incoming requests, and so whoami is a nice way to verify
that those are working too. Finally, the connection test will confirm
whether or not the TLS certificate is installed correctly.

*** Quickstart

Create a new config:

#+begin_run
d make whoami config
#+end_run

The first question the config asks for is =WHOAMI_TRAEFIK_HOST= which
should be the fully qualified domain name that the whoami app will use
for its URL:

#+begin_stdout
WHOAMI_TRAEFIK_HOST: Enter the whoami domain name (eg. whoami.example.com)
​: whoami.d.example.com
#+end_stdout

Optional authentication can be configured:

#+begin_stdout
? Do you want to enable sentry authentication in front of this app (effectively making the entire site private)?  
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout

For now, choose =No=, to disable authentication. 

Install whoami:

#+begin_run
d make whoami install
#+end_run

**** Setup temporary DNS override

The =whoami= service is not public yet, it is currently only
accessible from the same local network (LAN). For testing purposes,
you need to set a temporary local DNS override in the Raspberry Pi's
=/etc/hosts= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo "127.0.1.1       whoami.d.example.com" | sudo tee -a /etc/hosts
#+end_run

#+begin_notice
Replace whoami.d.exmaple.com with the same domain name you set for WHOAMI_TRAEFIK_HOST.
#+end_notice


**** Open whoami in the web browser

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make whoami open
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
The =open= target uses the =xdg-open= tool to automatically open your
preferred web browser to the given application's URL. Since you are
connected to the Raspberry Pi's text console over SSH, you are limited
to text-mode browsers. [[https://w3m.sourceforge.net/][w3m]] will be used in this instance to display
the page. To quit =w3m=, press =q=, then =y=.
#+end_notice

#+begin_stdout
Name: default
Hostname: c3ce89b0fceb
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:50156
GET / HTTP/1.1
Host: whoami.d.example.com
User-Agent: w3m/0.5.3+git20230121
Accept: text/html, text/*;q=0.5, image/*, application/*
Accept-Encoding: gzip, compress, bzip, bzip2, deflate
Accept-Language: en;q=1.0
X-Forwarded-For: 127.0.0.1
X-Forwarded-Host: whoami.d.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: pi5
X-Real-Ip: 127.0.0.1


≪ ↑ ↓ Viewing[SSL] <>
#+end_stdout

If you see output like printed above, you have confirmed that Whoami
and Traefik are functioning correctly. The status bar of =w3m= shows
=Viewing[SSL]= which confirms that TLS is successfully working.

You can further verify the TLS certificate is issued correctly:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
openssl s_client -connect whoami.example.com:443 </dev/null
#+end_run

#+begin_stdout
...
issuer=C = US, O = Let's Encrypt, CN = R10
...
#+end_stdout

 * If the issuer is =Let's Encrypt=, then the certificate is valid ✅.
 * If the issuer is =TRAEFIK DEFAULT CERT=, then there is some kind of
   problem 💥, and you will need to inspect the logs.


**** View the logs

It may be necessary to inspect the applicaiton logs, which you can do
so as follows:

#+begin_run
d make whoami logs
#+end_run

To check the Traefik logs, do similar:

#+begin_run
d make traefik logs
#+end_run

* Setup cloud server sentry
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: setup-cloud-sentry
:EXPORT_HUGO_WEIGHT: 300
:END:
** Setup cloud server sentry
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 301
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Launch DigitalOcean droplet
:PROPERTIES:
:EXPORT_FILE_NAME: launch-digitalocean-droplet
:EXPORT_HUGO_WEIGHT: 310
:END:
*** Create a droplet (VPS)
:PROPERTIES:
:EXPORT_FILE_NAME: public-docker-server
:END:

This chapter will show you how to create a DigitalOcean droplet (VPS)
to use as the wireguard enabled proxy server.

**** Setup your SSH key on DigitalOcean

If you have not yet setup an SSH key on your workstation, read about
that in [[/linux-workstation/config/ssh/#create-ssh-keys][the Linux Workstation book]] and set that up first.

#+attr_shortcode: :style tip
#+begin_notice
If you have the [[/linux-workstation/app-users/digitalocean][doctl client]] setup:

List all your SSH keys:
#+begin_run
doctl compute ssh-key list
#+end_run

Configure the SSH public key file you want to use:

#+begin_env
SSH_KEY=~/.ssh/id_ed25519.pub
#+end_env

Install the public key on DigitalOcean:

#+begin_run
(set -e
test -f ${SSH_KEY} || (echo "SSH key not found: ${SSH_KEY}" && exit 1)
SSH_TMP=$(mktemp) && chmod a+r ${SSH_TMP}
cat ${SSH_KEY} > ${SSH_TMP}
doctl compute ssh-key import ${USER}@${HOSTNAME} --public-key-file ${SSH_TMP}
rm -f ${SSH_TMP}
)
#+end_run

#+end_notice

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Settings= in the menu.
 * Click on the =Security= tab.
 * Click on the =Add SSH Key= button.
 * Paste your public SSH key into the box. (copy your pub key from the
   output of ~ssh-add -L~.)
 * Enter a key name, I recommend this be the name of your workstation
   computer.
 * Finish adding the key, click =Add SSH Key=.
#+end_notice

**** Create a DigitalOcean firewall template

#+attr_shortcode: :style tip
#+begin_notice
If you have the [[/linux-workstation/app-users/digitalocean][doctl client]] setup:

#+begin_run
doctl compute firewall list
#+end_run

#+begin_run
(set -e
FIREWALL_ID=$(doctl compute firewall create \
    --name "ssh-web-https-wireguard" \
    --inbound-rules "protocol:tcp,ports:22,address:0.0.0.0/0" \
    --no-header --format ID)
doctl compute firewall add-rules "${FIREWALL_ID}" \
    --inbound-rules "protocol:tcp,ports:80,address:0.0.0.0/0"
doctl compute firewall add-rules "${FIREWALL_ID}" \
    --inbound-rules "protocol:tcp,ports:443,address:0.0.0.0/0"
doctl compute firewall add-rules "${FIREWALL_ID}" \
    --inbound-rules "protocol:udp,ports:51820,address:0.0.0.0/0"
doctl compute firewall add-rules "${FIREWALL_ID}" \
    --outbound-rules "protocol:tcp,ports:0,address:0.0.0.0/0"
doctl compute firewall add-rules "${FIREWALL_ID}" \
    --outbound-rules "protocol:udp,ports:0,address:0.0.0.0/0"
doctl compute firewall add-rules "${FIREWALL_ID}" \
    --outbound-rules "protocol:icmp,ports:0,address:0.0.0.0/0"
echo ${FIREWALL_ID}
)
#+end_run
#+end_notice

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Firewalls= tab.
 * Click =Create Firewall=.
 * Enter the name, eg. =ssh-web-https-wireguard=.
 * Enter the following rules:
   * SSH:
     * Type: =SSH=
     * Protocol: =TCP=
     * Port Range: =22=
     * Sources: All IPv4, All IPv6, or a specific static IP address if
       you want to be more secure.
   * HTTP:
     * Type: =HTTP=
     * Protocol: =TCP=
     * Port Range: =80=
     * Sources: All IPv4, All IPv6.
   * HTTPS:
     * Type: =HTTP=
     * Protocol: =TCP=
     * Port Range: =443=
     * Sources: All IPv4, All IPv6.
   * Wireguard VPN (optional):
     * Type: =Custom=
     * Protocol: =UDP=
     * Port Range: =51820=
     * Sources: All IPv4, All IPv6.
  * Click =Create Firewall=.
#+end_notice

**** Creating a DigitalOcean droplet for a Docker server

DigitalOcean provides a Docker image with which to create a droplet
(DigitalOcean's name for their own VPS product).

#+attr_shortcode: :style tip
#+begin_notice
If you have the [[/linux-workstation/app-users/digitalocean][doctl client]] setup:

Set variables to configure the droplet:

#+begin_env
NAME=docker-dev
IMAGE=debian-12-x64
REGION=nyc1
SIZE=s-1vcpu-2gb
SSH_KEY=~/.ssh/id_ed25519.pub
SSH_FINGERPRINT=$(ssh-keygen -E md5 -l -f ${SSH_KEY} | grep -Po "MD5:\K[a-f0-9\:]+")
#+end_env

Create the droplet:

#+begin_run
DROPLET_ID=$(doctl compute droplet create \
    "${NAME}" \
    --image "${IMAGE}" \
    --size "${SIZE}" \
    --region "${REGION}" \
    --ssh-keys "${SSH_FINGERPRINT}" \
    --tag-names "doctl-${USERNAME}@${HOST}" \
    --wait --no-header --format ID)
echo ${DROPLET_ID}
#+end_run

#+end_notice

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Droplets= in the menu.
 * Click =Create Droplet=.
 * Choose a Region (eg. New York), where the droplet will be created.
 * Underneath the heading =Choose an image=, choose =Debian= (select
   the latest version).
 * Choose a droplet size. 2GB RAM and 50GB disk recommended for medium
   size production installs. (It is tested working on as little as
   512MB ram, [[https://blog.rymcg.tech/blog/linux/zram/][if you enable zram]] and/or create a 1GB swapfile. Do not
   abuse swap space like this in production! However I think its fine
   for development use, but you may occasionally run into low memory
   issues if less than 1GB.)
 * Optional: Add a block storage device, in order to store your Docker
   volumes. (This is useful to store data separate from the droplet
   lifecycle, or to have a larger amount of storage than the droplet
   size gives you for the root filesystem. If your basic droplet size
   is already sufficient, and you perform regular backups, this might
   not be needed.)
 * Select your SSH key for the root user.
 * Set the hostname for the docker server. The name should be short
   and typeable, as it will become a part of the canononical service
   URLs. For this example, we choose =prod=.
 * Verify everything's correct, and then click =Create Dropet=.
#+end_notice

**** Apply the DigitalOcean droplet firewall

#+attr_shortcode: :style tip
#+begin_notice
If you have the [[/linux-workstation/app-users/digitalocean][doctl client]] setup:

#+begin_run
FIREWALL_ID=$(doctl compute firewall list | grep ssh-web-https-wireguard | cut -d " " -f1)
doctl compute firewall add-droplets \
    "${FIREWALL_ID}" \
    --droplet-ids "${DROPLET_ID}"
#+end_run
#+end_notice

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Find the firewall template you created, and click it.
 * Click on the firewall's =Droplets= tab.
 * Click =Add Droplets= and search for the droplet you created and select it.
 * Click =Add Droplet= to add the firewall to the droplet.
#+end_notice

**** Create wildcard DNS records for the droplet

For the purposes of documentation, assume you you own the domain
=example.com= and you have created the Docker server named =prod=. You
should replace =example.com= with your actual domain name, and =prod=
with your actual docker instance name/stage.

#+attr_shortcode: :style tip
#+begin_notice
If you have the [[/linux-workstation/app-users/digitalocean][doctl client]] setup:

List all domains:

#+begin_run
doctl compute domain list
#+end_run

#+begin_env
ROOT_DOMAIN=example.com
HOST=docker-dev
HOST_IP=$(doctl compute droplet get --no-header --format "Public IPv4" ${DROPLET_ID})
TTL=1800
#+end_env

List all records for =ROOT_DOMAIN=:

#+begin_run
doctl compute domain records list ${ROOT_DOMAIN}
#+end_run

Create Host record:

#+begin_run
doctl compute domain records create \
    "${ROOT_DOMAIN}" \
    --record-type A \
    --record-name "${HOST}" \
    --record-data ${HOST_IP} \
    --record-ttl ${TTL} \
    --record-tag "doctl-${USERNAME}@${HOST}"
#+end_run

Create Wildcard subdomain record:

#+begin_run
doctl compute domain records create \
    "${ROOT_DOMAIN}" \
    --record-type A \
    --record-name "*.${HOST}" \
    --record-data ${HOST_IP} \
    --record-ttl ${TTL} \
    --record-tag "doctl-${USERNAME}@${HOST}"
#+end_run

#+end_notice
#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Domains= tab.
 * Find the domain you created earlier, and click it.
 * Create an =A= record:
   * Hostname: enter the subdomain name without the domain part (eg.
     =prod=, the name of your docker server, without the
     =.example.com= suffix).
   * Will direct to: select the droplet you created from the list.
   * Click =Create Record=.
 * Create another =A= record, for the wildcard:
   * Hostname: enter the same name as before but prepend =*.= in front
     of it (eg. if the server is named =prod=, create a record for
     =*.prod=, without the =.example.com= suffix).
   * Will direct to: select the same droplet as before.
   * Click =Create Record=.
 * Optional: create additional records on the root domain. If you
   don't want the docker instance name in the subdomain you give to
   people (eg. =www.prod.example.com=), you could create additional
   (non-wildcard) records on the root domain now (eg.
   =www.example.com=, or even just =example.com=). However, it would
   be wasteful to put a wildcard record on the root domain
   (=*.example.com=) because then the domain could only be used with a
   single Docker instance, therefore all records on the root should be
   non-wildcard, and this means you must add them one by one.
#+end_notice

#+attr_shortcode: :style secondary :title Test DNS
#+begin_notice
Test that your wildcard record actually works. Use the =dig= command
(For Debian/Ubuntu install the =dnsutils= package. For Arch Linux
install =bind-tools=. For Fedora install =bind-utils=.)

Pick some random subdomain off your domain:

#+begin_run
dig laksdflkweieri.prod.example.com
#+end_run

#+begin_stdout
;; ANSWER SECTION:
laksdflkweieri.prod.example.com.    3600    IN      A       153.114.12.78
#+end_stdout

Since you created the wildcard record for =*.prod.example.com= dig
should return your Docker server's IP address in the =ANSWER SECTION=
of the output. You can test all your other records the same way.

If you run into DNS caching problems, verify with the source DNS
server directly:

#+begin_run
dig @ns1.digitalocean.com laksdflkweieri.prod.example.com
#+end_run
#+end_notice

**** Congratulations

You have now finished installation of a remote host running Debian.

You must now configure your workstation to remotely control your
remote Docker context.


** Setup Docker context on the Pi
:PROPERTIES:
:EXPORT_FILE_NAME: setup-docker-context
:EXPORT_HUGO_WEIGHT: 320
:END:
TODO
** Install Traefik and Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: install-traefik-and-whoami
:EXPORT_HUGO_WEIGHT: 330
:END:
TODO
* Configure Wireguard tunnel
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: configure-wireguard-tunnel
:EXPORT_HUGO_WEIGHT: 400
:END:
TODO
** Configure Wireguard tunnel
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 401
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Configure sentry wireguard server
:PROPERTIES:
:EXPORT_FILE_NAME: configure-sentry-wireguard-server
:EXPORT_HUGO_WEIGHT: 410
:END:
TODO
** Configure pi wireguard client
:PROPERTIES:
:EXPORT_FILE_NAME: configure-pi-wireguard-client
:EXPORT_HUGO_WEIGHT: 420
:END:
TODO
** Configure routes for Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: configure-routes-for-whoami
:EXPORT_HUGO_WEIGHT: 430
:END:
TODO
* Install web services
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: install-web-services
:EXPORT_HUGO_WEIGHT: 500
:END:
** Install web services
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 501
:END:
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Immich
:PROPERTIES:
:EXPORT_FILE_NAME: immich
:EXPORT_HUGO_WEIGHT: 510
:END:
TODO
** Yourls
:PROPERTIES:
:EXPORT_FILE_NAME: yourls
:EXPORT_HUGO_WEIGHT: 520
:END:
TODO
