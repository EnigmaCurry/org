#+hugo_base_dir: ../hugo
#+hugo_section: /portable-docker
#+hugo_weight: auto
#+hugo_paired_shortcodes: %notice badge button %children %index run stdout edit math mermaid openapi toc env
#+STARTUP: align

* Portable Docker: Build and Deploy Anywhere with WireGuard Tunneling
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :linkTitle Portable Docker
:EXPORT_HUGO_WEIGHT: 300
:END:

[[/img/portable-docker/treasure.webp]]

This book serves as your guide to installing Docker on a small
portable Linux device (e.g., Raspberry Pi) and deploying some web
service containers on it.

You'll also create and configure a public cloud server (e.g.,
a DigitalOcean droplet) whose sole purpose is to host a VPN (WireGuard)
and public gateway (Traefik), enabling the Raspberry Pi to securely
connect from any location.

Through the encrypted tunnel established by this connection, the Pi
can publish services to the Internet even when operating behind a
restrictive firewall, such as public Wi-Fi, mobile hotspots, or
carrier-grade NAT. As long as you can get unblocked /outgoing/
Internet access, you can self-host a roaming public server from
anywhere!

#+attr_shortcode: :icon code-branch :style primary :href https://github.com/EnigmaCurry/d.rymcg.tech#readme
#+begin_button
d.rymcg.tech
#+end_button

#+attr_shortcode: :icon comment-dots :style red :href https://matrix.to/#/#d.rymcg.tech:enigmacurry.com
#+begin_button
Chat with us on Matrix
#+end_button

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: introduction
:EXPORT_HUGO_WEIGHT: 100
:END:

#+begin_toc
table of contents
#+end_toc

** Raspberry Pi

[[/img/portable-docker/pi5-assembled.webp]]

Here is my Raspberry Pi 5, which is a small form factor Linux
computer, running [[https://www.raspberrypi.com/software/][Raspberry Pi OS]] and [[https://docs.docker.com/engine/][Docker]]. It has been outfitted
with an NVME SSD attached via the expandable PCI-E bus. It has 8GB of
RAM and 1TB of fast storage.

I use this as a tiny web server that I can take anywhere I go.

It normally sits in one place for a long time. But sometimes it needs
to be picked up and installed in a new place. I need it to be able to
get the network up, have it resume all of its previous functions, and
even use the same IP address as before. Traveling with this device
should be a plug and play experience, with minimal disruption to the
clients that expect this server to be online and available. No matter
what kind of connection to the Internet it has available, it should be
quick to get this server back online.

** Sentry Droplet

To accomplish this feat, we need to set up another server (to be named
=sentry=) that has a static IP address and is accessible from the
public Internet. I use a [[https://m.do.co/c/d5da28d3d99d][DigitalOcean droplet]] (affiliate link helps
support this book), which is a type of Virtual Private Server (VPS)
and exists in the public cloud. The sentry is always on and anyone in
the world can connect to it (via HTTP). However, the sentry does not
serve any applications by itself; it only creates the public [[https://doc.traefik.io/traefik/][Traefik]]
proxy (ingress) which forwards incoming connections through a backdoor
VPN connection to the Raspberry Pi. The Pi automatically initiates
this connection to the sentry whenever it boots and becomes online.

[[/img/portable-docker/vpn-diagram.webp]]

** WireGuard VPN

The Raspberry Pi should acquire whatever kind of Internet connection
is locally available via DHCP, therefore it won't have a static IP
address initially. Once it's online, it creates an outbound VPN
connection to the sentry via [[https://www.wireguard.com/][WireGuard]]. Once connected to the VPN, the
Pi is assigned a static private IP address that only the sentry can
communicate with.

The sentry forwards incoming connections from the Internet to the
Raspberry Pi over the WireGuard VPN connection. Traefik is used on
both the sentry and Raspberry Pi to create the full public route to
each of your services. Traefik supports the following types of routes:

 * HTTP Layer 7 (Routes an incoming HTTP request, which is a domain
   name [TLS SNI], and optional HTTP path, over port 443 to a backend
   HTTP server based on these criteria)
 * TCP Layer 4 (Routes a unique TCP ADDRESS:PORT combination to a
   unique backend ADDRESS:PORT combination)
 * UDP Layer 4 - TODO (unimplemented, but doable)

This lets you publicly route virtually any service directly to your
Raspberry Pi, whether it's sitting at your desk, or taken to an
impromptu getaway location.

** d.rymcg.tech


[[/img/portable-docker/vpn-string-along.webp]]


[[https://github.com/EnigmaCurry/d.rymcg.tech][d.rymcg.tech]] is a configuration manager for Docker, as well as a
collection of open source web services and config templates. It
contains an extensive configuration wizard for [[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master/traefik#readme][Traefik]] and an
idiomatic [[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master#command-line-interaction][command line tool]], which makes Docker Compose projects both
easy to document, as well as to use.

** Your workstation

Traditionally, d.rymcg.tech suggests to install itself /on a separate
workstation/ and urges you to never actually login to your Docker
server, but rather to exclusively control it remotely from your
workstation. This is one of the ways to follow the good DevOps
practice, summed up by the metaphor: "Treat your infrastructure like
cattle, not like pets." However, this strategy has the drawback that
if you lose access to your workstation, it makes it diffcult to
adminster the server (you would have to recreate your =.env= files on
a new workstation, from backup, or from scratch).

To avoid this complexity, and to require keeping everything portable
in one package, as well as to make it easier to maintain after long
periods of inactivity and forgetfulness, we will make an important
compromise and an exception to the normal DevOps rule:

#+attr_shortcode: :title The Raspberry Pi serves the role of workstation AND server :style info
#+begin_notice
In this book, the configuration tools (d.rymcg.tech) will be installed
/to the same server/ that runs Docker, rather than the usual
recomendation to do so on a separate workstation. Comingling the roles
of server and workstation means you've got everything together in one
little portable box, and it will make everything easier to get started
with. Your portable Pi is therefore a /pet/ Docker server, plus
workstation, all in one.

If you had a whole fleet of Raspberry Pis to manage, this would be a
terrible idea, because you would be missing the centralized
workstation to control them all, and you'd have to login to each one
of them and configure them directly. However, you will likely start
this journey with only one Pi to manage, so this is a good initial
compromise to make. If you want to build a proper workstation that can
control several servers from one location, read the [[/linux-workstation/][Linux Workstation]]
book and the main [[https://github.com/enigmacurry/d.rymcg.tech?tab=readme-ov-file#readme][d.rymcg.tech README]].

If you are going to seriously travel with this device, you should
consider [[https://gist.github.com/EnigmaCurry/2f9bed46073da8e38057fe78a61e7994][installing full disk encryption]] and requiring remote SSH
unlock on boot, but this is an advanced topic that is outside the
scope of this book.
#+end_notice

** Your console client

So, if the workstation is on the Raspberry Pi, you're still going to
need to travel with another computer (e.g., a laptop) and set that up
with an SSH key on it, so you can remotely log in to the Pi (unless
you want to carry a display and keyboard to plug into it directly).

**** Editing files on the Pi

Eventually you might need to edit a =.env= file by hand, and so you
need to know how to edit files remotely over SSH, so you have a few
options in that regard:

 * Learn how to use one of the many terminal mode text editors (Emacs,
   Vim, nano, etc.) and edit the files through an SSH console directly
   on the Pi.
 * Setup your personal computer with an editor that works over SSH
   (Emacs' [[https://www.gnu.org/software/tramp/][TRAMP]], VS Code's [[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh][Remote SSH]], Vim's [[https://www.vim.org/scripts/script.php?script_id=1075][Netrw]] etc.)
 * Edit the files locally and copy the files with scp, [[https://wiki.archlinux.org/title/Rsync][rsync]], or
   [[https://blog.rymcg.tech/blog/linux/rclone_sync/][rclone]].

** Next steps

 * Set up DNS
 * Set up Raspberry Pi
 * Set up Sentry Droplet
 * Set up WireGuard
 * Install apps and services

* Set up DNS
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: set-up-dns
:EXPORT_HUGO_WEIGHT: 150
:END:
** Set up DNS
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 151
:END:

Before you can configure any hardware, you need to set up the domain
name service (DNS) of your domain.

[[/img/portable-docker/dns.webp]]

#+begin_index
index
#+end_index

** Register a domain name
:PROPERTIES:
:EXPORT_FILE_NAME: register-domain
:EXPORT_HUGO_WEIGHT: 160
:END:

To host a web service, one of the first things you will need is to
register your domain name (e.g., =example.com=). This will be the
domain name used for all of your service links, and it is what your
users will need to type into their web browsers (or click on) to visit
your pages.

[[/img/portable-docker/hello-traefik.webp]]

Public domain names are a scarce resource. Because of their scarcity,
you must pay for your domain registrations, doing so in 1 year
increments. If domain names were free, all the good ones would be
taken by now, but because they cost money, there are still some good
enough ones left to be had. In return for your fee, you receive
exclusive use of the domain name for the period that you paid for. You
"own" the domain name, and its configuration, but you need to keep
paying a registrar to keep the record active (so its more like
renting). You can pre-pay for several years in advance, or just pay
for one year at a time. If you stop paying, and the records expire,
they will no longer resolve to your services, and you may lose control
of the domain, possibly forever.

*** Register an Internet domain name

You can buy (rent) a domain name from lots of places. For
documentation purposes, we will use [[https://www.gandi.net][Gandi.net]], but these instructions
will be similar regardless of the domain provider you pick.

#+attr_shortcode: :style info :title Setup on Gandi.net
#+begin_notice
 * Sign up for an account at [[https://www.gandi.net/][Gandi.net]]
 * Once signed in, from your dashboard, click =Register=.
 * Search for any domain name you like, e.g., =your-name.com=.
 * Add your domain to the shopping cart, go to checkout, and complete
   your purchase.
 * Once you have purchased the domain, it should show up in your
   =Dashboard=, under the =Domain= tab.
 * Leave this browser tab open, you will return to it in the next
   chapter.
#+end_notice

*** Transfer DNS to DigitalOcean

#+attr_shortcode: :style tip :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].
#+end_notice

#+attr_shortcode: :style info :title Setup on Gandi.net
#+begin_notice

 * Login to your [[https://admin.gandi.net][gandi.net]] dashboard.
 * Click the =Domain= tab.
 * Find your domain name in the list and click on it.
 * Click on the =Nameservers= tab.
 * Click on the edit button to create new =External nameservers=.
 * Delete all existing nameservers that may exist.
 * Add the following nameservers, specific to DigitalOcean:
   
   * =ns1.digitalocean.com=
   * =ns2.digitalocean.com=
   * =ns3.digitalocean.com=
#+end_notice

Wait a few minutes for the change to take effect, then you can verify
the setting from your workstation using the =whois= command:

#+begin_run
whois example.com
#+end_run

#+begin_stdout
Domain Name: example.com
Registrar WHOIS Server: whois.gandi.net
Name Server: ns1.digitalocean.com
Name Server: ns2.digitalocean.com
Name Server: ns3.digitalocean.com
#+end_stdout

The output shows a report for your domain registration including the
list of the new nameservers.

If you don't have =whois= installed, you can use [[https://www.registry.google/whois-lookup/][the web version provided by google]].

** Add the domain to DigitalOcean DNS
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token
:EXPORT_HUGO_WEIGHT: 161
:END:

The [[https://www.rfc-editor.org/rfc/rfc1035][Domain Name System]] is how you can associate one of your
sub-domains with an actual IP address on the Internet.

[[/img/portable-docker/hello-docker.webp]]

#+attr_shortcode: :style tip :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].

Sign up for a [[https://m.do.co/c/d827a13964d7][DigitalOcean account]] (using this referral link helps
support this site), and follow along to set up your domain's DNS.
#+end_notice

*** Add your domain name

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =Networking= in the left hand menu.
 * Select the =Domains= tab.
 * Enter your domain name, and click =Add Domain=.

*Wait a few minutes* for the setting to take effect, then you can verify
the domain name is added:

#+begin_run
# install dig from bind-utils package.
dig -t ns example.com
#+end_run

(if you don't have =dig= installed, you can also use [[https://toolbox.googleapps.com/apps/dig/][the web version
provided by google]], enter the domain name, and select =NS=.)

#+begin_stdout
;; ANSWER SECTION:
example.com.             2400    IN      NS      ns1.digitalocean.com.
example.com.             2400    IN      NS      ns3.digitalocean.com.
example.com.             2400    IN      NS      ns2.digitalocean.com.
#+end_stdout

The number in the second column is the TTL (Time To Live) which is the
number of seconds that the record is cached in the queried DNS server.
If you jump the gun and check this too quickly before the changes
takes effect, you may need to wait for this TTL to reset.

** Generate DigitalOcean API token for ACME challenge
:PROPERTIES:
:EXPORT_FILE_NAME: create-digitalocean-api-token-for-acme-challenge
:EXPORT_HUGO_WEIGHT: 255
:END:

[[/img/portable-docker/api.webp]]

#+attr_shortcode: :style tip :title Choose a supported DNS provider
#+begin_notice
This book uses DigitalOcean as the DNS provider in all examples, but
you may choose a different provider if you prefer, but it needs to be
supported by [[https://go-acme.github.io/lego/dns/index.html][go-acme LEGO]].
#+end_notice

DNS is also a part of the TLS certificate request process with [[https://letsencrypt.org/getting-started/][Let's
Encrypt]] (via [[https://letsencrypt.org/docs/challenge-types/][ACME DNS-01 challenge]]). Traefik interacts with Let's
Encrypt on your behalf, automatically requesting TLS certificates to
be created for your services. To allow this, you will need to procure
a DigitalOcean Personal Access Token, which grants programatic control
of your DigitalOcean account's DNS settings:

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean console]].
 * Click on =API= in the left hand menu, near the bottom of the list.
 * On the =Tokens= tab, click =Generate New Token=.
 * Enter a descriptive name indicating the owner of the token (e.g., a
   subdomain), and its purpose (e.g., ACME): =pi5.example.com ACME=.
 * Set the expiration period you want to use. Use =No expire= if you
   just want to set it and forget it, otherwise you will need to
   update the token periodically.
 * Select =Custom Scopes= so you can choose the fine-grained
   permissions.
 * The only permission that needs to be selected is =domain=.
 * Click =Generate Token=.
 * Copy the generated token to a temporary buffer/notepad. You will
   need to reference this token in the next section, when it asks for
   the =DO_AUTH_TOKEN= variable.

You will also need to generate an API token for the sentry droplet.

 * Create the second token named =sentry.example.com ACME= or similar.
 * Set a =Custom scope= = =domain=.
 * Copy this token to the same temporary buffer/notepad as before,
   you'll need it when setting up the sentry droplet.

#+attr_shortcode: :style tip
#+begin_notice
You could reuse the same API token on both Pi and sentry, but its reccomended 
to create a unique token for each host.
#+end_notice
 
* Set up Raspberry Pi
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: set-up-raspberry-pi
:EXPORT_HUGO_WEIGHT: 200 
:END:
** Set up Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 201
:END:
[[/img/portable-docker/rpi-handover.webp]]
#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Build your Raspberry Pi
:PROPERTIES:
:EXPORT_FILE_NAME: build-your-pi
:EXPORT_HUGO_WEIGHT: 210
:END:

These are the parts you will need to source for this build (purchase
price ~$240 USD):

#+attr_shortcode: :title Raspberry Pi 5 motherboard
#+begin_notice
[[/img/portable-docker/pi5.webp]]
#+end_notice
The Raspberry Pi 5 is often sold in kits, but you can also buy the
motherboard separately. If buying a pre-made kit, make sure it
includes an NVME shield to plug in an NVME SSD. Otherwise, this can be
purchased separately:

#+attr_shortcode: :title Geeekpi / 52Pi case, heatsink, NVME shield, and power supply
#+begin_notice
[[/img/portable-docker/geeekpi5case.webp]]
#+end_notice
This kit comes with the NVME shield, which is an adapter (hat) to
install on top of the Raspberry Pi 5 motherboard. This allows you to
plug in a full size NVME SSD into the Raspberry Pi's PCI-E bus. The
metal case fits the extended height neccessary to fit the NVME shield
and SSD inside. The kit also includes the required heatsink for the
motherboard, a power supply, and the flat ribbon cable (not shown)
that connects the shield to the motherboard's PCI-E port.

#+attr_shortcode: :title Sandisk SD card (32GB)
#+begin_notice
[[/img/portable-docker/sandisk-32GB-sdcard.webp]]
#+end_notice

The SD card is used as the root filesystem for Raspberry Pi OS
(formerly named Raspbian). The capacity of the card doesn't need to be
very big, as you won't be storing very much data on this.

Booting from the SD-card is a bit slower than NVME, but the advantage
of it is that you can simply swap SD-cards, and temporarily use the pi
for a different purpose, all without disrupting access to your NVME
storage.

SD-cards are more prone to failure than NVME, especially if you write
too much data to them, so this is minimized as much as possible.
=/tmp= will be mounted on tmpfs, and =/var/log= will run on log2ram,
which are both stored in RAM, so the only writes that should happen on
the SD-card should be OS updates.

#+attr_shortcode: :title SD-card adapter
#+begin_notice
[[/img/portable-docker/sd-card-adapter.webp]]
#+end_notice

The micro SD-card comes with a full size SD-card adapter, but you may
also need a USB adapter, in order to write the image.

#+attr_shortcode: :title Samsung 990EVO NVME SSD
#+begin_notice
[[/img/portable-docker/samsung-990EVO-NVME.webp]]
#+end_notice

The NVME SSD is much faster, and far more reliable, than the SD-card.
This device will be used exclusively for the Docker storage system
(mounted at =/var/lib/docker=). This is where all of your container
images will be built/downloaded, and where the volumes holding your
app data will live.

#+attr_shortcode: :title NVME heatsink
#+begin_notice
[[/img/portable-docker/nvme-heatsink.webp]]
#+end_notice

You should purchase separately an NVME heatsink to go on the top of
your NVME drive, and there is a little bit of room left in the case to
fit one.

*** Putting everything together

 * *Read the directions that come with the Geeekpi / 52Pi case*, the rest of
   this list is just a summary.
 * Install the heatsink to the Pi 5 motherboard.
 * Attach one end of the ribbon cable to the PCI-E port and lock it
   into place.
 * Attach the other end of the ribbon cable to the NVME shield and
   lock it into place.
 * Install the NVME shield on top of the Pi motherboard, plugging into
   the GPIO ports, and using the taller risers to sandwich things
   together.
 * Install the motherboard into the bottom part of the case, using the
   smaller risers to support the motherboard from below.
 * Install the NVME SSD into the NVME shield.
 * Screw on the top part of the case.
 * Install the SD-card into the slot on the bottom edge.

#+attr_shortcode: :title Pi 5 heatsink and risers installed
#+begin_notice
[[/img/portable-docker/pi-heatsink.webp]]
#+end_notice

#+attr_shortcode: :title Ribbon cable and GPIO pins connect NVME shield to Pi motherboard
#+begin_notice
[[/img/portable-docker/ribbon-cable.webp]]
#+end_notice

#+attr_shortcode: :title NVME SSD installed in the NVME shield and motherboard secured in the bottom part of case
#+begin_notice
[[/img/portable-docker/pi5-nvme.webp]]
#+end_notice

#+attr_shortcode: :title top part of the case screwed on top and SD-card installed
#+begin_notice
[[/img/portable-docker/pi5-sdcard.webp]]
#+end_notice

#+attr_shortcode: :title The fully assembled Raspberry Pi 5 (NVME heatsink not shown)
#+begin_notice
[[/img/portable-docker/pi5-assembled.webp]]
#+end_notice

** Install Raspberry Pi OS
:PROPERTIES:
:EXPORT_FILE_NAME: install-raspbian
:EXPORT_HUGO_WEIGHT: 220
:END:

[[/img/portable-docker/penguin.webp]]

The best way to install Raspberry Pi OS onto an SD-card, is to use the
[[https://www.raspberrypi.com/documentation/computers/getting-started.html][rpi-imager program]] from another computer. This allows you to set up the
user account, network settings, and SSH credentials all from the
imager software.

 * [[https://www.raspberrypi.com/software/][Download the Raspberry PI
   Imager]] or install
   =rpi-imager= from your package manager.
 * Run =rpi-imager=.
 * Click on the menu labled =Rasperry Pi Device=.
   * Choose your model of raspberry pi.
   
 * Click on the menu labeled =Operating System=
   * Choose =Raspberry PI OS (other)=
   * Choose =Raspberry PI OS Lite (64-bit)=.
   
 * Click on the menu labeled =Storage=.
   * Choose the Storage device to install to.
   * You may need to change the ownership of the device (e.g., I had to
     do =sudo chown ryan /dev/sdb= first).
     
 * Click =Next=.
 
 * Click =Edit Settings=.
 
   * On the =General= tab:
   
     * Enter the hostname
     * Enter a username and password (This book uses the username
       =pi=).
     * Optionally set up the Wi-Fi (I just use ethernet instead).
     * Set locale settings. I set mine to UTC.
     
   * On the =Services= tab:
   
     * Click =Enable SSH=
     * Choose =Allow pulbic-key authentication only=
     * If you don't have an SSH key yet, read the [[/linux-workstation/config/ssh/][SSH chapter of the Linux Workstation book]].
     * Paste the list of your SSH public keys into the box. (Find them
       on your workstation by running =ssh-add -L= or look in
       =~/.ssh/id_ed25519.pub=)
     * The SSH key is important to protect, as this is the only way to
       remotely SSH into the Raspberry Pi
       
   * On the =Options= tab:
   
     * Unselect =Enable telemetry= unless you're into that sort of
       thing.
       
 * Click =Yes= to the question =Would you like to apply OS custom settings=.
 
 * Confirm you would like to write to the SD-card and wait for it to complete.
 
 * Once complete, unplug the SD-card, put it into the raspberry pi,
   plug in the ethernet, and power it on.

*** Find the local IP address of the Pi on your LAN

Once the Pi is powered on, and is connected to your LAN, you need to
figure out what its IP address is. There are a number of ways to do
that:

 * If your network has configured multicast DNS (mDNS), you can find
   the IP address by the hostname you set in the imager (e.g., =pi5=),
   appended with the domain =.local=:

#+begin_run
ping -c3 pi5.local
#+end_run

 * From any Linux computer attached to the same LAN, run =arp -a= to
   find and list local devices. Try doing this before and after you
   turn on the Pi, and then spot the difference.

#+begin_run
arp -a
#+end_run
 * If you have a central LAN router + DHCP server, check the console
   of the router for the newly added device.
 * Plug a monitor into the (micro) HDMI port of the Raspberry Pi, and
   the IP address will be printed to the console when it boots.
   

*** Create SSH config on your workstation

You should try to connect to the Raspberry Pi from another computer
(which from now is to be refered to as your "workstation").

To do so, you will need to create an SSH config on your workstation,
containing the temporary local IP address of the Raspberry Pi. This
config is somewhat temporary, and once DNS is set up later on, it can
be replaced with a permanent hostname config.

#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host pi
    User pi
    Hostname X.X.X.X
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

Replace =X.X.X.X= with the local IP address assigned to the Raspberry
Pi.

Test that the SSH connection works:

#+begin_run
ssh pi
#+end_run

The first time you connect, it will ask you to confirm the remote host
ssh key, you should simply type =yes= to trust whatever it says, and
it will trust it automatically from now on.

If the connection is successful, you should now be logged into the
remote shell console of the Raspberry Pi.

*** Set up Log2Ram

You can increase the expected lifespan of your SD card by installing
[[https://github.com/azlux/log2ram#log2ram][log2ram]]

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo "deb [signed-by=/usr/share/keyrings/azlux-archive-keyring.gpg] http://packages.azlux.fr/debian/ bookworm main" | sudo tee /etc/apt/sources.list.d/azlux.list
sudo wget -O /usr/share/keyrings/azlux-archive-keyring.gpg  https://azlux.fr/repo.gpg
sudo apt update
sudo apt install log2ram
#+end_run

After installing log2ram, reboot the pi:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo reboot
#+end_run

After reboot, you will find =/var/log/= is mounted as type =log2ram=:

#+begin_stdout
ryan@pi5:~ $ df -h
Filesystem      Size  Used Avail Use% Mounted on
...
log2ram         128M   14M  115M  11% /var/log
#+end_stdout

*** Format and mount SSD storage

**** Identify the device name of the NVME SSD:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo fdisk -l | grep -A5 nvme
#+end_run

#+begin_stdout
Disk /dev/nvme0n1: 931.51 GiB, 1000204886016 bytes, 1953525168 sectors
Disk model: Samsung SSD 990 EVO 1TB                 
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
#+end_stdout

This shows the device is named =/dev/nvme0n1=.

**** Partition the device

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo parted /dev/nvme0n1 --script mklabel gpt
sudo parted /dev/nvme0n1 --script mkpart primary ext4 0% 100%
#+end_run

**** Create filesystem

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo mkfs.ext4 /dev/nvme0n1p1
#+end_run

**** Mount the filesystem

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo mkdir -p /var/lib/docker

echo "/dev/nvme0n1p1  /var/lib/docker  ext4  defaults  0  3" | sudo tee -a /etc/fstab

sudo systemctl daemon-reload
sudo mount /var/lib/docker
#+end_run

**** Verify the mounted storage

#+attr_shortcode: :style secondary :title Run this on the Raspberry Pi
#+begin_run
df -h /var/lib/docker
#+end_run

#+begin_stdout
Filesystem      Size  Used Avail Use% Mounted on
/dev/nvme0n1p1  916G   28K  870G   1% /var/lib/docker
#+end_stdout

This shows the correct partition =/dev/nvme0n1p1= mounted at the
correct path =/var/lib/docker= and showing the correct size of the
NVME SSD (=916G=; it's always a bit smaller than advertised.)

** Set up networking
:PROPERTIES:
:EXPORT_FILE_NAME: set-up-networking
:EXPORT_HUGO_WEIGHT: 230
:END:

[[/img/portable-docker/networking.webp]]

*** Wi-Fi

You may have already configured the Wi-Fi in the rpi-imager options,
but if not, you can do so after its been installed.

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo raspi-config
#+end_run

 * Enter =System Options=.
 * Enter =S1 Wireless LAN=.
 * Choose your current country.
 * Enter the SSID (Wi-Fi network name) you wish to connect to.
 * Enter the network passphrase

*** Configure DNS

By default, DNS is handled via DHCP, which will probably work in the
majority of cases. However, you may wish to hardcode specific DNS servers instead:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo -e "nameserver 1.1.1.1" | sudo tee /etc/resolv.conf
sudo chattr +i /etc/resolv.conf
#+end_run

=chattr +i= prevents DHCP from overwriting this file in the future.

*** Links

 * [[https://raspberrypi-guide.github.io/networking][The Raspberry Pi Guide - For scientists and anyone else]] - this
   shares how to configure many different network scenarios, including
   a direct ethernet cable between your workstation and the pi, useful
   when you can't find an ethernet LAN with DHCP.
 * [[https://www.raspberrypi.com/documentation/computers/configuration.html#wireless-networking-command-line][Official Raspberry Pi Networking guide]]

** Set up SSH
:PROPERTIES:
:EXPORT_FILE_NAME: set-up-ssh
:EXPORT_HUGO_WEIGHT: 231
:END:

The Docker context is controlled exclusively through SSH, as the
=root= user. This requires setting up some keys to allow the =pi= user
to access the =root= user's account.

Although you will not need to interact with the =root= user's shell
directly, the =pi= user will be granted full access to =root= via SSH.

#+attr_shortcode: :style warning :title Docker == root == pi
#+begin_notice
SSH is used here almost like =sudo=. The =pi= user should be treated
with the same respect as the =root= user, as it will be granted full
=root= access through SSH (to localhost).
#+end_notice

*** Create a new SSH key

You need to create a new SSH key for the =pi= user.

#+attr_shortcode: :style warning :title Unencrypted SSH keys are used for convenience
#+begin_notice
To connect to the Docker context requires that your SSH key be already
/decrypted/.

There's only two ways to do that:

 * Create an /unencrypted/ SSH key, so that no passphrase is ever
    required.
 -or-
 * Set up an ssh-agent to decrypt and load the unencrypted key into
    resident memory, so that your key can be used without requiring a
    passphrase.

For the sake of convenience, this guide will use the first method, and
create a new /unencrypted/ SSH key, living in the pi user's home
directory: =/home/pi/.ssh/id_ed25519=. The security of this key
depends upon the physical and network security of the device
(including SD-card). Any user gaining entry to the =pi= user's account
will have access to the key, and no passphrase is required to use the
key.

If you wish to enhance the security of your SSH key, please read the
[[https://wiki.archlinux.org/title/SSH_keys][Arch Wiki article on SSH keys]], which covers generating secure SSH
keys, setting a passphrase, and setting up an ssh-agent with [[https://wiki.archlinux.org/title/SSH_keys#Keychain][Keychain]].

You may also protect the integrity of the SD-card (at rest) with [[https://gist.github.com/EnigmaCurry/2f9bed46073da8e38057fe78a61e7994][full
disk encryption and remote unlock via SSH]].
#+end_notice

Create a new SSH key (without a passphrase):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519
#+end_run

*** Authorize the key of the pi user to connect as root

All interaction with Docker is done over SSH as the =root= user, so
for the =pi= user to control Docker, they need to be able to SSH to
=localhost= as the =root= user.

Add the =pi= user's key to the root user's
=/root/.ssh/authorized_keys= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat ~/.ssh/id_ed25519.pub | sudo tee -a /root/.ssh/authorized_keys
#+end_run

Create a config named =pi= in your =~/.ssh/config=:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host pi
    User root
    Hostname localhost
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

Test the connection is working:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh pi whoami
#+end_run

Accept the key fingerprint it offers:

#+begin_stdout
The authenticity of host 'localhost (::1)' can't be established.
ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
#+end_stdout

If it worked, you should see the output of =whoami= which should print
the username =root= (which is the user configured by SSH).


** Install Docker
:PROPERTIES:
:EXPORT_FILE_NAME: install-docker
:EXPORT_HUGO_WEIGHT: 240
:END:
*** Install Docker

 * On the pi, install docker:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run   
curl -sSL https://get.docker.com | sh
#+end_run

 * Test docker is working: 

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo docker run hello-world
#+end_run

  * If working, you should see a =Hello from Docker!= message and some other help info.

#+attr_shortcode: :style tip
#+begin_notice
Normally, you shouldn't use =sudo docker=. In the next section you
will create a Docker context for the =pi= user to use directly.
#+end_notice
  
*** Set up Docker context (SSH)

[[https://github.com/enigmacurry/d.rymcg.tech][d.rymcg.tech]] requires the use of a [[https://docs.docker.com/engine/manage-resources/contexts/][Docker context]] via SSH, rather than
the default socket context.

Create a new docker context, named =pi=, using the SSH config you had
just created (also called =pi=):

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context create pi --docker "host=ssh://pi"
#+end_run

Switch to use the new SSH context as the default:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker context use pi
#+end_run

Now, when you run any docker command, it will use the SSH context:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker info | grep -iE "(Name|Context)"
#+end_run

This should print the proper context: =pi=.

If it worked, the =pi= user is now fully equipped to run any docker comamnd as =root=.

** Install d.rymcg.tech
:PROPERTIES:
:EXPORT_FILE_NAME: install-d-rymcg-tech
:EXPORT_HUGO_WEIGHT: 250
:END:

*** Install dependencies

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
sudo apt-get update && \
sudo apt-get install -y bash build-essential gettext \
     git openssl apache2-utils xdg-utils jq sshfs \
     wireguard curl inotify-tools w3m
#+end_run

*** Clone the git repository

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
git clone https://github.com/EnigmaCurry/d.rymcg.tech.git \
    ${HOME}/git/vendor/enigmacurry/d.rymcg.tech

cd ${HOME}/git/vendor/enigmacurry/d.rymcg.tech
#+end_run

*** Configure Bash shell integration

Configure the =pi= user's =~/.bashrc= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;'EOF' &gt&gt ~/.bashrc
export PATH=${PATH}:${HOME}/git/vendor/enigmacurry/d.rymcg.tech/_scripts/user
eval "$(d.rymcg.tech completion bash)"
__d.rymcg.tech_cli_alias d
EOF
#+end_run

Once finished, logout of the Pi and log back in.

Now you should have a new alias named =d= that controls the
=d.rymcg.tech= toolset. Check out the main help screen:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d
#+end_run

#+begin_stdout
## Main d.rymcg.tech sub-commands - Optional arguments are printed in brackets [OPTIONAL_ARG]
cd [SUBDIR]                   Enter a sub-shell and go to the ROOT_DIR directory (or given subdirectory)
make [PROJECT] [ARGS ...]     Run a `make` command for the given d.rymcg.tech project name
context                       View or set the current Docker context
new-context                   Create a new Docker context
tmp-context                   Use a temporary Docker context in a sub-shell
config                        Configure the current Docker context
ssh [COMMAND ...]             Run command or shell on active docker context SSH host
completion                    Setup TAB completion in your shell
install                       Install an app interactively
install-docker                Install Docker Engine on the host
status                        Show status of all installed services
audit                         Print security audit of running containers

## Documentation sub-commands:
help                          Show this help screen
list                          List available d.rymcg.tech projects
                              (not including external projects, unless you symlink them into ROOT_DIR)
readme                        Open the main d.rymcg.tech README.md in your browser
readme [PROJECT]              Open the README.md for the given project name
readme digitalocean           Open root documentation file: DIGITALOCEAN.md
readme security               Open root documentation file: SECURITY.md
readme aws                    Open root documentation file: AWS.md
readme license                Open root documentation file: LICENSE.txt
readme raspberry_pi           Open root documentation file: RASPBERRY_PI.md
readme makefile_ops           Open root documentation file: MAKEFILE_OPS.md
#+end_stdout

*** Run the main config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d config
#+end_run

*** Follow the interactive prompts to finish configuration
**** Install script-wizard
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_stdout
This utility can automatically install a required helper tool called script-wizard.
See https://github.com/enigmacurry/script-wizard

Do you wish to automatically install script-wizard into `_scripts/script-wizard`? (Y/n): y
#+end_stdout

[[https://github.com/EnigmaCurry/script-wizard][script-wizard]] is required dependency that can be downloaded and
installed automatically. =script-wizard= makes interactive input and
selection wizards in Bash a lot nicer.

**** Acknowledge the detected Docker context
#+begin_stdout
? This will make a configuration for the current docker context (pi). Proceed? (Y/n)  y
#+end_stdout
**** Choose the root domain name for this server

#+begin_stdout
ROOT_DOMAIN: Enter the root domain for this context (e.g., d.example.com)
: d.example.com
#+end_stdout

Instead of =d.example.com= you should type the actual domain name (or
subdomain name) that you want to use as the root domain for all of
your services on this server.

For example, if you entered =example.com=, you will later install apps
(e.g., =whoami=) with subdomains like =whoami.example.com=. Choosing a
deeper subdomain has the benefit of being able to share a single root
domain name amongst several Docker instances, therefore with the
example of =d.example.com= the service would be deployed like
=whoami.d.example.com=, and a second Docker instance could use
=d2.example.com=, with services like =whoami.d2.example.com=.

**** Choose to save generated passwords.json files by default
#+begin_stdout
Every time you configure HTTP Basic Authentication, you are asked if you wish to save the cleartext passwords
into passwords.json (in each project directory). If you were to press Enter without answering the question,
the default answer is No (displayed as y/N). You may change the default response to Yes (displayed as Y/n).
? Do you want to save cleartext passwords in passwords.json by default? (y/N)  y
#+end_stdout

This question is in regards to the integrated HTTP Basic Auth setting,
which allows you to store the plain text credentials in the file named
=passwords.json= in the various project directories. This is a
convenience feature, but you may not want it. Its not really a
security concern, because the same password is also availalbe in the
.env file for the project anyway, so go ahead an enable it.



** Install Traefik
:PROPERTIES:
:EXPORT_FILE_NAME: install-traefik
:EXPORT_HUGO_WEIGHT: 260
:END:

[[/img/portable-docker/gopher.webp]]

[[https://doc.traefik.io/traefik/][Traefik]] is the application proxy (HTTP / TCP / UDP) that is the
entrypoint, and router, for all of your web services. Traefik
facilitates automatic TLS certificate requests via Let's Encrypt, and
handles transport security for all of your applications. Traefik is
configured to support several authentication + sentry authorization
mechanisms, including: HTTP Basic Auth, OAuth2, mutual TLS, and IP
address filtering.

*** Basic Traefik config

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik config
#+end_run

This presents the interactive configuration menu for Traefik:

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

You can use the up and down arrow keys to choose the selection, and
you may type to narrow the list. Select the =Config= entry and press
the =Enter= key.

**** Traefik Config

#+attr_shortcode: :style secondary :title Don't wander off
#+begin_notice
The Traefik configuration is extensive. This section will only show
you how to configure Traefik for a basic install. Many of the menu
options will be skipped for the time being. Follow these instructions
exactly, and don't go wandering through the other menus just yet.
#+end_notice

#+begin_stdout
During first time setup, you must complete the following tasks:

 * Create Traefik user.
 * Configure TLS certificates and ACME (optional).
 * Install traefik.

Traefik must be re-installed to apply any changes.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


? Traefik Configuration:  
> Traefik user
  Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
v Logging level
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

***** Traefik user

Select the =Traefik user= option to create the traefik user on the
host.

***** Entrypoints (including dashboard)

The following entrypoints are defined by default:

#+begin_stdout
Entrypoint  Listen_address  Listen_port  Protocol  Upstream_proxy
----------  --------------  -----------  --------  --------------
web         0.0.0.0         80           tcp       
websecure   0.0.0.0         443          tcp       
#+end_stdout

You will need to reconfigure the =websecure= entrypoint, to enable the
=Proxy Protocol=:

#+begin_stdout
? Traefik entrypoint config  
  Show enabled entrypoints
> Configure stock entrypoints
  Configure custom entrypoints

? Select entrypoint to configure:  
  dashboard : Traefik dashboard (only accessible from 127.0.0.1:8080 and requires HTTP basic auth)
  web : HTTP (unencrypted; used to redirect requests to use HTTPS)
> websecure : HTTPS (TLS encrypted HTTP)
  web_plain : HTTP (unencrypted; specifically NOT redirected to websecure; must use different port than web)
  mqtt : MQTT (mosquitto) pub-sub service
  ssh : SSH (forgejo) git (ssh) entrypoint
v xmpp_c2s : XMPP (ejabberd) client-to-server entrypoint

> Do you want to enable the websecure entrypoint? Yes
Set TRAEFIK_WEBSECURE_ENTRYPOINT_ENABLED=true
TRAEFIK_WEBSECURE_ENTRYPOINT_HOST: Enter the host ip address to listen on (0.0.0.0 to listen on all interfaces) (e.g., 0.0.0.0)
: 0.0.0.0
TRAEFIK_WEBSECURE_ENTRYPOINT_PORT: Enter the host port to listen on (e.g., 443)
: 443

? Is this entrypoint downstream from another trusted proxy?  
  No, clients dial directly to this server. (Turn off Proxy Protocol)
> Yes, clients are proxied through a trusted server. (Turn on Proxy Protocol)

TRAEFIK_WEBSECURE_ENTRYPOINT_PROXY_PROTOCOL_TRUSTED_IPS: Enter the comma separated list of trusted upstream proxy servers (CIDR)
: 10.13.16.1/32
#+end_stdout

Press =ESC= two times to get back to the traefik config menu.

***** TLS certificates and authorities

 * Select =TLS certificates and authorities=.
 * Select =Configure ACME (Let's Encrypt or Step-CA)=.
   * Select =Let's Encrypt (ACME)=.
   * Select =Production (recommended!)= to choose the production Lets
     Encrypt environment.
   * Select =DNS-01= as the ACME challenge type.
   * Enter an email address for ACME registration (100% optional)

****** TRAEFIK_ACME_DNS_PROVIDER     
   * Enter the ACME DNS provider: =digitalocean=
#+begin_stdout
TRAEFIK_ACME_DNS_PROVIDER: Enter the LEGO code for your DNS Provider (e.g., digitalocean)
: digitalocean
#+end_stdout

****** TRAEFIK_ACME_DNS_VARNAME_1
   * Enter the  VAR /name/ that  the DigitalOcean LEGO  provider uses,
     which is literally: =DO_AUTH_TOKEN=
   * ([[https://go-acme.github.io/lego/dns/index.html][If you use a
     different DNS provider, lookup the LEGO docs for the specific var
     names used by your provider.]])

   
#+begin_stdout
You need to enter the NAMES of these variables that your provider needs.
You can enter up to 5 variable names and/or leave them blank
TRAEFIK_ACME_DNS_VARNAME_1: Enter the 1st DNS provider variable name (e.g., DO_AUTH_TOKEN)
: DO_AUTH_TOKEN
#+end_stdout
     
****** TRAEFIK_ACME_DNS_VARNAME_2
   * Enter a blank value for the second VAR name, because there are no
     additional variables to enter:
#+begin_stdout
TRAEFIK_ACME_DNS_VARNAME_2: Enter the 2nd DNS provider variable name (or leave blank)
: 
#+end_stdout

****** DO_AUTH_TOKEN
  * Enter the actual value for the =DO_AUTH_TOKEN=:

#+attr_shortcode: :style secondary :title DO_AUTH_TOKEN
#+begin_notice
The value of DO_AUTH_TOKEN should be the DigitalOcean Personal Access Token
#+end_notice
  
#+begin_stdout
Now to enter the values for the custom DNS API variables:
DO_AUTH_TOKEN: Enter the value for DO_AUTH_TOKEN (e.g., your-actual-digitalocean-token-here)
: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#+end_stdout

****** Select =Configure TLS certificates (make certs)=.
   * Select =Create a new certificate=

#+begin_stdout
> Traefik Configuration: TLS certificates and authorities

> Traefik TLS config: Configure TLS certificates (make certs)

> Configure Traefik TLS certificates Create a new certificate.
Set TRAEFIK_ACME_CERT_DOMAINS=[["",[]]]
Enter the main domain (CN) for this certificate (e.g., `d.rymcg.tech` or `*.d.rymcg.tech`)
: d.example.com
#+end_stdout

Instead of =d.example.com=, enter the same root domain name you chose
before.

****** Enter secondary (SANS) domains
#+begin_stdout
Now enter additional domains (SANS), one per line:
Enter a secondary domain (enter blank to skip)
: *.d.example.com
#+end_stdout

For the SANS domain, enter the wildcard subdomain of the same domain
as before, like =*.d.example.com=.

#+begin_stdout
Enter a secondary domain (enter blank to skip)
: 
#+end_stdout

It will continue asking you to enter additional SANS domains until you
enter a blank response, so just press Enter on the blank line.

****** Certificate summary

#+begin_stdout
Main domain:
 pi5.example.com
Secondary (SANS) domains:
 *.pi5.example.com
#+end_stdout

Finally a summary of the certificate request is printed.

 * Press the =ESC= key three times to go back to the main menu.

***** Error page template

You can customize the [[https://github.com/tarampampam/error-pages#-templates][Traefik error page template]] by selecing a custom
theme:

[[/img/portable-docker/404.webp]]

#+begin_stdout
? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
  Advanced Routing (Layer 7 / Layer 4 / WireGuard)
> Error page template
  Logging level
  Access logs

? Select an error page theme (https://github.com/tarampampam/error-pages#-templates)  
^ hacker-terminal
  cats
  lost-in-space
  app-down
  connection
> matrix
  orient
#+end_stdout

Since this theme is only used for the 404s and other errors coming
from Traefik directly (and not for any errors coming from the apps
themselves), the choice here is not purely aesthetic: as long as you
choose /unique/ error page template themes for each Traefik server
instance (e.g., =pi=, =sentry=), you will gain extra debugging
knowledge of knowing /which/ Traefik instance is returning a
particular error.


*** Install Traefik

#+begin_stdout
############################################################
###                          pi                          ###
############################################################


? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
[↑↓ to move, enter to select, type to filter, ESC to cancel]
#+end_stdout

On the main menu, select =Install (make install)=.

Wait for the Traefik service to be installed, and then you will be
returned to the main menu.

Press the =Esc= key to quit the Traefik configuration.

*** Verify Traefik status

You can check to see that Traefik has started:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik status
#+end_run

You should see two services running: =traefik= and
=traefik-error-pages=, both in state =running=:

#+begin_stdout
NAME                   ENV              IMAGE                           STATE
traefik-error-pages-1  .env_pi_default  tarampampam/error-pages:2.25.0  running
traefik-traefik-1      .env_pi_default  traefik-traefik                 running
#+end_stdout

** Install Whoami
:PROPERTIES:
:EXPORT_FILE_NAME: install-whoami
:EXPORT_HUGO_WEIGHT: 261
:END:
#+attr_shortcode:
#+begin_toc
table of contents
#+end_toc

[[/img/portable-docker/whoami.webp]]

*** What is Whoami?

[[https://github.com/EnigmaCurry/d.rymcg.tech/tree/master/whoami#readme][Whoami]] is a web application that simply outputs the request headers
that it receives (reflecting them back to the requesting client):

#+attr_shortcode: :title Run this later after you install it: :style none
#+begin_run
curl https://whoami.example.com
#+end_run

#+begin_stdout
Name: default
Hostname: 38704012c4b3
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:34610
GET / HTTP/1.1
Host: whoami.example.com
User-Agent: curl/7.88.1
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: 198.51.100.1
X-Forwarded-Host: whoami.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: docker
X-Real-Ip: 198.51.100.1
#+end_stdout

This output is useful for end-to-end testing, to verify that the
application is capable of serving requests, and that all of the
configuration is correct. Traefik middlewares may also add additional
headers to incoming requests, and so whoami is a nice way to verify
that those are working too. Finally, the connection test will confirm
whether or not the TLS certificate is installed correctly.

*** Install

Create a new config:

#+begin_run
d make whoami config
#+end_run

The first question the config asks for is =WHOAMI_TRAEFIK_HOST= which
should be the fully qualified domain name that the whoami app will use
for its URL:

#+begin_stdout
WHOAMI_TRAEFIK_HOST: Enter the whoami domain name (e.g., whoami.example.com)
​: whoami.d.example.com
#+end_stdout

Optional authentication can be configured:

#+begin_stdout
? Do you want to enable sentry authentication in front of this app (effectively making the entire site private)?  
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout

For now, choose =No=, to disable authentication. 

Install whoami:

#+begin_run
d make whoami install
#+end_run

**** Set up temporary DNS override

The =whoami= service is not public yet, it is currently only
accessible from the same local network (LAN). For testing purposes,
you need to set a temporary local DNS override in the Raspberry Pi's
=/etc/hosts= file:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
echo "127.0.1.1       whoami.d.example.com" | sudo tee -a /etc/hosts
#+end_run

#+begin_notice
Replace whoami.d.exmaple.com with the same domain name you set for WHOAMI_TRAEFIK_HOST.
#+end_notice


**** Open whoami in the web browser

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make whoami open
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
The =open= target uses the =xdg-open= tool to automatically open your
preferred web browser to the given application's URL. Since you are
connected to the Raspberry Pi's text console over SSH, you are limited
to text-mode browsers. [[https://w3m.sourceforge.net/][w3m]] will be used in this instance to display
the page. To quit =w3m=, press =q=, then =y=.
#+end_notice

#+begin_stdout
Name: default
Hostname: c3ce89b0fceb
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:50156
GET / HTTP/1.1
Host: whoami.d.example.com
User-Agent: w3m/0.5.3+git20230121
Accept: text/html, text/*;q=0.5, image/*, application/*
Accept-Encoding: gzip, compress, bzip, bzip2, deflate
Accept-Language: en;q=1.0
X-Forwarded-For: 127.0.0.1
X-Forwarded-Host: whoami.d.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: pi5
X-Real-Ip: 127.0.0.1


≪ ↑ ↓ Viewing[SSL] <>
#+end_stdout

If you see output like printed above, you have confirmed that Whoami
and Traefik are functioning correctly. The status bar of =w3m= shows
=Viewing[SSL]= which confirms that TLS is successfully working.

You can further verify the TLS certificate is issued correctly:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
openssl s_client -connect whoami.example.com:443 </dev/null
#+end_run

#+begin_stdout
...
issuer=C = US, O = Let's Encrypt, CN = R10
...
#+end_stdout

 * If the issuer is =Let's Encrypt=, then the certificate is valid ✅.
 * If the issuer is =TRAEFIK DEFAULT CERT=, then there is some kind of
   problem 💥, and you will need to inspect the logs.


**** View the logs

It may be necessary to inspect the applicaiton logs, which you can do
so as follows:

#+begin_run
d make whoami logs
#+end_run

To check the Traefik logs, do similar:

#+begin_run
d make traefik logs
#+end_run

* Set up sentry Droplet
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: set-up-cloud-sentry
:EXPORT_HUGO_WEIGHT: 300
:END:
** Set up sentry Droplet
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 301
:END:
#+attr_shortcode: :depth 999
[[/img/portable-docker/flight.webp]]

#+begin_index
index
#+end_index
** Launch DigitalOcean droplet
:PROPERTIES:
:EXPORT_FILE_NAME: launch-digitalocean-droplet
:EXPORT_HUGO_WEIGHT: 310
:END:

**** Set up your SSH key on DigitalOcean

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 - Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 - Click =Settings= in the menu.
 - Click on the =Security= tab.
 - Click on the =Add SSH Key= button.
 - Paste your public SSH key into the box. (copy the contents of =~/.ssh/id_ed25519.pub=.)
 - Enter a key name, I recommend this be the same as the hostname of
   your raspberry pi.
 - Finish adding the key, click =Add SSH Key=.
#+end_notice

**** Create a DigitalOcean firewall template

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Firewalls= tab.
 * Click =Create Firewall=.
 * Enter the name, e.g., =ssh-web-https-wireguard=.
 * Enter the following rules:
   * SSH:
     * Type: =SSH=
     * Protocol: =TCP=
     * Port Range: =22=
     * Sources: All IPv4, All IPv6, or a specific static IP address if
       you want to be more secure.
   * HTTP:
     * Type: =HTTP=
     * Protocol: =TCP=
     * Port Range: =80=
     * Sources: All IPv4, All IPv6.
   * HTTPS:
     * Type: =HTTP=
     * Protocol: =TCP=
     * Port Range: =443=
     * Sources: All IPv4, All IPv6.
   * WireGuard VPN:
     * Type: =Custom=
     * Protocol: =UDP=
     * Port Range: =51820=
     * Sources: All IPv4, All IPv6.
   * ICMP:
     * /Optional/ to allow ping response
     * Type: ICMP
  * Click =Create Firewall=.
#+end_notice

**** Create the DigitalOcean droplet

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Droplets= in the menu.
 * Click =Create Droplet=.
 * Choose a Region (e.g., New York), where the droplet will be created.
 * Underneath the heading =Choose an image=, choose =Debian= (select
   the latest version).
 * Choose a droplet size. For a wireguard proxy by itself, 1GB should
   be fine. 2GB RAM and 50GB disk recommended for medium size
   production installs with some apps installed on the droplet itself.
   (It is also tested working on as little as 512MB ram,
   [[https://blog.rymcg.tech/blog/linux/zram/][if you enable zram]]
   and/or create a 1GB swapfile. Do not abuse swap space like this in
   production! However I think its fine for development use, but you
   may occasionally run into low memory issues if less than 1GB.)
 * Select the SSH key uploaded from the pi user to use as the root
   user on the droplet.
 * Set the hostname for the docker server. The name should be short
   and typeable, as it will become a part of the canononical service
   URLs. For this example, we choose =sentry=.
 * Verify everything's correct, and then click =Create Dropet=.
#+end_notice

**** Apply the DigitalOcean droplet firewall

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Find the firewall template you created, and click it.
 * Click on the firewall's =Droplets= tab.
 * Click =Add Droplets= and search for the droplet you created and select it.
 * Click =Add Droplet= to add the firewall to the droplet.
#+end_notice

**** Create wildcard DNS records for the droplet

#+attr_shortcode: :style info :title How to do this in the DigitalOcean cloud console
#+begin_notice
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Domains= tab.
 * Find the domain you created earlier, and click it.
 * Create an =A= record for the sentry:
   * Hostname: enter the subdomain name without the domain part (e.g.,
     =sentry=, the name of your docker server, without the
     =.example.com= suffix).
   * Will direct to: select the droplet you created from the list.
   * Click =Create Record=.
 * Create another =A= record, for the wildcard of the sentry:
   * Hostname: enter the same name as before but prepend =*.= in front
     of it (e.g., if the server is named =sentry=, create a record for
     =*.sentry=, without the =.example.com= suffix).
   * Will direct to: select the same droplet as before.
   * Click =Create Record=.
 * Create another =A= record, for the Raspberry Pi:
   * Hostname: e.g., =pi5.example.com=.
   * Will direct to to: select the same droplet as before.
   * Click =Create Record=.
 * Create another =A= record, for the wildcard of the Raspberry Pi:
   * Hostname: e.g., =*.pi5.example.com=.
   * Will direct to to: select the same droplet as before.
   * Click =Create Record=.
 * Create any more =A= records that you may need.
#+end_notice

#+attr_shortcode: :style secondary :title Test DNS
#+begin_notice
Test that your wildcard record actually works. Use the =dig= command
(For Debian/Ubuntu install the =dnsutils= package. For Arch Linux
install =bind-tools=. For Fedora install =bind-utils=.)

Pick some random subdomain off your domain:

#+begin_run
dig laksdflkweieri.sentry.example.com
#+end_run

#+begin_stdout
;; ANSWER SECTION:
laksdflkweieri.sentry.example.com.    3600    IN      A       153.114.12.78
#+end_stdout

Since you created the wildcard record for =*.sentry.example.com= dig
should return your Docker server's IP address in the =ANSWER SECTION=
of the output. You can test all your other records the same way.

If you run into DNS caching problems, verify with the source DNS
server directly:

#+begin_run
dig @ns1.digitalocean.com laksdflkweieri.sentry.example.com
#+end_run
#+end_notice

**** Next steps

 * Install Docker
 * Configure VPN

** Configure the droplet on the Pi
:PROPERTIES:
:EXPORT_FILE_NAME: set-up-docker-context
:EXPORT_HUGO_WEIGHT: 320
:END:

You now need to be able to control the droplet's =root= user from the
 Raspberry Pi's =pi= user. Create a new SSH config entry for the
 sentry (replace =sentry.example.com= with your own droplet's DNS
 name):

[[/img/portable-docker/configure.webp]]
 
*** Append to the SSH config on the Pi
 
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
cat &lt;&lt;EOF &gt&gt ~/.ssh/config
Host sentry
    User root
    Hostname sentry.example.com
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
EOF
#+end_run

*** Test the connection from the Pi to the sentry
#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
ssh sentry whoami
#+end_run

The first time you connect, you must confirm the host fingerprint (type =yes=):

#+begin_stdout
The authenticity of host 'sentry' can't be established.
ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added 'pi5' (ED25519) to the list of known hosts.
#+end_stdout

On the final line, it will print the output of the command you
requested, which should print the username =root= :

#+begin_stdout
root
#+end_stdout

*** Create a new Docker context for the sentry

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context new
#+end_run

#+begin_stdout
? This command can help create a new SSH config and Docker context. Proceed? (Y/n) y 

? You must specify the SSH config entry to use  
> I already have an SSH host entry in ~/.ssh/config that I want to use
  I want to make a new SSH host entry in ~/.ssh/config

? Choose an existing SSH Host config  
  pi
> sentry

> Do you want to switch to the new sentry context now? Yes
#+end_stdout

*** Install Docker on the sentry

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d install-docker
#+end_run

#+begin_stdout
? This will install Docker on the host of your remote Docker context.. Proceed? Yes
#+end_stdout

*** Test the docker context is functional

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
docker info | grep Context
#+end_run

#+begin_stdout
 Context:    sentry
#+end_stdout

#+attr_shortcode: :title Switch between Docker contexts :style info
#+begin_notice
You should now have two configured Docker contexts on your Pi:
 * =pi=
 * =sentry=

You can switch between these two contexts using =d context=. The
currently selected context specifies which Docker server is currently
being operated on.
#+end_notice

** Configure d.rymcg.tech for the sentry
:PROPERTIES:
:EXPORT_FILE_NAME: configure-d-rymcg-tech-for-sentry
:EXPORT_HUGO_WEIGHT: 325
:END:

*** Ensure you use the correct Docker context

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context use sentry
#+end_run

*** Run the main config

The main config must be run for each new context you create:

#+begin_stdout
> This will make a configuration for the current docker context (sentry). Proceed? Yes

ROOT_DOMAIN: Enter the root domain for this context (e.g., d.example.com)
: sentry.example.com
#+end_stdout

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make - config
#+end_run

*** Insatall Traefik

This is a very similar process as when you installed Traefik on the
Raspberry Pi:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Create the traefik user:

#+begin_stdout
? Traefik Configuration:  
> Traefik user
#+end_stdout

Configure ACME:

#+begin_stdout
? Traefik TLS config:  
  Configure certificate authorities (CA)
> Configure ACME (Let's Encrypt or Step-CA)
  Configure TLS certificates (make certs)
#+end_stdout

Choose Let's Encrypt:

#+begin_stdout
? Which ACME provider do you want to use?  
> Let's Encrypt (ACME)
  Step-CA (ACME)
  Disable ACME
  Cancel / Go back
#+end_stdout

Choose the Production environment:

#+begin_stdout
? Which LE environment do you want to use?  
> Production (recommended!)
  Staging (untrusted / testing)
#+end_stdout

Choose the DNS-01 challenge type:

#+begin_stdout
? Which type of ACME challenge should be used?  
  TLS-ALPN-01 (default for public servers, easy, but no wildcard certs)
> DNS-01 (requires API key, but good behind firewalls, and allows wildcard certs)
#+end_stdout

Skip entering an email unless you want to.

Enter the LEGO provider code:

#+begin_stdout
Find the provider code of your supported DNS provider here:
https://go-acme.github.io/lego/dns/#dns-providers

TRAEFIK_ACME_DNS_PROVIDER: Enter the LEGO code for your DNS Provider (e.g., digitalocean)
: digitalocean
#+end_stdout

Enter the variable /name/ literal DO_AUTH_TOKEN:

#+begin_stdout
# For DigitalOcean, literally enter DO_AUTH_TOKEN here.
TRAEFIK_ACME_DNS_VARNAME_1: Enter the 1st DNS provider variable name (e.g., DO_AUTH_TOKEN)
: DO_AUTH_TOKEN
TRAEFIK_ACME_DNS_VARNAME_2: Enter the 2nd DNS provider variable name (or leave blank)
: 
#+end_stdout

Enter a blank for the second var name, because there isn't one.

Now enter the variable /value/ for DO_AUTH_TOKEN (this should actually
be the secret [[https://cloud.digitalocean.com/account/api/tokens/new][personal access token that you generate on DigitalOcean]]):
#+begin_stdout
Now to enter the values for the custom DNS API variables:
DO_AUTH_TOKEN: Enter the value for DO_AUTH_TOKEN (e.g., your-actual-digitalocean-token-here)
: dop_v1_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#+end_stdout

Create a new TLS certificate:

#+begin_stdout
? Traefik TLS config:  
  Configure certificate authorities (CA)
  Configure ACME (Let's Encrypt or Step-CA)
> Configure TLS certificates (make certs)

? Configure Traefik TLS certificates  
  Manage all certificates.
> Create a new certificate.
  Done / Go back

Enter the main domain (CN) for this certificate (e.g., `d.rymcg.tech` or `*.d.rymcg.tech`)
: sentry.example.com

Now enter additional domains (SANS), one per line:
Enter a secondary domain (enter blank to skip)
: *.sentry.example.com
Enter a secondary domain (enter blank to skip)
: 

Main domain:
 sentry.example.com
Secondary (SANS) domains:
 *.sentry.example.com
#+end_stdout

*** Install Traefik

Press =ESC= three times to go back to the main menu.

Install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

When done, press =ESC= to quit the Traefik config program.

*** Install whoami

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make whoami config
#+end_run

#+begin_stdout
WHOAMI_TRAEFIK_HOST: Enter the whoami domain name (e.g., whoami.example.com)
: whoami.sentry.example.com

? Do you want to enable sentry authentication in front of this app (effectively making the entire site private)?
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)
#+end_stdout


#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make whoami install
#+end_run

#+attr_shortcode: :style info :title Whoami on the sentry
#+begin_notice
This instance of whoami runs on the droplet, and it is only to test
the connectivity of the public droplet itself. We still have not yet
exposed the whoami running on the Raspberry Pi publicly.
#+end_notice


*** Wait a few minutes for the TLS certificate to generate

*** Test the whoami instance

You can open the page in =w3m=:

#+begin_run
d make whoami open
#+end_run

Or test it with curl:

#+begin_run
curl https:://whoami.sentry.example.com
#+end_run

Note that if the TLS certificate has not been issued yet, you will get
this error from curl (and a similar error in =w3m=):

#+begin_stdout
curl: (60) SSL certificate problem: self-signed certificate
More details here: https://curl.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
#+end_stdout

Simply wait a bit longer for the TLS cert to issue, or check the logs
for errors (=d make traefik logs service=traefik=). You can also tell
curl to ignore the error:

#+begin_run
## This is insecure, but fine for testing:
curl -k https://whoami.sentry.example.com
#+end_run

A valid whoami response page looks like similar to this:

#+begin_stdout
Name: default
Hostname: 52a9750ecaa4
IP: 127.0.0.1
IP: ::1
IP: 172.19.0.2
RemoteAddr: 172.19.0.1:56082
GET / HTTP/1.1
Host: whoami.sentry.example.com
User-Agent: curl/7.88.1
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: X.X.X.X
X-Forwarded-Host: whoami.sentry.example.com
X-Forwarded-Port: 443
X-Forwarded-Proto: https
X-Forwarded-Server: sentry
X-Real-Ip: X.X.X.X
#+end_stdout

*** Next steps 

 * Configure the WireGuard VPN

* Configure WireGuard VPN
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: configure-wireguard-tunnel
:EXPORT_HUGO_WEIGHT: 400
:END:

** Configure WireGuard VPN
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 401
:END:
#+attr_shortcode: :depth 999

[[/img/portable-docker/tunnel.webp]]

#+begin_index
index
#+end_index
** Configure sentry wireguard server
:PROPERTIES:
:EXPORT_FILE_NAME: configure-sentry-wireguard-server
:EXPORT_HUGO_WEIGHT: 410
:END:

[[/img/portable-docker/dragon.webp]]

*** Ensure you use the correct context

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context use sentry
#+end_run

*** Reconfigure Traefik to enable WireGuard server

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
  Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
> Configure wireguard VPN

? Should this Traefik instance connect to a wireguard VPN?  
  No, Traefik should use the host network directly.
> Yes, and this Traefik instance should start the wireguard server.
  Yes, but this Traefik instance needs credentials to connect to an outside VPN.

? Should Traefik bind itself exclusively to the VPN interface?  
> No, Traefik should work on all interfaces (including the VPN).
  Yes, Traefik should only listen on the VPN interface.

TRAEFIK_VPN_HOST: Enter the public Traefik VPN hostname (e.g., vpn.example.com)
: sentry.example.com
TRAEFIK_VPN_SUBNET: Enter the Traefik VPN private subnet (no mask) (e.g., 10.13.16.0)
: 10.13.16.0
TRAEFIK_VPN_ADDRESS: Enter the Traefik VPN private IP address (e.g., 10.13.16.1)
: 10.13.16.1
TRAEFIK_VPN_PORT: Enter the Traefik VPN TCP port number (e.g., 51820)
: 51820
Enter the Traefik VPN peers list
: pi
#+end_stdout

Press =ESC= three times to back out of the main menu and quit the
program.

*** Reconfigure Traefik to add a Layer 7 route to the Raspberry Pi

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

> Do you want to enable the layer 7 TLS proxy? Yes

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: whoami.pi5.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443
##
## See https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint              Destination_address  Destination_port  Proxy_protocol
----------              -------------------  ----------------  --------------
whoami.pi5.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= multiple times to back out to the main menu. On the main
menu, select =Install=, to re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

*** Find the wireguard peer config

You can check the wireguard service is now started:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik show-wireguard-peers
#+end_run

#+begin_stdout
## /config/peer_pi/peer_pi.conf
[Interface]
Address = 10.13.16.2
PrivateKey = 2E1vQHCS5JuaoRrt21GO0bYVrafOhplrGNFqoFBivEY=
ListenPort = 51820
DNS = 10.13.16.1

[Peer]
PublicKey = AZiNh/5sk71QTy6Rk0ygzIUsSGAX8/s3EeGN6lT9oj0=
PresharedKey = tEIW8FuxR6I+Qu79bORatbD+JgNPeigNvc9V18f7to8=
Endpoint = sentry.example.com:51820
AllowedIPs = 10.13.16.0/24
#+end_stdout

Copy the output you see into a tempory buffer / notepad, you will need
to copy this information in the next chapter.

** Configure Raspberry Pi WireGuard client
:PROPERTIES:
:EXPORT_FILE_NAME: configure-raspberry-pi-wireguard-client
:EXPORT_HUGO_WEIGHT: 420
:END:

[[/img/portable-docker/castle.webp]]

*** Ensure you use the correct Docker context

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context use pi
#+end_run

*** Reconfigure Traefik to enable WireGuard client

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
  Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
> Configure wireguard VPN

? Should this Traefik instance connect to a wireguard VPN?  
  No, Traefik should use the host network directly.
  Yes, and this Traefik instance should start the wireguard server.
> Yes, but this Traefik instance needs credentials to connect to an outside VPN.

? Should Traefik bind itself exclusively to the VPN interface?  
> No, Traefik should work on all host interfaces (including the VPN).
  Yes, Traefik should only listen on the VPN interface.

TRAEFIK_VPN_CLIENT_INTERFACE_ADDRESS: Enter the wireguard client Interface Address (e.g., 10.13.16.2)
: 10.13.16.2
TRAEFIK_VPN_CLIENT_INTERFACE_PRIVATE_KEY: Enter the wireguard PrivateKey (ends with =)
: 2E1vQHCS5JuaoRrt21GO0bYVrafOhplrGNFqoFBivEY=
TRAEFIK_VPN_CLIENT_INTERFACE_LISTEN_PORT: Enter the wireguard listen port (e.g., 51820)
: 51820
TRAEFIK_VPN_CLIENT_PEER_PUBLIC_KEY: Enter the Peer PublicKey (ends with =)
: AZiNh/5sk71QTy6Rk0ygzIUsSGAX8/s3EeGN6lT9oj0=
TRAEFIK_VPN_CLIENT_PEER_PRESHARED_KEY: Enter the Peer PresharedKey (ends with =)
: tEIW8FuxR6I+Qu79bORatbD+JgNPeigNvc9V18f7to8=
TRAEFIK_VPN_CLIENT_PEER_ENDPOINT: Enter the Peer Endpoint (host:port)
: sentry.example.com:51820
TRAEFIK_VPN_CLIENT_PEER_ALLOWED_IPS: Enter the Peer AllowedIPs (e.g., 10.13.16.1/32)
: 10.13.16.1/32
#+end_stdout

*** Reinstall Traefik

Press =ESC= twice to go back to the main menu, then re-install:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

Once reinstalled, press =ESC= to quit the config tool.

*** Test VPN connectivity

Check the logs:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik logs service=wireguard
#+end_run

#+begin_stdout
wireguard-client-1  | 2024-09-28T08:42:09.445201647Z **** All tunnels are now active ****
#+end_stdout

Enter the wireguard client shell to test networking parameters:

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make traefik shell service=wireguard-client
#+end_run

Show the connected wireguard peers:

#+attr_shortcode: :title Run this in the WireGuard Client shell :style info
#+begin_run
wg
#+end_run

#+attr_shortcode: :title Look for the last handshake time :style info
#+begin_notice
The output of =wg= should show the peer and the =latest handshake=
time, for example:

: latest handshake: 45 seconds ago

If you do not see a handshake time, then there is some kind of problem
connecting to the WireGuard server that you need to resolve.
#+end_notice

Ping the WireGuard server (=10.13.16.1=):

#+attr_shortcode: :title Run this in the WireGuard Client shell :style info
#+begin_run
ping -c3 10.13.16.1
#+end_run

When you are done using the shell press =Ctrl-D= or type =exit= to
quit.

*** Check that whoami is available publicly

In the last chapter you created a layer 7 route for the URL
=https://whoami.pi5.example.com=. Now that your wireguard connection
is active on both ends, this service should now be available publicly.

* Install web services
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: install-web-services
:EXPORT_HUGO_WEIGHT: 500
:END:
** Install web services
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 501
:END:

[[/img/portable-docker/surf.webp]]

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index
** Immich
:PROPERTIES:
:EXPORT_FILE_NAME: immich
:EXPORT_HUGO_WEIGHT: 510
:END:

*** Configure Immich

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context use pi

d make immich config
#+end_run


#+begin_stdout
IMMICH_TRAEFIK_HOST: Enter the Immich domain name (e.g., immich.example.com)
: immich.pi5.example.com

? Do you want to enable sentry authentication in front of this app (effectively making the entire site private)?
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)

? Select the hardware acceleration to use for machine learning
> CPU
  ...

? Select the hardware acceleration to use for transcoding
> CPU
  ...

? Select whether you want Immich to upload images to a bind mount on the host or to a named Docker volume  
  bind mount
> Docker volume
#+end_stdout

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make immich install wait
#+end_run

Wait for the services to start and report themselves as healthy:

#+begin_stdout
Waiting until all services are started and become healthy ...
All services healthy.
#+end_stdout

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context use sentry

d make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: immich.pi5.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint              Destination_address  Destination_port  Proxy_protocol
----------              -------------------  ----------------  --------------
immich.pi5.example.com  10.13.16.2           443               2
whoami.pi5.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.


*** Finish

The app is now deployed at the URL you configured: =https://immich.pi5.example.com=

#+attr_shortcode: :title Immediately secure the admin account :style warning
#+begin_notice
You should immediately open the URL in your web browser:
=https://immich.pi5.example.com= and complete the initial
configuration to secure the admin user account.
#+end_notice

** Yourls
:PROPERTIES:
:EXPORT_FILE_NAME: yourls
:EXPORT_HUGO_WEIGHT: 520
:END:

*** Configure Yourls

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context use pi

d make yourls config
#+end_run

Follow the prompts to configure the domain name and admin user
authentication.

#+begin_stdout
YOURLS_TRAEFIK_HOST: Enter the YOURLS domain name (e.g., yourls.example.com)
: yourls.pi5.forwarding.network

? Do you want to enable sentry authentication in front of this app (effectively making the entire site private)?
> No
  Yes, with HTTP Basic Authentication
  Yes, with Oauth2
  Yes, with Mutual TLS (mTLS)

YOURLS_USER: Enter the admin username for your YOURLS instance
: admin
YOURLS_PASS: Enter the password for 'admin'
: 528e0e36fc170 
#+end_stdout

Choose your own a secure passphrase!

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d make yourls install wait
#+end_run

Wait for the services to start and report themselves as healthy:

#+begin_stdout
Waiting until all services are started and become healthy ...
All services healthy.
#+end_stdout

*** Add a new route on the sentry (droplet)

#+attr_shortcode: :title Run this on the Raspberry Pi :style secondary
#+begin_run
d context use sentry

d make traefik config
#+end_run

#+begin_stdout
? Traefik:  
> Config
  Install (make install)
  Admin
  Exit (ESC)

? Traefik Configuration:  
^ Entrypoints (including dashboard)
  TLS certificates and authorities
  Middleware (including sentry auth)
> Advanced Routing (Layer 7 / Layer 4 / WireGuard)
  Error page template
  Logging level
  Access logs

? Traefik routes  
> Configure layer 7 TLS proxy
  Configure layer 4 TCP/UDP proxy
  Configure wireguard VPN

? Layer 7 TLS Proxy:  
  List layer 7 ingress routes
> Add new layer 7 ingress route
  Remove layer 7 ingress routes
  Disable layer 7 TLS Proxy

Enter the public domain (SNI) for the route:
: yourls.pi5.example.com

Enter the destination IP address to forward to:
: 10.13.16.2

Enter the destination TCP port to forward to:
: 443

> Do you want to enable Proxy Protocol for this route? Yes

## Layer 7 TLS Proxy is ENABLED.
## Configured Layer 7 Routes:
Entrypoint              Destination_address  Destination_port  Proxy_protocol
----------              -------------------  ----------------  --------------
yourls.pi5.example.com  10.13.16.2           443               2
#+end_stdout

Press =ESC= three times to go back to the main menu, and re-install Traefik:

#+begin_stdout
? Traefik:  
  Config
> Install (make install)
  Admin
  Exit (ESC)
#+end_stdout

After installation, press =ESC= to quit the config tool.

*** Finish

#+attr_shortcode: :title Immediately secure the admin account :style warning
#+begin_notice
You should immediately open the URL in your web browser:
=https://yourls.pi5.example.com/admin= and complete the initial
configuration to finsh installation.
#+end_notice

