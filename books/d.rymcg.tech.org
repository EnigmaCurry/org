#+hugo_base_dir: ../hugo
#+hugo_section: /d.rymcg.tech
#+hugo_weight: auto
#+STARTUP: align

* Self-hosting Docker with d.rymcg.tech
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :linkTitle Self-hosting Docker
:EXPORT_HUGO_WEIGHT: 200
:END:

This book describes how to get started with self-hosting your own
Docker server, using the tools provided by [[https://d.rymcg.tech][d.rymcg.tech]].

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: introduction
:END:


** What is self-hosting?

[[https://en.wikipedia.org/wiki/Self-hosting_(web_services)][Self-hosting]] is described on Wikipedia as the following:

#+BEGIN_QUOTE
Self-hosting is the practice of running and maintaining a website or
service using a private web server, instead of using a service outside
of someone's own control. Self-hosting allows users to have more
control over their data, privacy, and computing infrastructure, as
well as potentially saving costs and improving skills.
#+END_QUOTE

You can apply self-hosting a little bit, or a lot. On the one hand,
you could post all of your content on Facebook (obviously, this is
/not/ self-hosting), and on the other hand you could build all your
servers yourself, from parts, and run them in your basement, on your
own network, bootstrapping everything. For most people though,
self-hosting means to use cloud computing, using a generic Linux VPS
(virtual private server), installing and operating open-source
software (or software that you built), but still letting the cloud
provider handle the hardware and network side of things.

Demarcate your own level of abstraction. Test that your abstraction
works in a generic way, portable to any other provider at the same
level of abstraction. Try running it entirely at home, at least for
development purposes. Don't get locked into a single vendor. Use open
source software, or software you built yourself. This is self-hosting.

** What is Docker?

[[https://www.docker.com/][Docker]] is a software platform for running containers on Linux.
Containers let you install and run software in an isolated and generic
way. It solves the problems of [[https://en.wikipedia.org/wiki/Dependency_hell]["dependency hell"]] and [[https://donthitsave.com/comic/2016/07/15/it-works-on-my-computer]["But it works on
my computer!"]], for all Linux distributions. Containers are created
from images that include /all/ of their dependencies, including the
operating system to support it. The only thing a container does /not/
include, is the Linux kernel, which is shared from the host with all
the containers running on the same host. This abstraction makes it
work the same way on all computers, regardless of Linux distribution
(assuming an up to date kernel). Docker maintains persistent volumes
for each container, so that they may mount it into their own virtual
filesystem, and thus storing all of its important data into the
volume. You may upgrade, or even delete these containers, and as long
as you keep the volume(s), you can simply reprovision the same images
(even on new hardware), and the containers will load all of its same
data from before.

** What is a container?

Although it is possible to run desktop software inside of a Docker
container, 99% of the time a Docker container is created to run a
/service/, assumed to run on a server, assumed to be serving remote
clients. Generally, a container is designed only to run a single
service. For example: /A/ web server, /a/ chat server, /a/ DNS server,
/a/ python server you write, etc. Multiple instances of the same image
can run as separate containers, and they can even share volumes, if
you want (though generally not).

Containers are related to a different technology that you might
already be familar with: Virtual Machines. However, there are several
fundamental differences between containers and virtual machines, and
so it is useful to describe them here as a comparison:

| Feature           | Container                                                                                                                  | Virtual Machine                                                       |
|-------------------+----------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------|
| Kernel            | Containers share a kernel with the host                                                                                    | VMs runs their own kernel                                             |
| Hardware          | Containers share hardware with the host, but with the addition of a permissions model to access it                         | VMs use hardware virtualization features                              |
| Memory            | Containers share memory with the host                                                                                      | VMs use a fixed size virtual hardware memory space                    |
| Disk              | Containers share storage system with the host (volumes live under =/var/lib/docker/= by default)                           | VMs use a fixed size (but expandable) virtual hard disk image         |
| Network           | Containers support Host level networking, or can do NAT                                                                    | NAT or bridge network, not host level                                 |
| Execution model   | Containers are just a regular Linux processes, run under a given user account                                              | VMs run their own kernel and init (systemd)                           |
| Init process      | Containers don't need an init process, Docker runs the containers process (CMD) directly                                   | VMs run their own kernel and init (systemd)                           |
| Process isolation | Containers run as as regular Linux processes, which have a capabilities system to limit privileges                         | VMs are like a separate machine, and a have a separate process space  |
| Root filesystem   | Containers inherit a root filesystem from their image, which contain all the application files, and the OS, minus a kernel | VMs are run from (linked) virtual disk images                         |
| Volumes           | Containers automatically mount volumes provided from Docker. Docker maintains the lifecycle of these volumes.              | VMs can have multiple virtual disks, or manually mount remote volumes |

Containerization uses features of the Linux kernel, (specifically,
namespaces and cgroups). For the purposes of this book, the term
"container" will always imply that it is running on a Linux host; it
is inseparable from the host kernel, and it can't work without it!
(You may be aware that you can install a product called "Docker
Desktop" on Windows or MacOS. This product installs a Linux virtual
machine on your host OS and runs Docker inside it, and then it
installs the docker client on the host OS, so it appears seamless.)

In a general context, there are other OS containers, like Windows
containers, however they are on the fringe, and will not be discussed
in this book. Containers imply Linux.

Docker is a good platform to pick for self-hosting containers, because
it's a mature open source project, and it works on virtually any Linux
computer or VPS. Docker is server focussed, and therefore ideal for
self-hosting. Docker is easy to get started with, even if you're a
beginner.

** What is Docker Compose?

Docker uses a client-server API pattern of control. You install the
Docker daemon on a server machine, and this machine is called the
Docker Host. Usually you interact with the API through the command
line =docker= tool. Docker provides primitive commands for running
single containers directly, with =docker run=. However, for larger
projects that need more than one container (eg. a webserver + a
database) and need to be able to talk to one another, =docker run= is
not the best tool to use.

=docker compose= is a command that operates your containers from a
project level abstraction. =docker compose= lets you define all the
containers and volumes that you need for a given project, in a
declarative way, in a =docker-compose.yaml= file.

With =docker compose= you can start/stop/delete all the project
containers together, as a single unit.

** What is d.rymcg.tech?

[[https://github.com/EnigmaCurry/d.rymcg.tech][d.rymcg.tech]] is a collection of docker compose projects for various
open source server applications, with an integrated frontend proxy
with [[https://doc.traefik.io/traefik/][Traefik Proxy]], including integrated authentication (HTTP Basic
and/or OAuth2) and IP address filtering, and is a framework for
packaging your own applications, and managing several container
instances at the same time, with seprate configs in .env files.

d.rymcg.tech focuses on the config rules of the [[https://12factor.net/config][12-factor principle]].
All of the configuration for a container should be specified as
environment variables, which Docker loads from a standard =.env= file.
All of the data for a container should live inside a [[https://docs.docker.com/storage/volumes/][Docker Volume]]
(not a bind mount), and so the lifecycle of the volume is maintained
by Docker directly.

d.rymcg.tech is designed to work on a workstation, not a server. The
Docker client-server API is accessed remotely over SSH. Only your
personal workstation should be used to issue =docker= commands that
affect the server, they should not be run on the server itself. It's
important to keep the server as bare bones and hands off as possible.
The server's only job is to run containers, configured from a remote
workstation. Once the server is setup, you won't normally need to even
login to the server console ever again. By controlling the server from
your workstation, you can manage the server in a clean fashion. You
can even create a new server from scratch, in no time. All of the
important configuration stays on your workstation (and are backed up
in a git repository).


* Register a domain name
:PROPERTIES:
:EXPORT_FILE_NAME: register-a-domain-name
:END:

To host a web service, one of the first things you will need is to
register your domain name. This will be the domain name used for all
your service links, and it is what your users will need to type into
their browsers to visit your pages.

Domain names a scarce resource. Because of their scarcity, you must
pay for your domain registrations, doing so in 1 year increments. If
domains were free, all the good ones would be taken by now, but
because they cost money, there are still some good enough ones left to
be had. In return for your fee, you receive exclusive use of your
domain name for the period that you paid for. You can pre-pay for
several years in advance, or for just one year at a time. You must
remember to renew your domains for every year, lest they expire and no
longer resolve to your services, and you lose control of the domain,
possibly forever.

** Domain names for private servers

If your Docker server won't be a public server, (eg. running a private
Docker server at home), it is still recommended that you use a valid
internet domain name, because you will still need one in order to
create valid TLS certificates from [[https://letsencrypt.org/][Let's Encrypt]]. However, having
working TLS is not /required/ for development purposes (but certainly
nice to have!), so you may choose to make up your own fake domain name
instead, and forgo TLS. In either case, you will still need to setup
DNS, and this is explained in the next section.

** Register an Internet domain name

You can buy (rent) a domain name from lots of places. For
documentation purposes, we will use [[https://www.gandi.net][Gandi.net]], but these instructions
will be similar regardless of the domain provider you pick.

 * Sign up for an account at [[https://www.gandi.net/][Gandi.net]]
 * Once signed in, from your dashboard, click =Register=.
 * Search for any domain name you like, eg. =your-name.com=.
 * Add your domain to the shopping cart, go to checkout, and complete
   your purchase.
 * Once you have purchased the domain, it should show up in your
   =Dashboard=, under the =Domain= tab.
 * Leave this browser tab open, you will return to it in the next
   chapter.

* Setup public DNS
:PROPERTIES:
:EXPORT_FILE_NAME: setup-dns
:END:

A DNS server maps your domain (and subdomain) names to the various IP
addresses of your servers. DNS is required for your users to be able
to type your domain name =prod.example.com= and have it resolve to the
IP address that is required to contact your Docker server.

Now that you have registered a domain name, you need to tell your
registrar where your DNS server is. Usually you will use the DNS
server that your cloud provider gives you, but you may choose any DNS
provider you like. If you are creating a private server, you may still
want to choose a public DNS server, but using private IP addresses
ranges for the records. You can also setup a local/private DNS server,
but this will be discussed later.

For documentation purposes, this chapter will assume you are using
Gandi.net as your domain registrar, and that you want to use
DigitalOcean.com as your domain's public DNS server, but these
instructions will be similar regardless of the providers you pick.

** Configure your domain's DNS server on Gandi.net

 * Login to your [[https://admin.gandi.net][gandi.net]] dashboard.
 * Click the =Domain= tab.
 * Find your domain name in the list and click on it.
 * Click on the =Nameservers= tab.
 * Click on the edit button to create new =External nameservers=.
 * Delete all existing nameservers that may exist.
 * Add the following nameservers, specific to DigitalOcean:
   
   * =ns1.digitalocean.com=
   * =ns2.digitalocean.com=
   * =ns3.digitalocean.com=

Once changed, you can verify the setting from your workstation, using
the =whois= command:

: whois your-domain.com

The output shows a report for your domain registration, including the
list of the new nameservers.

** Setup public DNS on DigitalOcean.com

 * Signup for an account at [[https://m.do.co/c/069af06b869e][DigitalOcean]], if you haven't already.
 * Login to the [[https://cloud.digitalocean.com/][cloud console]].
 * Click on the =Networking= tab in the menu.
 * Click on the =Domains= tab.
 * Enter your domain name into the box and click =Add Domain=.

DigitalOcean is now in charge of your DNS for your domain. You will
return to this screen later on, when creating individual subdomain
records for your services.

* Create a Docker server
:PROPERTIES:
:EXPORT_FILE_NAME: docker-server
:END:

The next three chapters will guide you to install Docker, for three
different server scenarios:

 1. A production/staging Docker server on the public Internet (eg.
    DigitalOcean or any other VPS cloud provider).
 2. A production/staging Docker server on a private LAN.
 3. A development Docker server in a local VM.

* Create a public Docker server 
:PROPERTIES:
:EXPORT_FILE_NAME: public-docker-server
:END:

This section will guide you to create your own public Docker server as
a DigitalOcean droplet, however you may also install Docker on any
cloud provider or dedicated host that you prefer.

** Choosing a VPS provider

One of the most basic units of cloud computing is the Virtual Private
Server (VPS). A VPS is a virtual machine that is provisioned by a
cloud service, that you are given full adminstrative control of. You
are given root access to the VPS (running Linux), and you can install
whatever you want. VPS generally come with a dedicated IP address and
have a public internet connection, although some VPS only have NAT,
with dedicated port forwarding.

In this guide you will create a VPS with a DigitalOcean droplet.

You can install Docker on almost any VPS, but some are better than
others. DigitalOcean is a good choice for experimenting, because it is
billed hourly, and because it has an integrated external firewall.
Having an external firewall is one of the most important features to
look for in a hosting provider. Docker maintains its own firewall on
the host level automatically, and so your hands should probably stay
off of it. If you want to reliably block traffic, in addition to the
automatic rules, it must be done on an external/upstream firewall.

** Create a DigitalOcean account and setup your SSH key

If you have not yet setup an SSH key on your workstation, [[file:openssh.org][read the
OpenSSH book]] and do that first.

 * Signup for an account at [[https://m.do.co/c/069af06b869e][DigitalOcean]].
 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Settings= in the menu.
 * Click on the =Security= tab.
 * Click on the =Add SSH Key= button.
 * Paste your public SSH key into the box. (copy your pub key from the
   output of ~ssh-add -L~.)
 * Enter a key name, I recommend this be the name of your workstation
   computer.
 * Finish adding the key, click =Add SSH Key=.

** Create a DigitalOcean firewall template

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Firewalls= tab.
 * Click =Create Firewall=.
 * Enter the name, eg. =basic-docker-public-web=.
 * Enter the following rules:
   * SSH:
     * Type: =SSH=
     * Protocol: =TCP=
     * Port Range: =22=
     * Sources: All IPv4, All IPv6, or a specific static IP address if
       you want to be more secure.
   * HTTP:
     * Type: =HTTP=
     * Protocol: =TCP=
     * Port Range: =80=
     * Sources: All IPv4, All IPv6.
   * HTTPS:
     * Type: =HTTP=
     * Protocol: =TCP=
     * Port Range: =443=
     * Sources: All IPv4, All IPv6.
  * Click =Create Firewall=.
 
** Creating a DigitalOcean droplet for a Docker server

DigitalOcean provides a Docker image with which to create a droplet
(DigitalOcean's name for their own VPS product).

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Droplets= in the menu.
 * Click =Create Droplet=.
 * Choose a Region (eg. New York), where the droplet will be created.
 * Underneath the heading =Choose an image=, select the =Marketplace=
   tab.
 * Find the image called =Docker 2x.x.x= (eg. =23.0.6= or a later
   version)
 * Choose a droplet size. 2GB RAM and 50GB disk recommended for medium
   size production installs. (It is tested working on as little as
   512MB ram, [[https://blog.rymcg.tech/blog/linux/zram/][if you enable zram]] and/or create a 1GB swapfile. Do not
   abuse swap space like this in production! However I think its fine
   for development use, but you may occasionally run into low memory
   issues if less than 1GB.)
 * Optional: Add a block storage device, in order to store your Docker
   volumes. (This is useful to store data separate from the droplet
   lifecycle, or to have a larger amount of storage than the droplet
   size gives you for the root filesystem. If your basic droplet size
   is already sufficient, and you perform regular backups, this might
   not be needed.)
 * Select your SSH key for the root user.
 * Set the hostname for the docker server. The name should be short
   and typeable, as it will become a part of the canononical service
   URLs. For this example, we choose =prod=.
 * Verify everything's correct, and then click =Create Dropet=.

** Apply the DigitalOcean droplet firewall

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Find the firewall template you created, and click it.
 * Click on the firewall's =Droplets= tab.
 * Click =Add Droplets= and search for the droplet you created and select it.
 * Click =Add Droplet= to add the firewall to the droplet.

** Create wildcard DNS records for the droplet

For the purposes of documentation, assume you you own the domain
=example.com= and you have created the Docker server named =prod=. You
should replace =example.com= with your actual domain name, and =prod=
with your actual docker instance name/stage.

 * Login to the [[https://cloud.digitalocean.com/][DigitalOcean cloud console]].
 * Click =Networking= in the menu.
 * Click the =Domains= tab.
 * Find the domain you created earlier, and click it.
 * Create an =A= record:
   * Hostname: enter the subdomain name without the domain part (eg.
     =prod=, the name of your docker server, without the
     =.example.com= suffix).
   * Will direct to: select the droplet you created from the list.
   * Click =Create Record=.
 * Create another =A= record, for the wildcard:
   * Hostname: enter the same name as before but prepend =*.= in front
     of it (eg. if the server is named =prod=, create a record for
     =*.prod=, without the =.example.com= suffix).
   * Will direct to: select the same droplet as before.
   * Click =Create Record=.
 * Optional: create additional records on the root domain. If you
   don't want the docker instance name in the subdomain you give to
   people (eg. =www.prod.example.com=), you could create additional
   (non-wildcard) records on the root domain now (eg.
   =www.example.com=, or even just =example.com=). However, it would
   be wasteful to put a wildcard record on the root domain
   (=*.example.com=) because then the domain could only be used with a
   single Docker instance, therefore all records on the root should be
   non-wildcard, and this means you must add them one by one.

Test that your wildcard record actually works. Use the =dig= command
(For Debian/Ubuntu install the =dnsutils= package. For Arch Linux
install =bind-tools=. For Fedora install =bind-utils=.)

Pick some random subdomain off your domain:

: dig laksdflkweieri.prod.example.com

Since you created the wildcard record for =*.prod.example.com= dig
should return your Docker server's IP address in the =ANSWER SECTION=
of the output. You can test all your other records the same way.

If you run into DNS caching problems, verify with the source DNS
server directly:

: dig @ns1.digitalocean.com laksdflkweieri.prod.example.com

** Setup your local workstation

Edit your SSH config file: =~/.ssh/config= (create it if necessary).
Add the following lines, and change it for your domain name that you
already created the DNS record for:

: Host ssh.prod.example.com
:     User root
:     ControlMaster auto
:     ControlPersist yes
:     ControlPath /tmp/ssh-%u-%r@%h:%p

(The name ssh.prod.example.com should work automatically if you
setup the wildcard DNS entry (*.prod.example.com) created
previously. The ControlMaster, ControlPersist, ControlPath adds SSH
connection multi-plexing, and will make repeated logins/docker
commands faster.)

Now test that you can SSH to your droplet:

ssh ssh.prod.example.com

The first time you login to your droplet, you need to confirm the SSH
pubkey fingerprint; press Enter. Once connected, log out: press Ctrl-D
or type exit and press Enter.
 
* Create a private Docker Server for a LAN
:PROPERTIES:
:EXPORT_FILE_NAME: private-docker-server
:END:

Create a VM

** Setup private DNS

If you chose a fake domain, you can set the DNS record on your local
DNS server. Generally, most LANs already have a local DNS server
install on a home router. You can add your records there. If you don't
have a DNS server, you can install [[https://dnsmasq.org/][dnsmasq]]. dnsmasq can act as DNS
and/or DHCP servers for your LAN.

A dnsmasq entry for the wildcard records would look like this (in
=dnsmasq.conf=):

: # dnsmasq wildcard records for your Docker server (192.168.0.1):
: address=/prod.example.com/192.168.0.1
: address=/.prod.example.com/192.168.0.1

Replace =192.168.0.1= with the ip of your Docker server.

Alternatively, you can edit =/etc/hosts= directly on your workstation,
but it does not support wildcard records, so you would have to specify
each name one by one:

: ## /etc/hosts excerpt for three explicit domains:
: 192.168.0.1 prod.example.com www.prod.example.com test.prod.example.com


* Create a development Docker Server VM
:PROPERTIES:
:EXPORT_FILE_NAME: development-docker-server-vm
:END:

* Create a Docker workstation
:PROPERTIES:
:EXPORT_FILE_NAME: docker-workstation
:END
