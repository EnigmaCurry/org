#+hugo_base_dir: ../hugo
#+hugo_section: /linux-workstation
#+hugo_weight: auto
#+hugo_paired_shortcodes: %notice badge button %children %index run stdout edit math mermaid openapi %env toc
#+STARTUP: align

* Linux Workstation
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 190
:END:

This book describes how I setup a Linux Workstation (on a personal
Desktop or Laptop computer).

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

* Introduction
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: introduction
:END:

** Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 200
:END:

A Linux Workstation is a single user computer that you use as your
primary interface for computing, especially for "work" purposes. At a
bare minimum, a workstation includes a keyboard and a display.
Historically, there has been a hardware distinction between a personal
computer (PC) and a Unix workstation, but ever since the introduction
of Linux, the difference in hardware doesn't really exist anymore, and
any computing device can become a workstation. The only important
distinction for a workstation is the role that it serves, and how
/you/ configure and use it on daily basis.

The role of a workstation is very different than that of a server. A
workstation's only purpose is to serve you, the user, while
interacting with its physical keyboard/mouse/etc interface. A
workstation /is/ usually connected to a network, but only as a client,
not as a server. (Of course, you may bend this rule if you like, to
make your computer a server-workstation or "Sworkstation", but it is
cleaner, and more secure, to use separate machines for these very
different roles.)

This book will describe my preferred method for setting up a brand new
computer for use as a personal workstation. It will also show how to
bend the rules a bit, and create a few virtual machines (VM) for
running local development servers.

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

** Fedora Sway Atomic
:PROPERTIES:
:EXPORT_FILE_NAME: fedora-sway-atomic
:END:

I have tried a great many different Linux distributions over the
years, but I have recently settled on using [[https://fedoraproject.org/atomic-desktops/sway/][Fedora Sway Atomic]] for my
desktop and laptop workstations.

[[https://github.com/swaywm/sway][Sway]] is a minimal tiling window manager for Wayland. It is ideal for
efficient keyboard centric development and for getting out of your
way.

The "Atomic" part refers to [[https://coreos.github.io/rpm-ostree/][rpm-ostree]] which was developed by the
CoreOS team to build an operating system that is built entirely to
support containers. The root file system of the host operating system
is mounted read-only, and the packages are distributed in an image,
rather than installed individually. This makes updating (or rolling
back) the system far easier, and makes for a more stable environment.
There is no need to replace packages one-by-one, you just download the
new image provided by the distro, and then reboot the system to use
it.

The base image includes all the typical things everyone needs:
coreutils, a display manager, web browser, terminal apps etc. However,
the base image is still pretty bare bones. Furthermore, the image is
read-only, so you can't install packages like you can with a more
traditional Linux distro. If you want to install something that isn't
in the base image, you have a few different options:

 * Podman or Docker containers. Since containers use their own image,
   they are separate from the main image, and can be freely created
   and destroyed separately.
 * Flatpak is a type of application container that includes all of its
   dependencies, and it is sandboxed/isolated from the host system,
   therefore they can be installed/managed separately from the base
   image.
 * Use rpm-ostree itself to create a new image *layer*. This extends
   the base layer with extra packages you want to install. This is
   fully supported, but not optimal, as when you upgrade the base
   image, this layer needs to be recreated each time.

I only use a couple of Flatpak apps for a few things. For almost
everything else I use Podman containers via [[https://docs.fedoraproject.org/en-US/fedora-silverblue/toolbox/][toolbox]] and/or [[https://distrobox.it/][distrobox]]
and these can even include graphical applications. Creating your own
[[https://docs.fedoraproject.org/en-US/iot/adding-layered/][rpm-ostree layers]] is to be avoided if possible, but some things don't
like running in containers, so this remains an option.

** Requirements
:PROPERTIES:
:EXPORT_FILE_NAME: requirements
:END:

You will need the following hardware:

 * An x86_64 desktop or laptop computer.
 * A USB drive for copying the .iso installer to.
 * A [[https://solokeys.com/][solokey]] or other FIDO2 compatible hardware authentication key.
   (This is optional, but highly recommended for storing secure shell
   keys, PGP keys, and logging into websites with Webauthn.)

* Install Linux (Fedora Atomic)
:PROPERTIES:
:EXPORT_FILE_NAME: install
:END:

*** Create USB installation media

#+attr_shortcode: :icon download :style primary :href https://fedoraproject.org/atomic-desktops/sway/download
#+begin_button
Download the Fedora Sway Atomic iso image.
#+end_button


Assuming you are temporarily using another Linux workstation, write
the .iso image to a USB drive:

#+begin_run
dd if=Fedora-Sericea-ostree-x86_64-40-1.14.iso \
   of=/dev/sdX bs=10M status=progress conv=sync
#+end_run

#+attr_shortcode: :style info
#+begin_notice
Replace ~/dev/sdX~ with your device name, and double check the =.iso=
filename, it may have changed.
#+end_notice

Boot the target workstation computer using the USB drive. You will
boot into the Anaconda install wizard. Just follow the prompts to
install it, it is exactly the same as any other Fedora / Redhat
install.

Tips:

 * Enable whole disk encryption and choose a secure passphrase.
   Especially for laptop computers that you may travel with, this an
   important thing to do to keep your files safe at rest.
 * Use the entire disk for the install. Dual booting another operating
   system on the same workstation is not considered a safe/secure
   thing to do. If you want to run Windows or play games, use a
   separate computer for that.

Once the installer finishes, reboot, remove the USB, and login to your
new system.

* Upgrading
:PROPERTIES:
:EXPORT_FILE_NAME: upgrading
:END:

As mentioned before, Fedora Atomic is distributed as a full system
image. You can both upgrade the image, as well as rollback the image
(in case you have any issues with the upgrade.)

To upgrade to the latest image:

#+begin_run
sudo rpm-ostree upgrade
#+end_run

Let it finish downloading the new image, and then you must reboot:

#+begin_run
sudo systemctl reboot
#+end_run
The boot manager lists the last several images, which are still
available to choose from. The default is to boot the newly upgraded
image.

The above will /not/ upgrade to a new release version, eg. Fedora 39
to Fedora 40. It will only update the packages for the currently
installed release.

To find the list of all released versions, run :

#+begin_run
ostree remote refs fedora | grep "$(uname -m)/sericea$"
#+end_run

Upgrade to the new release (eg. 40):

#+begin_run
rpm-ostree rebase fedora:fedora/40/x86_64/sericea
#+end_run

Let it finish downloading the new image, and then reboot again.

* Layering packages
:PROPERTIES:
:EXPORT_FILE_NAME: layering-packages
:END:

See the [[https://docs.fedoraproject.org/en-US/iot/add-layered/][Fedora docs for Adding Layered Packages]]. For most packages,
you should not install them this way, but you should prefer installing
them inside of a toolbox / distrobox container instead. On the Fedora
Atomic host, you should install (layer) only those packages that
cannot be run from a container (or you really just want to run them
natively for some reason).

To create efficient layers, *you should try to install everything in
one go*, using as few layers as possible. Here is a list of packages
you might want to add all together as one layer:

#+begin_run
sudo rpm-ostree install qemu-kvm libvirt virt-manager virt-viewer \
     virt-install libvirt-daemon-config-network libvirt-daemon-kvm \
     libguestfs-tools python3-libguestfs virt-top net-tools \
     gvfs-smb gvfs-archive gvfs-nfs gvfs-fuse gvfs-mtp \
     distrobox file-roller thunar-volman
#+end_run

[[https://fedoraproject.org/atomic-desktops/sway/][Fedora Atomic Sway edition (Sericea) already includes a lot of
packages layered on top of the core Fedora Atomic.]] So before you
install new things, check what comes preinstalled.

** Examples of applications you might want to layer

 * File explorer (thunar) plugins for archives and removeable drives.
 * Virtual filesystem plugins (gvfs).
 * Container tools (Distrobox).
 * Virtual Machine tools (Qemu and libvirt).
 * Basic network tools (net-tools arp)

Web browsers are fickle. Although they mostly work inside toolbx
containers just fine, Sericea includes Firefox in its base layer as a
native app, and that seems to work great. However, I have also tested
Chromium inside of a toolbx container without issue. For use cases
where Chromium needs to have native USB access, you might not want to
run it in a container.

** Check the list of layers:

#+begin_run
sudo rpm-ostree status
#+end_run

The top layer should list the =LayeredPackages= in your new layer.

Reboot.

** Reset all layers back to stock

#+attr_shortcode: :style warning
#+begin_notice
This will reset all the layered packages back to the stock image. This
may be useful if you are trying to clean up from lots of testing.

*All package layers will be destroyed!*

Your user home directories (=/var/home/=) and system configuration
(=/etc/=) are not affected.

#+begin_run
sudo rpm-ostree reset
sudo rpm-ostree cleanup -r
#+end_run
#+end_notice


* Config
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: config
:END:

** Config
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:END:

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index

** Sway
:PROPERTIES:
:EXPORT_FILE_NAME: sway
:END:

[[https://github.com/swaywm/sway?tab=readme-ov-file#readme][Sway]] is a reimagining of [[https://i3wm.org/][i3wm]] (X11), rewritten for Wayland. Sway (like
i3wm) is a keyboard centric tiling window manager. Although not a
source fork of i3wm, the configuration and user interface of Sway is
almost identical to that of i3wm.

*** Sway Config

The Fedora Atomic Sway edition includes a default configuration for
Sway. It's pretty nice out of the box, and so if you like it, you can
just use it. However, I use [[https://github.com/enigmacurry/sway-home][my own custom configuration]] that I replace
it with, and you can do the same if you like.

Open the default terminal emulator (foot) with the keyboard shortcut:
=Win+Enter= (hold down the "Windows" key on your keyboard, then
simultaneously press Enter.)

My custom config replaces several of the default configuration files.
So you must first get rid of these files, by renaming them with the
suffix =.orig= for posterity:

#+begin_run
mv ~/.config ~/.config.orig
mv ~/.bashrc ~/.bashrc.orig
mv ~/.bash_profile ~/.bash_profile.orig
#+end_run

Next, install my [[https://github.com/enigmacurry/sway-home][customized sway config repository]] :

#+begin_run
git clone https://github.com/enigmacurry/sway-home \
  ~/git/vendor/enigmacurry/sway-home
#+end_Run

Run the included setup script:

#+begin_run
cd ~/git/vendor/enigmacurry/sway-home
./setup.sh
#+end_run

The =setup.sh= script will make [[https://github.com/EnigmaCurry/sway-home/blob/master/setup.sh#L57-L61][symlinks]] to the repository files from
the same original paths as the files you just moved. It also asks you
some questions to help setup your git profile.

Once you have finished entering the information setup asks for, press
=Win+Shift+E=, and choose Log Out. Log back in, and this will load the
new config files.

*** Setup display resolutions and orientation

Fedora Sway Atomic ships with [[https://git.sr.ht/~emersion/kanshi][kanshi]] for display setup. Kanshi does
not include any GUI for setting it up, so another program called
[[https://github.com/artizirk/wdisplays][wdisplays]] is useful, however it is not included in the base Atomic
distribution, and you will have to install it via [[/linux-workstation/toolbox][toolbox]].

#+attr_shortcode: :title install wdisplays inside of toolbox
#+begin_run
sudo dnf install wdisplays
#+end_run

You can configure all of your displays using the wdisplays GUI
program, however, the configuration will not persist across login
sessions. So what you need to do is set it up how you like it, and
then transfer that information into the Kanshi config file so that it
sets it up the same way everytime you login.

For example, on my test system I have two display port monitors, with
outputs named =DP-3= and =DP-4=. These are shown in wdisplays and I
have set up the size, position, and DPI scaling exactly how I like it:

DP-3:

[[/img/wdisplays1.webp]]

DP-4:

[[/img/wdisplays2.webp]]

Open the Kanshi config file =~/.config/kanshi/config= and copy the
information into the config file:

#+attr_shortcode: :file ~/.config/kanshi/config
#+begin_edit
profile {
   output DP-3 enable mode 2560x1440 position 3840,0 scale 1 transform normal
   output DP-4 enable mode 3840x2160 position 1920,360 scale 2 transform normal
}
#+end_edit

Check out =man 5 kanshi= for more config options. Kanshi is
[[https://github.com/EnigmaCurry/sway-home/blob/9a7af6fbd60a671a7059ba7bd35f35c2ec3cbd1f/config/sway/config.d/autostart_applications#L2][automatically started]] when sway is, so you can test it by logging out
and logging back in.

** Firefox
:PROPERTIES:
:EXPORT_FILE_NAME: firefox
:END:

Fedora Atomic ships with the Firefox browser preinstalled. This
section describes how I like to set it up.

*** Remove clutter

**** Remove =Firefox View=, right click the upper left icon and select =Remove from toolbar=.

[[/img/firefox/firefox-view.webp]]

**** Remove existing bookmarks from bookmark bar, right click each one and select =Delete=.

**** Remove =Pocket=, right click the pocket icon in the upper right toolbar, select =Remove from toolbar=

[[/img/firefox/firefox-pocket.webp]]

**** Remove =Firefox Account= icon, select =Remove from toolbar=

[[/img/firefox/firefox-account.webp]]


*** Firefox Settings

Go into the Firefox settings: click the "hamburger" menu in the top
right toolbar. Select =Settings=.

[[/img/firefox/firefox-settings.webp]]

**** General Settings

***** Select =Open previous windows and tabs=

***** Turn on Dark mode

[[/img/firefox/firefox-general.webp]]

***** Turn off =Recommend extensions as you browse=

***** Turn off =Recommend features as you browse=

[[/img/firefox/firefox-browsing.webp]]

**** Home settings

***** =New Windows and Tabs=

Select =Blank Page= for both new windows and tabs.

[[/img/firefox/firefox-home.webp]]

***** Firefox Home Content

The home content won't show if you set =Blank Page= above, but I go
ahead and turn off all the home stuff anyway.


**** Search Settings

***** Choose a non-Google default search engine, eg. =DuckDuckGo=.

***** Turn off all Search Suggestions

***** Delete all the corporate Search Shortcuts other than your preferred one (eg. DuckDuckGo).

You can select each one and click =Remove= or you can press the Delete
key. Delete Google, Amazon, Bing, eBay, Wikipedia etc.

[[/img/firefox/firefox-search.webp]]


**** Privacy & Security settings

***** Enhanced Tracking Protection, select =Strict=

***** Set =Do Not Track= to =Always=

[[/img/firefox/firefox-privacy-1.webp]]

***** Logins and Passwords

Unselect =Suggest Firefox relay email masks=

Unselect =Show alerts about passwords for breached websites= (You
already use unique passwords for every website, right??)

***** IMPORTANT: select =Use a Primary Password=

[[/img/firefox/firefox-privacy-2a.webp]]

Without setting a primary password, any password that firefox saves
will be **unencrypted**! You must set a primary (master) password, and
you will need to type it in each time you restart your browser, to
unlock the password manager.

***** Address Bar - Firefox Suggest

Unselect =Search engines=

Unselect =Suggestions from the web=

Unselect =Suggestions from sponsors=

[[/img/firefox/firefox-privacy-2b.webp]]

***** Firefox Data Collection and Use

Unselect everything here.

[[/img/firefox/firefox-privacy-3a.webp]]

***** HTTPs-Only mode

Choose =Enable HTTPS-Only Mode in all windows=

[[/img/firefox/firefox-privacy-3b.webp]]


***** DNS over HTTPS

Especially if you use a portable laptop, or connect to various WiFi
access points, you should choose =Max Protection=.

[[/img/firefox/firefox-dns.webp]]

*** Extensions and Themes

From the Settings menu, near the bottom, click =Extensions & Themes=.

**** Themes

Choose a theme you like. For example, click =Dark= and then click =Enable=.

**** Extensions

Go to [[https://addons.mozilla.org][addons.mozilla.org]] and install the following extensions:

[[https://addons.mozilla.org/en-US/firefox/addon/darkreader/][Dark Reader]]

Dark reader makes all sites darker, and you can customize each site by
clicking on the Dark Reader extension in the menu bar.

[[https://addons.mozilla.org/en-US/firefox/addon/ublock-origin][Ublock Origin]]

Disables almost all ads on all websites. There's not much to configure
here, it basically works out of the box. However, you can customize it
per site if you want to enable ads on certain pages.

[[https://addons.mozilla.org/en-US/firefox/addon/noscript][NoScript]]

By default, all sites will have javascript disabled. On each site you
trust, you can customize the javascript availability by clicking the
NoScript extension in the menu bar.

[[https://addons.mozilla.org/en-US/firefox/addon/adsum-notabs][No Tabs]]

If you're using a tiling window manager (Sway), you might consider
disabling Firefox tabs, and have every site in its own window instead.
This extension does that.

[[https://addons.mozilla.org/en-US/firefox/addon/vimium-ff/][Vimium]]

Once vimium is installed, click the icon in the menu bar and click
=Enable all hosts permission=.

[[https://addons.mozilla.org/en-US/firefox/addon/multi-account-containers/][Firefox Multi-Account Containers]]

Read about [[https://support.mozilla.org/en-US/kb/containers][how to use Firefox Containers]]. Configure sites you trust to
open in specific containers, that way you can save your cookies per
container. By default, new sites will always open in temporary ones,
and so when you close your browser all the cookies for that site
disappears.

** Toolbox
:PROPERTIES:
:EXPORT_FILE_NAME: toolbox
:END:

[[https://docs.fedoraproject.org/en-US/fedora-silverblue/toolbox/][Toolbox]] is an integral part of Fedora Atomic, being one of the main
methods of installing software (the alternative being Flatpak), it
lets you run your applications inside of [[https://podman.io][Podman]] containers. Toolbox
can actually be used on any Linux system that is capable of running
Podman, but is especially useful on Atomic hosts. Toolbox is more
tightly integrated with your host OS than Docker or Podman containers
normally are. Toolbox containers share the same =/home= directory with
the host (bind mounted), and they live in the same network and process
namespace as the host (ie. you can run =ps= or =kill= from inside the
toolbox, and it will see/affect the host.) Toolbox containers are not
sandboxed like normal Docker containers are, but they are a
convenience for installing/removing software on Atomic hosts, because
theres not really any other way (since the host filesystem is
read-only). The applications you install in the container will live
only inside the toolbox.

The killer feature of a toolbox is that it lets you try things out,
and if you want to start over, you can just delete the toolbox
container, and create a new one. You are less likely to mess up the
host by playing around inside the toolbox. Just remember that =/home=
is bind mounted to the host, and so if you change or delete things in
those directories, they are also affected the same way on the host.

*** Dev toolbox (Fedora)

Let's create a toolbox to install some of the common development tools
we will use on a daily basis.

#+begin_run
toolbox create dev
#+end_run

This will create a new toolbox container called =dev= based upon the
same Fedora version as the host (the toolbox itself is not Atomic
though, but the normal Fedora Workstation version instead.)

To enter the toolbox run:

#+begin_run
toolbox enter dev
#+end_run

This will enter the toolbox container, and now you can install extra
software:

#+begin_run
sudo dnf install keychain htop
sudo dnf groupinstall "Development Tools" "Development Libraries"
#+end_run

*** Arch Linux toolbox

You are not limited to running Fedora toolboxes, in fact you can run
any container image you want, or even build your own from a
=Dockerfile=. Here is a Dockerfile for Arch Linux you can use to build
an Arch Linux toolbox container:

#+attr_shortcode: :file Dockerfile
#+begin_edit
FROM docker.io/archlinux/archlinux:latest
ENV NAME=arch-toolbox VERSION=rolling
LABEL com.github.containers.toolbox="true" \
  name="$NAME" \
  version="$VERSION"
RUN pacman -Syu --noconfirm \
    && pacman  -S --noconfirm sudo inetutils less \
       git base-devel go \
       noto-fonts noto-fonts-cjk \
       noto-fonts-emoji noto-fonts-extra \
    && pacman -Scc --noconfirm \
    && echo "%wheel ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/toolbox
RUN sudo -u nobody git clone https://aur.archlinux.org/yay-bin.git /tmp/yay \
    && cd /tmp/yay \
    && sudo -u nobody makepkg -s \
    && pacman -U --noconfirm yay-bin-*.pkg.tar.zst
CMD ["bash"]
#+end_edit

Write this to a file named =Dockerfile= and open your host terminal to
the same directory. Then run this command to build the container:

#+begin_run
podman build -t arch .
#+end_run

Now you can create a new toolbox based on the new image (both called
=arch=):

#+begin_run
toolbox create --image arch arch
#+end_run

To enter the Arch Linux container, run:

#+begin_run
toolbox enter arch
#+end_run

Now that you're inside the toolbox, you can run any Arch Linux command
(consult the [[http://wiki.archlinux.org/][Arch Wiki]]).

#+attr_shortcode: :title Run this inside the arch toolbox
#+begin_run
sudo pacman -Syu
sudo pacman -S keychain base-devel
#+end_run

*** Managing toolbox containers

You can list all of your toolboxes that you've created:

#+begin_run
toolbox list
#+end_run

You can remove existing toolboxes:

#+begin_run
toolbox rm --force arch
#+end_run

(force is only required if the toolbox is currently running.)

** Emacs
:PROPERTIES:
:EXPORT_FILE_NAME: emacs-on-fedora
:END:

[[https://www.gnu.org/software/emacs/][Emacs]] is my long time favorite code editor (IDE) and for writing
documentation (including this book).

*** Install Emacs

Because Sway runs on Wayland, you'll want to install the Wayland
(pgtk) version of Emacs. In Fedora 40 onwards, the Wayland (pgtk)
version is already the default. For Fedora 39, [[https://copr.fedorainfracloud.org/coprs/enigm-a/emacs-pgtk-nativecomp][you can use this COPR]]
(a COPR is to Fedora what PPA is to Ubuntu and what AUR is to Arch
Linux), which includes a custom build for Wayland (pgtk).

To enable this, you need to be running your dev toolbox:

#+begin_run
toolbox enter dev
#+end_run

Install Emacs:

#+attr_shortcode: :title run this inside the toolbox:
#+begin_run
sudo dnf install emacs
#+end_run

*** Create Emacs script

In order to be able to quickly launch Emacs inside the toolbox from
the host, you will need a little script installed on the host.

You can create this script and put it in =/usr/local/bin/emacs=. Run
this on the host (not in the toolbox), to create it as the root user:

#+attr_shortcode: :file /usr/local/bin/emacs
#+begin_edit
#!/bin/bash
## Run Emacs in the dev toolbox and pass it any args:
toolbox run -c dev emacs $@
#+end_edit

#+begin_run
sudo chmod a+x /usr/local/bin/emacs
#+end_run

Now you can run Emacs from the host, and it will run inside the
Toolbox.

*** Install dependencies

Most Emacs packages are written in Emacs Lisp, and therefore have no
external dependencies. The one exception is for Vterm terminal
support, which requires compiling a C library (libvterm). This
compilation can be done automatically by Emacs, but it requires you
have some tools preinstalled:

 * CMake
 * libtool

Install the dependencies inside the toolbox:

#+attr_shortcode: :title run this inside the toolbox
#+begin_run
sudo dnf install cmake libtool
#+end_run

*** Remove any existing Emacs config

Assuming you want to use my Emacs config, you need to delete any
existing config you already have. Also note that Emacs creates a
default config the first time it runs, so if you started Emacs
already, you may have a config and not even know it.

Here's how to remove the existing Emacs config:

#+begin_run
rm ~/.emacs ~/.emacs.d -rf
#+end_run

*** Install my Emacs config

[[https://github.com/EnigmaCurry/emacs][My Emacs config is on github]]. Install it with the following script:

#+begin_run
REMOTE=git@github.com:EnigmaCurry/emacs.git
REPO=${HOME}/git/vendor/enigmacurry/emacs
BRANCH=straight

(set -e
test -d ~/.emacs.d && (echo "~/.emacs.d already exists. Aborting install." && exit 1)
test -d ${REPO} || git clone -b ${BRANCH} ${REMOTE} ${REPO}
mkdir ~/.emacs.d && ls -1 ${REPO}/*.el | xargs -iXX ln -s XX ~/.emacs.d
mkdir ~/.emacs.d/straight && ln -s ${REPO}/straight-versions ~/.emacs.d/straight/versions
ln -s ${REPO}/snippets ~/.emacs.d/snippets
)
#+end_run

*** Start Emacs to finish the installation

The first time Emacs starts, it will install all of the dependencies
listed in the main config file =~/.emacs.d/init.el=.

Run:

#+begin_run
emacs
#+end_run

Wait for everything to install. You may see a blank screen for up to
10 minutes, but you should see some minimal information of the
progress in the bottom minibuffer.

If it gets stuck at any point, quit and restart it, and it should
continue where it left off. If you get any error message, you may want
to start Emacs again with debug mode turned on:

#+begin_run
emacs --debug-init
#+end_run

This will usually give you a more verbose error message which can be
helpful in debugging the startup.


*** Read the README for my config

More notes are available in the [[https://github.com/EnigmaCurry/emacs#readme][README]].

** SSH
:PROPERTIES:
:EXPORT_FILE_NAME: ssh
:END:

SSH (secure shell) is a secure networking tool used between a client
and a server. Using an encrypted network protocol, it can be used to
securely login to a server remotely, as well as for more advanded
networking scenarios. Typical use cases for SSH include:

 * Access to a server's console shell, remotely.
 * Transfer files between the server and client (using =rsync=, =scp=,
   or =sftp=).
 * Create network tunnels to access private servers, in both
   directions, either on the server, or on the client.
 * Create a server that acts as a bastion or "jump" host, to be a port
   of entry into a larger private network. SSH is configured to only
   allow authorized client keys access through the bastion host.
 * Create a server to act as an HTTP (socks) client proxy, to allow
   remote clients to browse the web, using the server's IP address as
   the origin.
 * Remote controlling a Docker server using the =docker= command line
   client (SSH Docker Context).

SSH is based upon public key cryptography. Both the client and the
server need to create their own public/private keypair. Keys can be
encrypted on disk (eg. =~/.ssh/id_ecdsa=) or they may also be loaded
from a USB hardware token. Upon connecting to a remote server for the
first time, the client asks the user to validate the server's public
key fingerprint, and then the server's public key is written into a
file called =~/.ssh/known_hosts=, which marks the connection as
trusted from then on. The server also authorizes the client through a
predefined =authorized_keys= file. If either side rejects the key
presented by the other, the connection is unauthorized, and is closed
immediately.

*** Create SSH Keys

This book recommends the use of hardware authentication tokens, like
the [[https://solokeys.com/][Solokey]]. Traditional SSH keyfiles are also acceptable, but these
should be considered as a legacy format, as they are less secure.
Finally, plain password authentication (non-key based) is fully
deprecated and should *never* be used.

**** Setup Solokey (FIDO2) hardware authentication

Plug in your Solokey (or compatible hardware) to the USB port.

Initialize the hardware with a new SSH key:

#+begin_run
## You only need to do this one time per solokey!
ssh-keygen -t ed25519-sk -O resident -O verify-required
#+end_run

You will be required to create/enter a PIN for the Solokey.

**** Traditional SSH keyfiles

The Solokey still has some drawbacks, and cannot be used in all cases.
Traditional SSH keyfiles are still useful for automated and unattended
clients. Technically, the solokey is supposed to be able to work in a
"touchless" mode, by using the =-O no-touch-required= option, but I
never got this to work.

Key files should be created uniquely for each user and workstation.
They should never be shared between multiple users or workstations.

***** Choosing the SSH key type

It is recommended to use the newer =ed25519= key type, which uses the
latest encryption standards. Your distribution may still use the older
standard =rsa= by default (which is acceptable). You should explicitly
select the key type when creating the keyfile to be sure.

Some older servers don't accpet =ed25519= keys, and so in those cases
you should still create an =rsa= key as well. Each key type is stored
in a different file, so its OK to have multiple types installed on the
same machine.

***** Create the new SSH keys

Create the =rsa= key type:

#+begin_run
ssh-keygen -t rsa -f ~/.ssh/id_rsa
#+end_run

Create the =ed25519= key type:

#+begin_run
ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519
#+end_run

You will be prompted to enter an encryption passphrase for each file,
which you should definitely not skip!

*** Setup the ssh-agent

Because your keyfiles are encrypted with a passphrase, you need to
enter the passphrase everytime you use it. This is inconvenient, so
you can run =ssh-agent= to temporarily store your key/identity in
memory, and therefore you only need to enter your passphrase once,
when you log in. (In the case of the solokey, the key is never held in
memory, but you still need to hold the identity of it in the
ssh-agent.)

Keychain is a program that helps you setup the ssh-agent. Install
=keychain=:

#+attr_shortcode: :title Run this on your Fedora workstations:
#+begin_run
sudo dnf install keychain
#+end_run

#+attr_shortcode: :title Run this on your Debian / Ubuntu workstations:
#+begin_run
sudo apt install keychain
#+end_run

#+attr_shortcode: :title Run this on your Arch Linux workstations:
#+begin_run
sudo pacman -S keychain
#+end_run

To configure keychain, edit your =~/.bashrc= file:

#+attr_shortcode: :file ~/.bashrc
#+begin_edit
## Put this line in your ~/.bashrc:
## (If you're using my config, this is already in it.)
eval $(keychain --eval --quiet)
#+end_edit

Log out of your desktop session, and log back in. Open your terminal,
and you should be automatically prompted to enter your SSH passphrase.
Once you have entered the passphrase, the SSH key will remain resident
in memory until you log out.

Double check that the key has been loaded, run:

#+attr_shortcode: :title run this inside your toolbox
#+begin_run
ssh-add -L
#+end_run

The above should print your public key, loaded into the running
=ssh-agent=. Now you should be able to use your key without entering a
passphrase. Copy the output and upload it to your services as your
authorized key. For servers, put the key into
=~/.ssh/authorized_keys=. For hosted services, like GitHub, paste the
key into your SSH settings page.

*** Add your solokey identity per session

Apparently, keychain does not yet know how to load the Solokey
automatically. You must add the Solokey to the ssh-agent manually, one
time, each time you boot your workstation:

#+attr_shortcode: :title run this inside your toolbox
#+begin_run
## Do this to load your Solokey into the ssh-agent:
ssh-add -K
#+end_run

You will be prompted one time to enter your Solokey pin to unlock the
key.

* KVM / libvirt
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: kvm-libvirt
:EXPORT_HUGO_WEIGHT: 4000
:END:

** KVM / libvirt
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:END:

Idealistically, the [[/linux-workstation/introduction/][Introduction]] declared a "No sworkstations" rule.
Pragmatically, you can bend this rule a bit, by hosting some
development servers inside of virtual machines (VM).

Using this config, your workstation will stay relatively pure, because
these VMs are isolated from your normal account. They are
automatically started on boot, running under a dedicated VM user
account. You can treat these VMs just like any other *remote* Linux
host, and access them by (local) SSH connection from your normal
workstation account.

These instructions will install a barebones Debian or Fedora server,
inside a VM, with NAT networking (private IP address, no public ports
open), for local development/testing purposes only. Near the end, you
get to decide if you'd like to bend that rule too, and open the VMs up
to public (LAN) routes.

#+attr_shortcode: :style orange :title Host workstation compatibility
#+begin_notice
The following *host* Linux distributions, have been tested as working:

 * ✅ Fedora Atomic (40)
 * ✅ Arch Linux

🚧 Debian (12) hosts are only partially compatible, I have not been
able to get the autostart service to run, due to an app armor
permission issue, however the VMs do run if you start them manually.
#+end_notice

#+attr_shortcode: :depth 999
#+begin_index
index
#+end_index


#+attr_shortcode:
#+begin_toc
table of contents
#+end_toc

** Setup libvirtd
:PROPERTIES:
:EXPORT_FILE_NAME: setup-libvirtd
:EXPORT_HUGO_WEIGHT: 100
:END:

*** Install libvirt packages

**** Packages for Fedora Atomic hosts

#+attr_shortcode: :style tip
#+begin_notice
Full package installation for Fedora Atomic is covered in the chapter
on [[/linux-workstation/layering-packages][Layering packages]].
#+end_notice

**** Packages for Arch Linux hosts

#+attr_shortcode: :style info
#+begin_notice
For Arch Linux, it is recommended to do a full system update and
reboot prior to installing the libvirt packages.
#+begin_run
sudo pacman -Syu
sudo reboot
#+end_run

After reboot, install packages:

#+begin_run
sudo pacman -S libvirt iptables-nft dnsmasq qemu-base virt-install \
               sysfsutils bridge-utils ebtables git make which jq \
               dmidecode pkgconf gcc
#+end_run
#+end_notice


**** Packages for Debian/Ubuntu hosts

#+attr_shortcode: :style info
#+begin_notice
For Debian (or Ubuntu), it is recommended to do a full system upgrade and
reboot prior to installing the libvirt packages.
#+begin_run
sudo apt update
sudo apt upgrade
sudo reboot
#+end_run

After reboot, install packages:

#+begin_run
sudo apt install --no-install-recommends \
                 libvirt-daemon-system virtinst libvirt-clients \
                 dnsmasq sysfsutils bridge-utils ebtables git make \
                 which jq dmidecode pkgconf gcc curl \
                 python3 python-is-python3
#+end_run
#+end_notice

*** Enable libvirtd service

#+begin_run
sudo systemctl enable --now libvirtd
sudo systemctl enable --now libvirt-guests
sudo systemctl status --no-pager libvirtd
#+end_run

*** Start the default network

#+begin_run
sudo virsh net-start default
sudo virsh net-autostart default
#+end_run

*** Configure /etc/group

Add the existing =libvirt= group to =/etc/group=, if it isn't already:

#+begin_run
grep "^libvirt:" /etc/group || sudo bash -c "getent group libvirt >> /etc/group"
#+end_run

*** Extra steps for Debian workstations

#+attr_shortcode: :style tip
#+begin_notice
On a Debian workstation, creating a config for qemu-bridge-helper was
required, and modifying it to run setuid root to prevent user
permission error (=failed to create tun device: Operation not permitted:
Transport endpoint is not connected=):

#+begin_run
(set -e
sudo mkdir -p /etc/qemu
echo "allow virbr0" | sudo tee /etc/qemu/bridge.conf
sudo chmod u+s /usr/lib/qemu/qemu-bridge-helper
)
#+end_run

I also had to disable apparmor for libvirtd, otherwise I got
permission errors:

#+begin_run
sudo truncate --size 0 /etc/apparmor.d/usr.sbin.libvirtd
sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.libvirtd
#+end_run
#+end_notice

** Create VM admin
:PROPERTIES:
:EXPORT_FILE_NAME: dedicated-vm-user
:EXPORT_HUGO_WEIGHT: 101
:END:

This will create a new user account on your workstation named
=libvirt-admin=. This user will be used as the owner for all the VM
disk images, config files, and for running the libvirt (qemu)
processes that run your VM.

This separation from the normal account you use is important to limit
the privileges that you have over the VM infrastructure. Your normal
account should be able to SSH /into/ the VM and have full root
privleges inside the VM. But your normal account should /not/ have
access to the underlying VM disk image files, nor its configuration.
Access to all VM administrative tasks must be done through =sudo= to
control the =libvirt-admin= account.

*** Create =libvirt-admin= user

#+begin_run
VM_ADMIN=libvirt-admin
sudo useradd -m ${VM_ADMIN} -s /bin/bash -G libvirt 
#+end_run

**** Extra steps for Debian workstations

#+attr_shortcode: :style tip
#+begin_notice
On a Debian workstation, adding the user to the =kvm= group was also
required:

#+begin_run
sudo gpasswd -a ${VM_ADMIN} kvm
#+end_run
#+end_notice

*** Configure systemd for the =libvirt-admin= user

#+begin_run
sudo loginctl enable-linger ${VM_ADMIN}
sudo su ${VM_ADMIN} -c "mkdir -p ~/.bashrc.d"
sudo su ${VM_ADMIN} -c "echo export XDG_RUNTIME_DIR=/run/user/\$(id -u) > ~/.bashrc.d/xdg"
#+end_run

*** Copy your public SSH key into the =libvirt-admin= home directory
#+attr_shortcode: :style tip
#+begin_notice
If you don't have an SSH key yet, run =ssh-keygen -t ed25519=.
#+end_notice

Set =SSH_KEY= variable to point to your public SSH key file:

#+begin_env
SSH_KEY=~/.ssh/id_ed25519.pub
#+end_env

#+begin_run
TMP_SSH=$(mktemp)
cat ${SSH_KEY} > ${TMP_SSH}
chmod a+r ${TMP_SSH}
sudo su ${VM_ADMIN:-libvirt-admin} -c "mkdir -p ~/libvirt && cp ${TMP_SSH} ~/libvirt/user-ssh.pub"
#+end_run

** Configure VM
:PROPERTIES:
:EXPORT_FILE_NAME: config-vm
:END:

*** Choose hardware sizes

#+attr_shortcode:
#+begin_env
MEMORY=1024
CPUS=2
DISK_SIZE=50
#+end_env

*** Choose cloud image

You can choose any standard cloud image that supports cloud-init.

**** Debian 12

#+attr_shortcode:
#+begin_env
OS_VARIANT=debian12
CLOUD_IMAGE=https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2
#+end_env


#+attr_shortcode: :style tip
#+begin_notice
On slighly older versions of libvirt, you may need to set OS_VARIANT
differently, but the image should still work:
#+begin_env
OS_VARIANT=debian11
#+end_env
#+end_notice

**** Fedora 40

#+attr_shortcode:
#+begin_env
OS_VARIANT=fedora40
CLOUD_IMAGE=https://download.fedoraproject.org/pub/fedora/linux/releases/40/Cloud/x86_64/images/Fedora-Cloud-Base-Generic.x86_64-40-1.14.qcow2
#+end_env

*** Find the default subnet (=virbr0=)
#+attr_shortcode:
#+begin_run
ip route | grep virbr0 | cut -d " " -f 1
#+end_run
#+begin_stdout
192.168.122.0/24
#+end_stdout


*** Configure Hostname, IP Address, and MAC address

#+begin_env
NAME=debian-dev
IP_ADDRESS=192.168.122.2
MAC_ADDRESS=$(printf '00:60:2F:%02X:%02X:%02X\n' $[RANDOM%256] $[RANDOM%256] | tr '[:upper:]' '[:lower:]')
#+end_env

#+attr_shortcode: :style tip
#+begin_notice
You need to choose a valid IP_ADDRESS in the range of your subnet. The
Gateway should be the same subnet with the address ending in =.1=. The
MAC address will be random.
#+end_notice

*** Create static DHCP lease

#+attr_shortcode:
#+begin_run
sudo virsh net-update default add-last ip-dhcp-host "&lt;host mac='${MAC_ADDRESS}' name='${NAME}' ip='${IP_ADDRESS}' /&gt;" --live --config --parent-index 0
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
You can edit the file manually to do more cleanup. After editing, you
must stop (destroy) and restart the network.

#+begin_run
sudo virsh net-edit default
sudo virsh net-destroy default
sudo virsh net-start default
#+end_run
#+end_notice

*** Create env file to store main config settings

#+attr_shortcode:
#+begin_run
TMP_ENV=$(mktemp)
cat << EOF > ${TMP_ENV}
export NAME=${NAME}
export OS_VARIANT=${OS_VARIANT}
export IP_ADDRESS=${IP_ADDRESS}
export MAC_ADDRESS=${MAC_ADDRESS}
export CLOUD_IMAGE=${CLOUD_IMAGE}
export MEMORY=${MEMORY}
export CPUS=${CPUS}
export DISK_SIZE=${DISK_SIZE}
export USER_DATA=~/libvirt/cloud-init/${NAME}.yaml
EOF
chmod a+r ${TMP_ENV}
sudo su ${VM_ADMIN:-libvirt-admin} -c \
    "mkdir -p ~/libvirt && cp ${TMP_ENV} ~/libvirt/${NAME}.env"
#+end_run

#+attr_shortcode: :style tip
#+begin_notice
This will create a new config file *in the libvirt-admin user's home directory*
=~/libvirt/${NAME}.env=.
#+end_notice

** Create VM 
:PROPERTIES:
:EXPORT_FILE_NAME: create-vm
:END:
#+attr_shortcode: :style info
#+begin_notice
*For this entire section you need to perform the VM config as the =libvirt-admin= user.*

Login to the shell account of  =libvirt-admin=:

#+begin_run
sudo su libvirt-admin -l
#+end_run
#+end_notice

*** Source the config

Now, and anytime you come back later to work on the same VM, source the config file:

#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+begin_run
NAME=debian-dev
source ~/libvirt/${NAME}.env
#+end_run

*** Create directories to hold the VM disks and config files:

#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+begin_run
mkdir -p ~/libvirt/{cloud-images,disks,cloud-init}
#+end_run

*** Create the cloud-init config file:

#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+begin_run
cat << EOF | sed 's/\xe2\x80\x8b//g' > ${USER_DATA}
#cloud-config
hostname: ${NAME}
users:
​  - name: root
    ssh_authorized_keys:
​      - $(cat ~/libvirt/user-ssh.pub)
EOF
#+end_run

*** Download the cloud image:

#+attr_shortcode: :style tip
#+begin_notice
You only need to download each CLOUD_IMAGE once, they will be cached
in =~/libvirt/cloud-images=, so they can be be reused.
#+end_notice

#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+begin_run
(set -e
cd ~/libvirt/cloud-images
curl -LO ${CLOUD_IMAGE}
chmod a-w $(echo ${CLOUD_IMAGE} | grep -Po ".*/\K.*$")
)
#+end_run

*** Clean up old VMs with the same name:
#+attr_shortcode: :style warning
#+begin_notice
If you already have a VM with the same name, and you want to start
again from scratch, you need to clean up from the previous install
first:
#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+begin_run
## To cleanup and REMOVE an old VM named debian-dev:
virsh destroy debian-dev
virsh managedsave-remove debian-dev
virsh undefine debian-dev
#+end_run
#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+end_notice

*** Create the disk image for the new VM:
#+attr_shortcode: :style warning
#+begin_notice
This is destructive of the existing disk file!
#+end_notice


#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+begin_run
(set -e
cp ~/libvirt/cloud-images/$(echo ${CLOUD_IMAGE} | grep -Po ".*/\K.*") \
   ~/libvirt/disks/${NAME}.qcow2
chmod u+w ~/libvirt/disks/${NAME}.qcow2
qemu-img resize ~/libvirt/disks/${NAME}.qcow2 +${DISK_SIZE}G
echo Created ~/libvirt/disks/${NAME}.qcow2
)
#+end_run

*** Create the VM:

#+attr_shortcode:  :style secondary :title Run this as the libvirt-admin user
#+begin_run
virt-install \
  --name ${NAME} \
  --os-variant ${OS_VARIANT} \
  --virt-type kvm \
  --graphics none \
  --console pty,target_type=serial \
  --cpu host \
  --vcpus ${CPUS} \
  --memory ${MEMORY} \
  --network bridge=virbr0,model=virtio,mac=${MAC_ADDRESS} \
  --cloud-init user-data=${USER_DATA} \
  --import \
  --disk ~/libvirt/disks/${NAME}.qcow2
#+end_run

*** Watch the console for any errors

As the VM starts up, your terminal will attach to the console output
of the VM. This is to monitor any errors that may occur during the
bootup, especially relating to cloud-init.

Wait until you see this Login message:

#+begin_stdout
debian-dev login: 
#+end_stdout

*** Disconnect from the VM console
To disconnect from the VM console, press the keyboard combination
=Ctrl+]= (meaning to hold the Control key and the right square bracket
key at the same time.)

*** Shutdown the VM

#+attr_shortcode: :style info
#+begin_notice
It is important to shut down the VM the first time after install,
otherwise you will get an error about the unejected cloud-init ISO.
#+end_notice

#+attr_shortcode: :style secondary :title Run this as the libvirt-admin usre
#+begin_run
virsh shutdown ${NAME}
#+end_run

*** Verify VM is shut down
#+attr_shortcode: :style secondary :title Run this as the libvirt-admin user
#+begin_run
virsh list --all
#+end_run

#+begin_stdout
​ Id   Name         State
​-----------------------------
​ -    debian-dev   shut off
#+end_stdout

*** Restart VM
#+attr_shortcode: :style secondary :title Run this as the libvirt-admin user
#+begin_run
virsh start ${NAME}
#+end_run

#+begin_stdout
Domain 'debian-dev' started
#+end_stdout

*** Verify VM is running
#+attr_shortcode: :style secondary :title Run this as the libvirt-admin user
#+begin_run
virsh list --all
#+end_run

#+begin_stdout
​ Id   Name         State
​-----------------------------
​ -    debian-dev   running
#+end_stdout


** Auto start VMs on boot
:PROPERTIES:
:EXPORT_FILE_NAME: autostart
:EXPORT_HUGO_WEIGHT: 4001
:END:

*** Download libvirt python interface

#+attr_shortcode: :style tip
#+begin_notice
The [[https://github.com/EnigmaCurry/virsh-start-stop][virsh-start-stop]] tool offers a more reliable interface for
starting and stopping VMs via the libvirt API, so it will be used in
the systemd unit for starting on boot.
#+end_notice

#+begin_run
(set -e
sudo mkdir -p /usr/local/src/
sudo su -c "cd /usr/local/src && git clone https://github.com/EnigmaCurry/virsh-start-stop"
)
#+end_run

#+attr_shortcode: :style credits :title CREDITS :icon gift
#+begin_notice
EnigmaCurry/virsh-start-stop is my own fork of
[[https://github.com/avollmerhaus/virsh-start-stop][avollmerhaus/virsh-start-stop]] which has been slightly customized for
this configuration. Thank you to avollmerhaus for creating this
service manager!
#+end_notice

*** Create Unit template

This is an instantiable template used for all VM services:

#+begin_run
VM_ADMIN=libvirt-admin
cat << EOF | sudo tee /etc/systemd/system/virsh@.service
[Unit]
Description=virsh start / stop %i
Requires=libvirtd.service
After=libvirtd.service

[Service]
Type=oneshot
RemainAfterExit=true
User=${VM_ADMIN}
Group=libvirt
Environment="XDG_RUNTIME_DIR=/run/user/$(id -u ${VM_ADMIN})"
ExecStart=/usr/bin/python /usr/local/src/virsh-start-stop/src/virsh_start_stop/virsh_start_stop.py --machine %i --state started
ExecStop=/usr/bin/python /usr/local/src/virsh-start-stop/src/virsh_start_stop/virsh_start_stop.py --machine %i --state stopped

[Install]
WantedBy=default.target
EOF
#+end_run

*** Enable each VM service

This will instantiate the VM service template, and enable a VM named
=debian-dev=, which will automatically start on workstation boot:

#+begin_run
NAME=debian-dev
sudo systemctl enable --now virsh@${NAME}
sudo systemctl status virsh@${NAME}
#+end_run

** Public routes to VMs
:PROPERTIES:
:EXPORT_FILE_NAME: public-routes
:EXPORT_HUGO_WEIGHT: 5000
:END:

By default, all incoming traffic to the VMs must originate from your
workstation (or another VM on your workstation) - no traffic is routed
to your VMs from any other interface.

If you want to break this rule, and allow public routes into these VMs
(DNAT port forwarding), you will need to install the libvirt hook that
sets up the iptables forwarding rules:

*** Download the port-forwarding hook

#+begin_run
sudo mkdir -p /usr/local/src/
sudo su -c "cd /usr/local/src && git clone https://github.com/EnigmaCurry/libvirt-hook-qemu.git"
#+end_run

*** Install the port-forwarding hook

#+begin_run
sudo make -C /usr/local/src/libvirt-hook-qemu/ install
#+end_run

*** Customize the port-forwarding hook

Use the [[https://github.com/EnigmaCurry/libvirt-hook-qemu/blob/master/hooks.json][example]] and [[https://github.com/EnigmaCurry/libvirt-hook-qemu/blob/master/hooks.schema.json][schema]] as a reference, then edit
=/etc/libvirt/hooks/hooks.json= to setup the exact port mapping you
want.

#+begin_run
cat << EOF | jq > /etc/libvirt/hooks/hooks.json
{
  "debian-dev": {
    "interface": "virbr0",
    "private_ip": "192.168.122.2",
    "port_map": {
        "tcp": [
            [2222, 22],
            [80, 80],
            [443, 443]
        ]
    }
  }
}
EOF
#+end_run

*** Autostart port-forwarding script on boot

#+begin_aside
I have not figured out how libvirt hooks are supposed to work with
user-mode VMs. It seems like when the VM starts, the hook never gets
called. So, this section adds another service that triggers the hook
manually on boot to setup the port forwarding for each VM.
#+end_aside

**** Create DNAT service template

#+begin_run
cat << EOF | sudo tee /etc/systemd/system/libvirt-DNAT@.service
[Unit]
Description=DNAT port forwarding for kernel virtual machine: %i
After=network.target
Wants=network.target

[Service]
Type=oneshot
ExecStart=/etc/libvirt/hooks/qemu %i start

[Install]
WantedBy=network.target
EOF
systemctl daemon-reload
#+end_run

**** Enable DNAT service once per VM you want to expose

#+begin_run
NAME=debian-dev
systemctl enable --now libvirt-DNAT@${NAME}.service
systemctl status libvirt-DNAT@${NAME}.service
#+end_run

**** Reboot workstation

Once rebooted, test that your port forward rule exists in iptables
rules:

#+begin_run
iptables-save | grep 2222
#+end_run

#+begin_stdout
-A DNAT-debian-dev -d 10.13.13.227/32 -p tcp -m tcp --dport 2222 -j DNAT --to-destination 192.168.122.2:22
-A SNAT-debian-dev -s 192.168.122.2/32 -d 192.168.122.2/32 -p tcp -m tcp --dport 2222 -j MASQUERADE
#+end_stdout
** Setup workstation SSH config
:PROPERTIES:
:EXPORT_FILE_NAME: setup-workstation
:EXPORT_HUGO_WEIGHT: 5000
:END:

#+attr_shortcode: :style info
#+begin_notice
*For this section, you are back to using your normal workstation user.*
#+end_notice

Append a new host config into your SSH config (=~/.ssh/config=):

#+attr_shortcode: :file ~/.ssh/config
#+begin_edit
Host debian-dev
    Hostname 192.168.122.2
    User root
    ControlMaster auto
    ControlPersist yes
    ControlPath /tmp/ssh-%u-%r@%h:%p
#+end_edit

#+attr_shortcode: :style info
#+begin_notice
*Make sure =Host= and =Hostname= are set correctly for your VM.*
#+end_notice

With this config, you can now use SSH to control the VM:

#+begin_run
ssh debian-dev whoami
#+end_run

#+begin_stdout
root
#+end_stdout

*** Install Docker

You're now ready to use your VM as an install target for whatever you
want. It is recommended to install Docker, which you can learn about
in the volume [[/d.rymcg.tech][Self-hosting Docker]] in the chapter called [[/d.rymcg.tech/workstation][Setup your
workstation]].
