#+hugo_base_dir: ../hugo
#+hugo_section: /linux-workstation
#+hugo_weight: auto
#+STARTUP: align

* Linux Workstation
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_WEIGHT: 190
:END:

This book describes how I setup a Linux Workstation (on a personal
Desktop or Laptop computer).

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: introduction
:END:

A Linux Workstation is a single user computer that you use as your
primary interface for computing, especially for "work" purposes. At a
bare minimum, a workstation includes a keyboard to type on, and a
display to display things on. Historically, there has been a hardware
distinction between a personal computer (PC) and a Unix workstation,
but ever since the introduction of Linux, the difference in hardware
doesn't really exist anymore, and any computing device can become a
workstation. The only important distinctions for a workstation is the
role that it serves, and how /you/ configure and use it on daily
basis.

The role of a workstation is very different than that of a server. A
workstation's only purpose is to serve you, the user, while
interacting with its physical keyboard/mouse/etc interface. A
workstation /is/ usually connected to a network, but only as a client,
not as a server. (Of course, you may bend this rule if you like, to
make your computer a server-workstation or "Sworkstation", but it is
cleaner, and more secure, to use separate machines for these very
different roles.)

This book will describe my preferred method for setting up a brand new
computer for use as a personal workstation.

* Fedora Sway Atomic
:PROPERTIES:
:EXPORT_FILE_NAME: fedora-sway-atomic
:END:

I have tried a great many different Linux distributions over the
years, but I have recently settled on using [[https://fedoraproject.org/atomic-desktops/sway/][Fedora Sway Atomic]] for my
desktop and laptop workstations.

[[https://github.com/swaywm/sway][Sway]] is a minimal tiling window manager for Wayland. It is ideal for
efficient keyboard centric development and for getting out of your
way.

The "Atomic" part refers to [[https://coreos.github.io/rpm-ostree/][rpm-ostree]] which was developed by the
CoreOS team to build an operating system that is built entirely to
support containers. The root file system of the host operating system
is mounted read-only, and the packages are distributed in an image,
rather than installed individually. This makes updating (or rolling
back) the system far easier, and makes for a more stable environment.
There is no need to replace packages one-by-one, you just download the
new image provided by the distro, and then reboot the system to use
it.

The base image includes all the typical things everyone needs:
coreutils, a display manager, web browser, terminal apps etc. However,
the base image is still pretty bare bones. Furthermore, the image is
read-only, so you can't install packages like you can with a more
traditional Linux distro. If you want to install something that isn't
in the base image, you have a few different options:

 * Podman or Docker containers. Since containers use their own image,
   they are separate from the main image, and can be freely created
   and destroyed separately.
 * Flatpak is a type of application container that includes all of its
   dependencies, and it is sandboxed/isolated from the host system,
   therefore they can be installed/managed separately from the base
   image.
 * Use rpm-ostree itself to create a new image *layer*. This extends
   the base layer with extra packages you want to install. This is
   fully supported, but not optimal, as when you upgrade the base
   image, this layer needs to be recreated each time.

I only use a couple of Flatpak apps for a few things. For almost
everything else I use Podman containers via [[https://docs.fedoraproject.org/en-US/fedora-silverblue/toolbox/][toolbox]] and/or [[https://distrobox.it/][distrobox]]
and these can even include graphical applications. Creating your own
[[https://docs.fedoraproject.org/en-US/iot/adding-layered/][rpm-ostree layers]] is to be avoided if possible, but some things don't
like running in containers, so this remains an option.

* Requirements
:PROPERTIES:
:EXPORT_FILE_NAME: requirements
:END:

You will need the following hardware:

 * An x86_64 desktop or laptop computer.
 * A USB drive for copying the .iso installer to.
 * A [[https://solokeys.com/][solokey]] or other FIDO2 compatible hardware authentication key.
   (This is optional, but highly recommended for storing secure shell
   keys, PGP keys, and logging into websites with Webauthn.)

* Installation
:PROPERTIES:
:EXPORT_FILE_NAME: install
:END:

** Create USB installation media

[[https://fedoraproject.org/atomic-desktops/sway/download][Download the Fedora Sway Atomic iso image.]]

Assuming you are temporarily using another Linux workstation, write
the .iso image to a USB drive (eg. replace ~/dev/sdX~ with your device name):

: dd if=Fedora-Sericea-ostree-x86_64-39-1.5-respin2.iso \
:    of=/dev/sdX bs=10M status=progress conv=sync

Boot the target workstation computer using the USB drive. You will
boot into the Anaconda install wizard. Just follow the prompts to
install it, it is exactly the same as any other Fedora / Redhat
install.

Tips:

 * Enable whole disk encryption and choose a secure passphrase.
   Especially for laptop computers that you may travel with, this an
   important thing to do to keep your files safe at rest.
 * Use the entire disk for the install. Dual booting another operating
   system on the same workstation is not considered a safe/secure
   thing to do. If you want to run Windows or play games, use a
   separate computer for that.

Once the installer finishes, reboot, remove the USB, and login to your
new system.

** Setup Sway

The Fedora Atomic Sway edition includes a default configuration for
Sway. It's pretty nice out of the box, and so if you like it, you can
just use it. However, I have [[https://github.com/enigmacurry/sway-home][my own custom configuration]] that I
replace it with, and you can do the same if you like.

Open the default terminal emulator (foot) with the keyboard shortcut:
=Win+Enter= (hold down the "Windows" key on your keyboard, then
simultaneously press Enter.)

My custom config replaces several of the default configuration files.
So you must first get rid of these files, by renaming them with the
suffix =.orig= for posterity:

: mv ~/.config ~/.config.orig
: mv ~/.bashrc ~/.bashrc.orig
: mv ~/.bash_profile ~/.bash_profile.orig

Next, install my [[https://github.com/enigmacurry/sway-home][customized sway config repository]] :

: git clone https://github.com/enigmacurry/sway-home \
:   ~/git/vendor/enigmacurry/sway-home

Run the included setup script:

: cd ~/git/vendor/enigmacurry/sway-home
: ./setup.sh

The =setup.sh= script will make [[https://github.com/EnigmaCurry/sway-home/blob/master/setup.sh#L57-L61][symlinks]] to the repository files from
the same original paths as the files you just moved. It also asks you
some questions to help setup your git profile.

Once you have finished entering the information setup asks for, press
=Win+Shift+E=, and choose Log Out. Log back in, and this will load the
new config files.

** Setup display resolutions and orientation

Fedora Sway Atomic ships with [[https://git.sr.ht/~emersion/kanshi][kanshi]] for display setup. Kanshi does
not include any GUI for setting it up, so another program called
[[https://github.com/artizirk/wdisplays][wdisplays]] is useful, however it is not included in the base Atomic
distribution, and you will have to install it via [[/linux-workstation/toolbox][toolbox]].

: # install wdisplays inside of toolbox
: sudo dnf install wdisplays

You can configure all of your displays using the wdisplays GUI
program, however, the configuration will not persist across login
sessions. So what you need to do is set it up how you like it, and
then transfer that information into the Kanshi config file so that it
sets it up the same way everytime you login.

For example, on my test system I have two display port monitors, with
outputs named =DP-3= and =DP-4=. These are shown in wdisplays and I
have set up the size, position, and DPI scaling exactly how I like it:

DP-3:

[[/img/wdisplays1.webp]]

DP-4:

[[/img/wdisplays2.webp]]

Open the Kanshi config file =~/.config/kanshi/config= and copy the
information into the config file:

: profile {
:    output DP-3 enable mode 2560x1440 position 3840,0 scale 1
:    output DP-4 enable mode 3840x2160 position 1920,360 scale 2
: }

Kanshi is automatically started when sway is, so you can test it by
logging out and logging back in.

* Firefox
:PROPERTIES:
:EXPORT_FILE_NAME: firefox
:END:

Fedora Atomic ships with the Firefox browser preinstalled. This
section describes how I like to set it up.

** Remove clutter

*** Remove =Firefox View=, right click the upper left icon and select =Remove from toolbar=.

[[/img/firefox/firefox-view.webp]]

*** Remove existing bookmarks from bookmark bar, right click each one and select =Delete=.

*** Remove =Pocket=, right click the pocket icon in the upper right toolbar, select =Remove from toolbar=

[[/img/firefox/firefox-pocket.webp]]

*** Remove =Firefox Account= icon, select =Remove from toolbar=

[[/img/firefox/firefox-account.webp]]


** Firefox Settings

Go into the Firefox settings: click the "hamburger" menu in the top
right toolbar. Select =Settings=.

[[/img/firefox/firefox-settings.webp]]

*** General Settings

**** Select =Open previous windows and tabs=

**** Turn on Dark mode

[[/img/firefox/firefox-general.webp]]

**** Turn off =Recommend extensions as you browse=

**** Turn off =Recommend features as you browse=

[[/img/firefox/firefox-browsing.webp]]

*** Home settings

**** =New Windows and Tabs=

Select =Blank Page= for both new windows and tabs.

[[/img/firefox/firefox-home.webp]]

**** Firefox Home Content

The home content won't show if you set =Blank Page= above, but I go
ahead and turn off all the home stuff anyway.


*** Search Settings

**** Choose a non-Google default search engine, eg. =DuckDuckGo=.

**** Turn off all Search Suggestions

**** Delete all the corporate Search Shortcuts other than your preferred one (eg. DuckDuckGo).

You can select each one and click =Remove= or you can press the Delete
key. Delete Google, Amazon, Bing, eBay, Wikipedia etc.

[[/img/firefox/firefox-search.webp]]


*** Privacy & Security settings

**** Enhanced Tracking Protection, select =Strict=

**** Set =Do Not Track= to =Always=

[[/img/firefox/firefox-privacy-1.webp]]

**** Logins and Passwords

Unselect =Suggest Firefox relay email masks=

Unselect =Show alerts about passwords for breached websites= (You
already use unique passwords for every website, right??)

**** IMPORTANT: select =Use a Primary Password=

[[/img/firefox/firefox-privacy-2a.webp]]

Without setting a primary password, any password that firefox saves
will be **unencrypted**! You must set a primary (master) password, and
you will need to type it in each time you restart your browser, to
unlock the password manager.

**** Address Bar - Firefox Suggest

Unselect =Search engines=

Unselect =Suggestions from the web=

Unselect =Suggestions from sponsors=

[[/img/firefox/firefox-privacy-2b.webp]]

**** Firefox Data Collection and Use

Unselect everything here.

[[/img/firefox/firefox-privacy-3a.webp]]

**** HTTPs-Only mode

Choose =Enable HTTPS-Only Mode in all windows=

[[/img/firefox/firefox-privacy-3b.webp]]


**** DNS over HTTPS

Especially if you use a portable laptop, or connect to various WiFi
access points, you should choose =Max Protection=.

[[/img/firefox/firefox-dns.webp]]

** Extensions and Themes

From the Settings menu, near the bottom, click =Extensions & Themes=.

*** Themes

Choose a theme you like. For example, click =Dark= and then click =Enable=.

*** Extensions

Go to [[https://addons.mozilla.org][addons.mozilla.org]] and install the following extensions:

[[https://addons.mozilla.org/en-US/firefox/addon/darkreader/][Dark Reader]]

Dark reader makes all sites darker, and you can customize each site by
clicking on the Dark Reader extension in the menu bar.

[[https://addons.mozilla.org/en-US/firefox/addon/ublock-origin][Ublock Origin]]

Disables almost all ads on all websites. There's not much to configure
here, it basically works out of the box. However, you can customize it
per site if you want to enable ads on certain pages.

[[https://addons.mozilla.org/en-US/firefox/addon/noscript][NoScript]]

By default, all sites will have javascript disabled. On each site you
trust, you can customize the javascript availability by clicking the
NoScript extension in the menu bar.

[[https://addons.mozilla.org/en-US/firefox/addon/adsum-notabs][No Tabs]]

If you're using a tiling window manager (Sway), you might consider
disabling Firefox tabs, and have every site in its own window instead.
This extension does that.

[[https://addons.mozilla.org/en-US/firefox/addon/vimium-ff/][Vimium]]

Once vimium is installed, click the icon in the menu bar and click
=Enable all hosts permission=.

[[https://addons.mozilla.org/en-US/firefox/addon/multi-account-containers/][Firefox Multi-Account Containers]]

Read about [[https://support.mozilla.org/en-US/kb/containers][how to use Firefox Containers]]. Configure sites you trust to
open in specific containers, that way you can save your cookies per
container. By default, new sites will always open in temporary ones,
and so when you close your browser all the cookies for that site
disappears.

* Toolbox
:PROPERTIES:
:EXPORT_FILE_NAME: toolbox
:END:

[[https://docs.fedoraproject.org/en-US/fedora-silverblue/toolbox/][Toolbox]] is an integral part of Fedora Atomic, being one of the main
methods of installing software (the alternative being Flatpak), it
lets you run your applications inside of [[https://podman.io][Podman]] containers. Toolbox
can actually be used on any Linux system that is capable of running
Podman, but is especially useful on Atomic hosts. Toolbox is more
tightly integrated with your host OS than Docker or Podman containers
normally are. Toolbox containers share the same =/home= directory with
the host (bind mounted), and they live in the same network and process
namespace as the host (ie. you can run =ps= or =kill= from inside the
toolbox, and it will see/affect the host.) Toolbox containers are not
sandboxed like normal Docker containers are, but they are a
convenience for installing/removing software on Atomic hosts, because
theres not really any other way (since the host filesystem is
read-only). The applications you install in the container will live
only inside the toolbox.

The killer feature of a toolbox is that it lets you try things out,
and if you want to start over, you can just delete the toolbox
container, and create a new one. You are less likely to mess up the
host by playing around inside the toolbox. Just remember that =/home=
is bind mounted to the host, and so if you change or delete things in
those directories, they are also affected the same way on the host.

** Dev toolbox (Fedora)

Let's create a toolbox to install some of the common development tools
we will use on a daily basis.

: toolbox create dev

This will create a new toolbox container called =dev= based upon the
same Fedora version as the host (the toolbox itself is not Atomic
though, but the normal Fedora Workstation version instead.)

To enter the toolbox run:

: toolbox enter dev

This will enter the toolbox container, and now you can install extra
software:

: sudo dnf install keychain htop
: sudo dnf groupinstall "Development Tools" "Development Libraries"

** Arch Linux toolbox

You are not limited to running Fedora toolboxes, in fact you can run
any container image you want, or even build your own from a
=Dockerfile=. Here is a Dockerfile for Arch Linux you can use to build
an Arch Linux toolbox container:

: FROM docker.io/archlinux/archlinux:latest
: ENV NAME=arch-toolbox VERSION=rolling
: LABEL com.github.containers.toolbox="true" \
:   name="$NAME" \
:   version="$VERSION"
: RUN pacman -Syu --noconfirm \
:     && pacman  -S --noconfirm sudo inetutils less \
:        git base-devel go \
:        noto-fonts noto-fonts-cjk \
:        noto-fonts-emoji noto-fonts-extra \
:     && pacman -Scc --noconfirm \
:     && echo "%wheel ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/toolbox
: RUN sudo -u nobody git clone https://aur.archlinux.org/yay-bin.git /tmp/yay \
:     && cd /tmp/yay \
:     && sudo -u nobody makepkg -s \
:     && pacman -U --noconfirm yay-bin-*.pkg.tar.zst
: CMD ["bash"]

Write this to a file named =Dockerfile= and open your host terminal to
the same directory. Then run this command to build the container:

: podman build -t arch .

Now you can create a new toolbox based on the new image (both called
=arch=):

: toolbox create --image arch arch

To enter the Arch Linux container, run:

: toolbox enter arch

Now that you're inside the toolbox, you can run any Arch Linux command
(consult the [[http://wiki.archlinux.org/][Arch Wiki]]).

: sudo pacman -Syu
: sudo pacman -S keychain base-devel

** Managing toolbox containers

You can list all of your toolboxes that you've created:

: toolbox list

You can remove existing toolboxes:

: toolbox rm --force arch

(force is only required if the toolbox is currently running.)

* Emacs
:PROPERTIES:
:EXPORT_FILE_NAME: emacs-on-fedora
:END:

[[https://www.gnu.org/software/emacs/][Emacs]] is my long time favorite code editor (IDE) and for writing
documentation (including this book).

** Install Emacs

Because Sway runs on Wayland, you'll want to install the Wayland
(pgtk) version of Emacs. In Fedora 40 onwards, the Wayland (pgtk)
version is already the default. For Fedora 39, [[https://copr.fedorainfracloud.org/coprs/enigm-a/emacs-pgtk-nativecomp][you can use this COPR]]
(a COPR is to Fedora what PPA is to Ubuntu and what AUR is to Arch
Linux), which includes a custom build for Wayland (pgtk).

To enable this, you need to be running your dev toolbox:

: toolbox enter dev

Once the toolbox is running, you may enable the COPR:

: # This is no longer necessary on Fedora 40+
: sudo dnf copr enable enigm-a/emacs-pgtk-nativecomp

Install Emacs:

: sudo dnf install emacs

** Create Emacs script

In order to be able to quickly launch Emacs inside the toolbox from
the host, you will need a little script installed on the host.

You can create this script and put it in =/usr/local/bin/emacs=. Run
this on the host (not in the toolbox), to create it as the root user:

: cat <<EOF | sudo tee /usr/local/bin/emacs
: #!/bin/bash
: # Run Emacs in the dev toolbox and pass it any args:
: toolbox run -c dev emacs $@
: EOF
:
: sudo chmod a+x /usr/local/bin/emacs

Now you can run Emacs from the host, and it will run inside the
Toolbox.

** Install dependencies

Most Emacs packages are written in Emacs Lisp, and therefore have no
external dependencies. The one exception is for Vterm terminal
support, which requires compiling a C library (libvterm). This
compilation can be done automatically by Emacs, but it requires you
have some tools preinstalled:

 * CMake
 * libtool

Install the dependencies inside the toolbox:

: sudo dnf install cmake libtool

** Remove any existing Emacs config

Assuming you want to use my Emacs config, you need to delete any
existing config you already have. Also note that Emacs creates a
default config the first time it runs, so if you started Emacs
already, you may have a config and not even know it.

Here's how to remove the existing Emacs config:

: rm ~/.emacs ~/.emacs.d

** Install my Emacs config

[[https://github.com/EnigmaCurry/emacs][My Emacs config is on github]]. Install it with the following script:

: REMOTE=git@github.com:EnigmaCurry/emacs.git
: REPO=${HOME}/git/vendor/enigmacurry/emacs
: BRANCH=straight
: 
: (set -e
: test -d ~/.emacs.d && (echo "~/.emacs.d already exists. Aborting install." && exit 1)
: test -d ${REPO} || git clone -b ${BRANCH} ${REMOTE} ${REPO}
: mkdir ~/.emacs.d && ls -1 ${REPO}/*.el | xargs -iXX ln -s XX ~/.emacs.d
: mkdir ~/.emacs.d/straight && ln -s ${REPO}/straight-versions ~/.emacs.d/straight/versions
: ln -s ${REPO}/snippets ~/.emacs.d/snippets
: )

** Start Emacs to finish the installation

The first time Emacs starts, it will install all of the dependencies
listed in the main config file =~/.emacs.d/init.el=.

Run:

: emacs

Wait for everything to install. You may see a blank screen for up to
10 minutes, but you should see some minimal information of the
progress in the bottom minibuffer.

If it gets stuck at any point, quit and restart it, and it should
continue where it left off. If you get any error message, you may want
to start Emacs again with debug mode turned on:

: emacs --debug-init

This will usually give you a more verbose error message which can be
helpful in debugging the startup.


** Read the README for my config

More notes are available in the [[https://github.com/EnigmaCurry/emacs#readme][README]].

* SSH
:PROPERTIES:
:EXPORT_FILE_NAME: ssh
:END:

SSH (secure shell) is a secure networking tool used between a client
and a server. Using an encrypted network protocol, it can be used to
securely login to a server remotely, as well as for more advanded
networking scenarios. Typical use cases for SSH include:

 * Access to a server's console shell, remotely.
 * Transfer files between the server and client (using =rsync=, =scp=,
   or =sftp=).
 * Create network tunnels to access private servers, in both
   directions, either on the server, or on the client.
 * Create a server that acts as a bastion or "jump" host, to be a port
   of entry into a larger private network. SSH is configured to only
   allow authorized client keys access through the bastion host.
 * Create a server to act as an HTTP (socks) client proxy, to allow
   remote clients to browse the web, using the server's IP address as
   the origin.

SSH is based upon public key cryptography. Both the client and the
server need to create their own public/private keypair. Keys can be
encrypted on disk (eg. =~/.ssh/id_ecdsa=) or they may also be loaded
from a USB hardware token. Upon connecting to a remote server for the
first time, the client asks the user to validate the server's public
key fingerprint, and then the server's public key is written into a
file called =~/.ssh/known_hosts=, which marks the connection as
trusted from then on. The server also authorizes the client through a
predefined =authorized_keys= file. If either side rejects the key
presented by the other, the connection is unauthorized, and is closed
immediately.

** Create SSH Keys

This book recommends the use of hardware authentication tokens, like
the [[https://solokeys.com/][Solokey]]. Traditional SSH keyfiles are also acceptable, but these
should be considered as a legacy format, as they are less secure.
Finally, plain password authentication (non-key based) is fully
deprecated and should *never* be used.

*** Setup Solokey (FIDO2) hardware authentication

Plug in your Solokey (or compatible hardware) to the USB port.

Initialize the hardware with a new SSH key:

: # You only need to do this one time per solokey!
: ssh-keygen -t ed25519-sk -O resident -O verify-required

You will be required to create/enter a PIN for the Solokey.

*** Traditional SSH keyfiles

The Solokey still has some drawbacks, and cannot be used in all cases.
Traditional SSH keyfiles are still useful for automated and unattended
clients. Technically, the solokey is supposed to be able to work in a
"touchless" mode, by using the =-O no-touch-required= option, but I
never got this to work.

Key files should be created uniquely for each user and workstation.
They should never be shared between multiple users or workstations.

**** Choosing the SSH key type

It is recommended to use the newer =ed25519= key type, which uses the
latest encryption standards. Your distribution may still use the older
standard =rsa= by default (which is acceptable). You should explicitly
select the key type when creating the keyfile to be sure.

Some older servers don't accpet =ed25519= keys, and so in those cases
you should still create an =rsa= key as well. Each key type is stored
in a different file, so its OK to have multiple types installed on the
same machine.

**** Create the new SSH keys

Create the =rsa= key type:

: ssh-keygen -t rsa -f ~/.ssh/id_rsa

Create the =ed25519= key type:

: ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519

You will be prompted to enter an encryption passphrase for each file,
which you should definitely not skip!

** Setup the ssh-agent

Because your keyfiles are encrypted with a passphrase, you need to
enter the passphrase everytime you use it. This is inconvenient, so
you can run =ssh-agent= to temporarily store your key/identity in
memory, and therefore you only need to enter your passphrase once,
when you log in. (In the case of the solokey, the key is never held in
memory, but you still need to hold the identity of it in the
ssh-agent.)

Keychain is a program that helps you setup the ssh-agent. Install
=keychain=:

: # On Fedora:
: sudo dnf install keychain
:
: # On Debian / Ubuntu machines:
: sudo apt install keychain
:
: # On Arch Linux machines:
: sudo pacman -S keychain

To configure keychain, edit your =~/.bashrc= file:

: # Put this line in your ~/.bashrc:
: # (If you're using my config, this is already in it.)
: eval $(keychain --eval --quiet)

Log out of your desktop session, and log back in. Open your terminal,
and you should be automatically prompted to enter your SSH passphrase.
Once you have entered the passphrase, the SSH key will remain resident
in memory until you log out.

Double check that the key has been loaded, run:

: ssh-add -L

The above should print your public key, loaded into the running
=ssh-agent=. Now you should be able to use your key without entering a
passphrase. Copy the output and upload it to your services as your
authorized key. For servers, put the key into
=~/.ssh/authorized_keys=. For hosted services, like GitHub, paste the
key into your SSH settings page.

** Add your solokey identity per session

Apparently, keychain does not yet know how to load the Solokey
automatically. You must add the Solokey to the ssh-agent manually, one
time, each time you boot your workstation:

: # Do this to load your Solokey into the ssh-agent:
: ssh-add -K

You will be prompted one time to enter your Solokey pin to unlock the
key.
